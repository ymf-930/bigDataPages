/*!
  * bin-ui-next v0.5.0
  * (c) 2021 wangbin
  * @license MIT
  */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var isServer = typeof window === 'undefined';

var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
}; // 监听事件


var on$1 = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}(); // 移除事件

var off$1 = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}(); // 监听一次事件

function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
} // 添加class

function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }

  if (!el.classList) {
    el.className = curClass;
  }
} // 移除一个class样式

function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }

  if (!el.classList) {
    el.className = trim(curClass);
  }
} // getStyle

function getStyle(element, styleName) {
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'cssFloat';
  }

  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
} // 获取浏览器滚动条宽度

function getScrollBarWidth() {
  var scrollBarWidth;
  if (isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;
  var outer = document.createElement('div');
  outer.className = 'bin-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';
  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
}
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g; // eslint-disable-line

var MOZ_HACK_REGEXP = /^moz([A-Z])/; // eslint-disable-line

function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
} // scrollTop animation


function scrollTop(el, from, to, duration, endCallback) {
  if (from === void 0) {
    from = 0;
  }

  if (duration === void 0) {
    duration = 500;
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || function (callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }

  var difference = Math.abs(from - to);
  var step = Math.ceil(difference / duration * 50);

  function scroll(start, end, step) {
    if (start === end) {
      endCallback && endCallback();
      return;
    }

    var d = start + step > end ? end : start + step;

    if (start > end) {
      d = start - step < end ? end : start - step;
    }

    if (el === window) {
      window.scrollTo(d, d);
    } else {
      el.scrollTop = d;
    }

    window.requestAnimationFrame(function () {
      return scroll(d, end, step);
    });
  }

  scroll(from, to, step);
}
var stop = function stop(e) {
  return e.stopPropagation();
};

var script$1K = {
  name: 'BAnchor',
  props: {
    icon: String,
    iconSize: Number,
    activeColor: String,
    offsetTop: {
      type: Number,
      default: 0
    },
    bounds: {
      type: Number,
      default: 5
    },
    showInk: Boolean,
    scrollOffset: {
      type: Number,
      default: 0
    },
    target: String
  },
  emits: ['select'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var linksRef = vue.ref([]); // 用于获取所有子组件示例

    var data = vue.reactive({
      inkTop: 8,
      currentLink: '',
      // current show link =>  #href -> currentLink = #href
      currentId: '',
      // current show title id =>  #href -> currentId = href
      titlesOffsetArr: []
    });
    var el = vue.ref(null);
    var container = vue.ref(null);
    var animating = false;
    var iconStyle = vue.computed(function () {
      var size = props.iconSize ? props.iconSize : 14;
      return {
        width: size + "px",
        height: size + "px",
        fontSize: size + "px",
        top: data.inkTop + "px",
        transform: "translate(-" + (size - 2) * 0.5 + "px, -" + (size - 14) / 2 + "px)"
      };
    });
    var activeColorStr = vue.computed(function () {
      var colorMap = {
        primary: '#1089ff',
        success: '#52c41a',
        info: '#35495E',
        warning: '#fa8c16',
        danger: '#f5222d'
      };
      return props.activeColor ? colorMap[props.activeColor] ? colorMap[props.activeColor] : props.activeColor : null;
    });

    var chooseLink = function chooseLink(current) {
      data.currentLink = current;
      data.currentId = current.slice(1);
      emit('select', data.currentLink);
      var anchor = document.getElementById(data.currentId);
      if (!anchor) return;
      handleScrollTo(anchor.offsetTop);
      handleSetInkTop();
    };

    vue.provide('BAnchor', {
      props: props,
      data: data,
      linksRef: linksRef
    });
    vue.provide('chooseLink', chooseLink);

    var handleScroll = function handleScroll() {
      if (animating) return;
      updateTitleOffset();
      var scrollTop = el.value.pageYOffset || el.value.scrollTop;
      getCurrentScrollAtTitleId(scrollTop);
    };

    var updateTitleOffset = function updateTitleOffset() {
      var links = linksRef.value.map(function (link) {
        return link.href;
      });
      var idArr = links.map(function (link) {
        return link.split('#')[1];
      });
      var offsetArr = [];
      idArr.forEach(function (id) {
        var titleEle = document.getElementById(id);

        if (titleEle) {
          offsetArr.push({
            link: "#" + id,
            offset: titleEle.offsetTop - props.scrollOffset
          });
        }
      });
      data.titlesOffsetArr = offsetArr;
    };

    var getCurrentScrollAtTitleId = function getCurrentScrollAtTitleId(scrollTop) {
      var i = -1;
      var len = data.titlesOffsetArr.length;
      var titleItem = {
        link: '#',
        offset: 0
      };
      scrollTop += props.bounds;

      while (++i < len) {
        var currentEle = data.titlesOffsetArr[i];
        var nextEle = data.titlesOffsetArr[i + 1];

        if (scrollTop >= currentEle.offset && scrollTop < (nextEle && nextEle.offset || Infinity)) {
          titleItem = data.titlesOffsetArr[i];
          break;
        }
      }

      data.currentLink = titleItem.link;
      handleSetInkTop();
    };

    var handleSetInkTop = function handleSetInkTop() {
      var currentLinkElementA = container.value.querySelector("a[data-href=\"" + data.currentLink + "\"]");
      if (!currentLinkElementA) return;
      var elementATop = currentLinkElementA.offsetTop;
      data.inkTop = elementATop < 0 ? props.offsetTop : elementATop;
    };

    var handleScrollTo = function handleScrollTo(to) {
      var offsetTop = to - props.scrollOffset;
      animating = true;
      var currentPos = el.value.pageYOffset || el.value.scrollTop;
      scrollTop(el.value, currentPos, offsetTop, 1000, function () {
        animating = false;
      });
    };

    vue.onMounted(function () {
      el.value = window;

      if (props.target) {
        el.value = document.querySelector(props.target);

        if (!el.value) {
          throw new Error("target is not existed: " + props.target);
        }
      }

      on$1(el.value, 'scroll', handleScroll);
      on$1(window, 'resize', handleScroll);
      vue.nextTick(function () {
        handleScroll();
        handleSetInkTop();
        updateTitleOffset();
      });
    });
    vue.onBeforeUnmount(function () {
      off$1(el.value, 'scroll', handleScroll);
      off$1(window, 'resize', handleScroll);
    });
    return _extends$2({
      el: el,
      container: container,
      linksRef: linksRef
    }, vue.toRefs(data), {
      iconStyle: iconStyle,
      activeColorStr: activeColorStr
    });
  }
};

var _hoisted_1$11 = {
  class: "bin-anchor-wrapper",
  ref: "container"
};
var _hoisted_2$H = {
  class: "bin-anchor"
};
var _hoisted_3$v = {
  class: "bin-anchor-ink"
};
function render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  return vue.openBlock(), vue.createBlock("div", _hoisted_1$11, [vue.createVNode("div", _hoisted_2$H, [vue.createVNode("div", _hoisted_3$v, [$props.icon ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
    key: 0,
    name: $props.icon,
    style: $setup.iconStyle,
    color: $setup.activeColorStr
  }, null, 8
  /* PROPS */
  , ["name", "style", "color"])) : vue.createCommentVNode("v-if", true), vue.withDirectives(vue.createVNode("span", {
    class: "bin-anchor-ink-ball",
    style: {
      borderColor: $setup.activeColorStr,
      top: _ctx.inkTop + "px"
    }
  }, null, 4
  /* STYLE */
  ), [[vue.vShow, !$props.icon && $props.showInk]]), vue.withDirectives(vue.createVNode("span", {
    class: "bin-anchor-ink-line",
    style: {
      backgroundColor: $setup.activeColorStr,
      top: _ctx.inkTop + "px"
    }
  }, null, 4
  /* STYLE */
  ), [[vue.vShow, !$props.icon && !$props.showInk]])]), vue.renderSlot(_ctx.$slots, "default")])], 512
  /* NEED_PATCH */
  );
}

script$1K.render = render$1F;
script$1K.__file = "src/components/anchor/anchor.vue";

script$1K.install = function (app) {
  app.component(script$1K.name, script$1K);
};

var script$1J = {
  name: 'BAnchorLink',
  props: {
    href: String,
    title: String,
    scrollOffset: {
      type: Number,
      default: 0
    }
  },
  setup: function setup(props) {
    var prefix = 'bin-anchor-link';
    var parent = vue.inject('BAnchor');
    var selectLink = vue.inject('chooseLink');
    var anchorLinkClasses = vue.computed(function () {
      return [prefix, parent.data.currentLink === props.href ? prefix + "-active" : ''];
    });
    var activeColor = vue.computed(function () {
      return {
        color: parent.data.currentLink === props.href ? parent.props.activeColor : null
      };
    });
    parent.linksRef.value = [].concat(parent.linksRef.value, [props]);

    var goAnchor = function goAnchor() {
      selectLink(props.href);
    };

    return {
      parent: parent,
      selectLink: selectLink,
      anchorLinkClasses: anchorLinkClasses,
      activeColor: activeColor,
      goAnchor: goAnchor
    };
  }
};

function render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.anchorLinkClasses
  }, [vue.createVNode("a", {
    class: "bin-anchor-link-title",
    href: $props.href,
    "data-href": $props.href,
    style: $setup.activeColor,
    onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
      return $setup.goAnchor && $setup.goAnchor.apply($setup, arguments);
    }, ["prevent"])),
    title: $props.title
  }, vue.toDisplayString($props.title), 13
  /* TEXT, STYLE, PROPS */
  , ["href", "data-href", "title"]), vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$1J.render = render$1E;
script$1J.__file = "src/components/anchor/anchor-link.vue";

script$1J.install = function (app) {
  app.component(script$1J.name, script$1J);
};

var script$1I = {
  name: 'BIcon',
  props: {
    name: {
      type: String,
      default: ''
    },
    size: [Number, String],
    color: String,
    type: {
      type: String,
      validator: function validator(val) {
        return ['icon', 'button'].includes(val);
      },
      default: 'icon'
    }
  },
  emits: ['click'],
  computed: {
    iconStyle: function iconStyle() {
      return {
        fontSize: this.size ? this.size + "px" : null,
        color: this.color,
        cursor: this.type === 'button' ? 'pointer' : null
      };
    }
  },
  methods: {
    handleClick: function handleClick() {
      if (this.type === 'button') {
        this.$emit('click');
      }
    }
  }
};

function render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("i", {
    class: ['b-iconfont', 'b-icon-' + $props.name],
    style: $options.iconStyle,
    onClick: _cache[1] || (_cache[1] = function () {
      return $options.handleClick && $options.handleClick.apply($options, arguments);
    })
  }, null, 6
  /* CLASS, STYLE */
  );
}

script$1I.render = render$1D;
script$1I.__file = "src/components/icon/icon.vue";

script$1I.install = function (app) {
  app.component(script$1I.name, script$1I);
};

var TEMPLATE = 'template';
var PatchFlags = {
  TEXT: 1,
  CLASS: 2,
  STYLE: 4,
  PROPS: 8,
  FULL_PROPS: 16,
  HYDRATE_EVENTS: 32,
  STABLE_FRAGMENT: 64,
  KEYED_FRAGMENT: 128,
  UNKEYED_FRAGMENT: 256,
  NEED_PATCH: 512,
  DYNAMIC_SLOTS: 1024,
  HOISTED: -1,
  BAIL: -2
};
var isFragment = function isFragment(node) {
  return node.type === vue.Fragment;
};
var isComment = function isComment(node) {
  return node.type === vue.Comment;
};
var isTemplate = function isTemplate(node) {
  return node.type === TEMPLATE;
};
/**
 * get a valid child node (not fragment nor comment)
 * @param node {VNode} node to be searched
 * @param depth {number} depth to be searched
 */

function getChildren(node, depth) {
  if (isComment(node)) return;

  if (isFragment(node) || isTemplate(node)) {
    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : undefined;
  }

  return node;
}
/**
 * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if
 * @param node {VNode} node to be tested
 */


var isValidElementNode = function isValidElementNode(node) {
  return !(isFragment(node) || isComment(node));
};
var getFirstValidNode = function getFirstValidNode(nodes, maxDepth) {
  if (maxDepth === void 0) {
    maxDepth = 3;
  }

  if (Array.isArray(nodes)) {
    return getChildren(nodes[0], maxDepth);
  } else {
    return getChildren(nodes, maxDepth);
  }
};
function renderIf(condition, node, props, children, patchFlag, patchProps) {
  return condition ? renderBlock(node, props, children, patchFlag, patchProps) : vue.createCommentVNode('v-if', true);
}
function renderBlock(node, props, children, patchFlag, patchProps) {
  return vue.openBlock(), vue.createBlock(node, props, children, patchFlag, patchProps);
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main$1 = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement$1(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement$1(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$1(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement$1(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle$1(offsetParent).position !== 'static') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top) {
      sideY = bottom; // $FlowFixMe[prop-missing]

      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right; // $FlowFixMe[prop-missing]

      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide$1(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$2 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide$1
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$2 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset$1
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce$1(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format$1(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format$1(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format$1(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle$1(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$2];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
(process.env.NODE_ENV !== 'production')
    ? Object.freeze({})
    : {};
(process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];
const NOOP = () => { };
const isArray$1 = Array.isArray;
const isFunction$2 = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isObject$2 = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject$2(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));

/**
 * Generate random number in range [0, 1000]
 * Maybe replace with [uuid](https://www.npmjs.com/package/uuid)
 */

var generateId$1 = function generateId() {
  return Math.floor(Math.random() * 10000);
};
var isBool = function isBool(val) {
  return typeof val === 'boolean';
};
var isNumber = function isNumber(val) {
  return typeof val === 'number';
};
var isHTMLElement = function isHTMLElement(val) {
  return toRawType(val).startsWith('HTML');
};
var clearTimer$1 = function clearTimer(timer) {
  clearTimeout(timer.value);
  timer.value = null;
};
var autoprefixer = function autoprefixer(style) {
  var rules = ['transform', 'transition', 'animation'];
  var prefixes = ['ms-', 'webkit-'];
  rules.forEach(function (rule) {
    var value = style[rule];

    if (rule && value) {
      prefixes.forEach(function (prefix) {
        style[prefix + rule] = value;
      });
    }
  });
  return style;
};
var getValueByPath = function getValueByPath(obj, paths) {
  if (paths === void 0) {
    paths = '';
  }

  var ret = obj;
  paths.split('.').map(function (path) {
    var _ret;

    ret = (_ret = ret) == null ? void 0 : _ret[path];
  });
  return ret;
};
function getPropByPath(obj, path, strict) {
  var _tempObj;

  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  var keyArr = path.split('.');
  var i = 0;

  for (i; i < keyArr.length - 1; i++) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];

    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }

      break;
    }
  }

  return {
    o: tempObj,
    k: keyArr[i],
    v: (_tempObj = tempObj) == null ? void 0 : _tempObj[keyArr[i]]
  };
}
var isIE = function isIE() {
  return !isServer && !isNaN(Number(document.DOCUMENT_NODE));
};
var isEdge = function isEdge() {
  return !isServer && navigator.userAgent.indexOf('Edge') > -1;
}; // export const valueEquals

var escapeRegexpString = function escapeRegexpString(value) {
  if (value === void 0) {
    value = '';
  }

  return String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
};
/**
 * Unwraps refed value
 * @param ref Refed value
 */

function $(ref) {
  return ref.value;
}
function isUndefined(val) {
  return val === void 0;
}
function arrayFlat(arr) {
  return arr.reduce(function (acm, item) {
    var val = Array.isArray(item) ? arrayFlat(item) : item;
    return acm.concat(val);
  }, []);
}
function deduplicate(arr) {
  return Array.from(new Set(arr));
} // coerce truthy value to array

var coerceTruthyValueToArray = function coerceTruthyValueToArray(arr) {
  if (!arr && arr !== 0) {
    return [];
  }

  return Array.isArray(arr) ? arr : [arr];
};
function isEmpty(val) {
  return !val && val !== 0 || isArray$1(val) && !val.length || isObject$2(val) && !Object.keys(val).length;
}

function buildModifier(props, externalModifiers) {
  if (externalModifiers === void 0) {
    externalModifiers = [];
  }

  var arrow = props.arrow,
      arrowOffset = props.arrowOffset,
      offset = props.offset,
      gpuAcceleration = props.gpuAcceleration;
  var modifiers = [{
    name: 'offset',
    options: {
      offset: [0, offset != null ? offset : 12]
    }
  }, {
    name: 'preventOverflow',
    options: {
      padding: {
        top: 2,
        bottom: 2,
        left: 5,
        right: 5
      }
    }
  }, {
    name: 'flip',
    options: {
      padding: 5
    }
  }, {
    name: 'computeStyles',
    options: {
      gpuAcceleration: gpuAcceleration,
      adaptive: gpuAcceleration
    }
  } // tippyModifier,
  ];

  if (arrow) {
    modifiers.push({
      name: 'arrow',
      options: {
        element: arrow,
        // the arrow size is an equailateral triangle with 10px side length, the 3rd side length ~ 14.1px
        // adding a offset to the ceil of 4.1 should be 5 this resolves the problem of arrow overflowing out of popper.
        padding: arrowOffset != null ? arrowOffset : 5
      }
    });
  }

  modifiers.push.apply(modifiers, externalModifiers);
  return modifiers;
}

function usePopperOptions(props, state) {
  return vue.computed(function () {
    var _props$popperOptions;

    return _extends$2({
      placement: props.placement
    }, props.popperOptions, {
      // Avoiding overriding modifiers.
      modifiers: buildModifier({
        arrow: state.arrow.value,
        arrowOffset: props.arrowOffset,
        offset: props.offset,
        gpuAcceleration: props.gpuAcceleration
      }, (_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers)
    });
  });
}

var $ELEMENT = {};
var transferIndex = 0;

function transferIncrease() {
  return ++transferIndex + $ELEMENT.zIndex;
}

var setConfig = function setConfig(option) {
  $ELEMENT = option;
};

var Theme = {
  DARK: 'dark',
  LIGHT: 'light'
};
var DEFAULT_TRIGGER = 'hover';
var defaultProps$2 = {
  // the arrow size is an equailateral triangle with 10px side length, the 3rd side length ~ 14.1px
  // adding a offset to the ceil of 4.1 should be 5 this resolves the problem of arrow overflowing out of popper.
  arrowOffset: {
    type: Number,
    default: 5
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  boundariesPadding: {
    type: Number,
    default: 0
  },
  content: {
    type: String,
    default: ''
  },
  class: {
    type: String,
    default: ''
  },
  style: Object,
  closeDelay: {
    type: Number,
    default: 200
  },
  cutoff: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  theme: {
    type: String,
    default: Theme.DARK
  },
  enterable: {
    type: Boolean,
    default: true
  },
  hideAfter: {
    type: Number,
    default: 0
  },
  manualMode: {
    type: Boolean,
    default: false
  },
  showAfter: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    default: 'top'
  },
  popperClass: {
    type: String,
    default: ''
  },
  pure: {
    type: Boolean,
    default: false
  },
  // Once this option were given, the entire popper is under the users' control, top priority
  popperOptions: {
    type: Object,
    default: function _default() {
      return null;
    }
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  strategy: {
    type: String,
    default: 'fixed'
  },
  transition: {
    type: String,
    default: 'fade-in-linear'
  },
  trigger: {
    type: [String, Array],
    default: DEFAULT_TRIGGER
  },
  visible: {
    type: Boolean,
    default: undefined
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  }
};

var UPDATE_VISIBLE_EVENT$1 = 'update:visible';
function usePopper (props, ctx) {
  var arrowRef = vue.ref(null);
  var triggerRef = vue.ref(null);
  var popperRef = vue.ref(null);
  var popperId = "bin-popper-" + generateId$1();
  var popperInstance = null;
  var showTimer = null;
  var hideTimer = null;
  var triggerFocused = false;

  var isManualMode = function isManualMode() {
    return props.manualMode || props.trigger === 'manual';
  };

  var popperStyle = vue.ref({
    zIndex: transferIncrease()
  });
  var popperOptions = usePopperOptions(props, {
    arrow: arrowRef
  });
  var state = vue.reactive({
    visible: !!props.visible
  }); // visible has been taken by props.visible, avoiding name collision
  // Either marking type here or setter parameter

  var visibility = vue.computed({
    get: function get() {
      if (props.disabled) {
        return false;
      } else {
        return isBool(props.visible) ? props.visible : state.visible;
      }
    },
    set: function set(val) {
      if (isManualMode()) return;
      isBool(props.visible) ? ctx.emit(UPDATE_VISIBLE_EVENT$1, val) : state.visible = val;
    }
  });

  function _show() {
    if (props.hideAfter > 0) {
      hideTimer = window.setTimeout(function () {
        _hide();
      }, props.hideAfter);
    }

    visibility.value = true;
  }

  function _hide() {
    visibility.value = false;
  }

  function clearTimers() {
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
  }

  var show = function show() {
    if (isManualMode() || props.disabled) return;
    clearTimers();

    if (props.showAfter === 0) {
      _show();
    } else {
      showTimer = window.setTimeout(function () {
        _show();
      }, props.showAfter);
    }
  };

  var hide = function hide() {
    if (isManualMode()) return;
    clearTimers();

    if (props.closeDelay > 0) {
      hideTimer = window.setTimeout(function () {
        close();
      }, props.closeDelay);
    } else {
      close();
    }
  };

  var close = function close() {
    _hide();

    if (props.disabled) {
      doDestroy(true);
    }
  };

  function onPopperMouseEnter() {
    // if trigger is click, user won't be able to close popper when
    // user tries to move the mouse over popper contents
    if (props.enterable && props.trigger !== 'click') {
      clearTimeout(hideTimer);
    }
  }

  function onPopperMouseLeave() {
    var trigger = props.trigger;
    var shouldPrevent = isString(trigger) && (trigger === 'click' || trigger === 'focus') || // we'd like to test array type trigger here, but the only case we need to cover is trigger === 'click' or
    // trigger === 'focus', because that when trigger is string
    // trigger.length === 1 and trigger[0] === 5 chars string is mutually exclusive.
    // so there will be no need to test if trigger is array type.
    trigger.length === 1 && (trigger[0] === 'click' || trigger[0] === 'focus');
    if (shouldPrevent) return;
    hide();
  }

  function initializePopper() {
    if (!$(visibility)) {
      return;
    }

    var unwrappedTrigger = $(triggerRef);

    var _trigger = isHTMLElement(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;

    popperInstance = createPopper(_trigger, $(popperRef), $(popperOptions));
    popperInstance.update();
  }

  function doDestroy(forceDestroy) {
    /* istanbul ignore if */
    if (!popperInstance || $(visibility) && !forceDestroy) return;
    detachPopper();
  }

  function detachPopper() {
    var _popperInstance;

    (_popperInstance = popperInstance) == null ? void 0 : _popperInstance.destroy == null ? void 0 : _popperInstance.destroy();
    popperInstance = null;
  }

  var events = {};

  function update() {
    if (!$(visibility)) {
      return;
    }

    if (popperInstance) {
      popperInstance.update();
    } else {
      initializePopper();
    }
  }

  function onVisibilityChange(toState) {
    if (toState) {
      popperStyle.value.zIndex = transferIncrease();
      initializePopper();
    }
  }

  if (!isManualMode()) {
    var toggleState = function toggleState() {
      if ($(visibility)) {
        hide();
      } else {
        show();
      }
    };

    var popperEventsHandler = function popperEventsHandler(e) {
      e.stopPropagation();

      switch (e.type) {
        case 'click':
          {
            if (triggerFocused) {
              // reset previous focus event
              triggerFocused = false;
            } else {
              toggleState();
            }

            break;
          }

        case 'mouseenter':
          {
            show();
            break;
          }

        case 'mouseleave':
          {
            hide();
            break;
          }

        case 'focus':
          {
            triggerFocused = true;
            show();
            break;
          }

        case 'blur':
          {
            triggerFocused = false;
            hide();
            break;
          }
      }
    };

    var triggerEventsMap = {
      click: ['onClick'],
      hover: ['onMouseenter', 'onMouseleave'],
      focus: ['onFocus', 'onBlur']
    };

    var mapEvents = function mapEvents(t) {
      triggerEventsMap[t].forEach(function (event) {
        events[event] = popperEventsHandler;
      });
    };

    if (isArray$1(props.trigger)) {
      Object.values(props.trigger).forEach(mapEvents);
    } else {
      mapEvents(props.trigger);
    }
  }

  vue.watch(popperOptions, function (val) {
    if (!popperInstance) return;
    popperInstance.setOptions(val);
    popperInstance.update();
  });
  vue.watch(visibility, onVisibilityChange);
  return {
    update: update,
    doDestroy: doDestroy,
    show: show,
    hide: hide,
    onPopperMouseEnter: onPopperMouseEnter,
    onPopperMouseLeave: onPopperMouseLeave,
    onAfterEnter: function onAfterEnter() {
      ctx.emit('after-enter');
    },
    onAfterLeave: function onAfterLeave() {
      detachPopper();
      ctx.emit('after-leave');
    },
    onBeforeEnter: function onBeforeEnter() {
      ctx.emit('before-enter');
    },
    onBeforeLeave: function onBeforeLeave() {
      ctx.emit('before-leave');
    },
    initializePopper: initializePopper,
    isManualMode: isManualMode,
    arrowRef: arrowRef,
    events: events,
    popperId: popperId,
    popperInstance: popperInstance,
    popperRef: popperRef,
    popperStyle: popperStyle,
    triggerRef: triggerRef,
    visibility: visibility
  };
}

function renderPopper(props, children) {
  var theme = props.theme,
      name = props.name,
      stopPopperMouseEvent = props.stopPopperMouseEvent,
      popperClass = props.popperClass,
      popperStyle = props.popperStyle,
      popperRef = props.popperRef,
      pure = props.pure,
      popperId = props.popperId,
      visibility = props.visibility,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onAfterEnter = props.onAfterEnter,
      onAfterLeave = props.onAfterLeave,
      onBeforeEnter = props.onBeforeEnter,
      onBeforeLeave = props.onBeforeLeave;
  var kls = [popperClass, 'bin-popper', 'is-' + theme, pure ? 'is-pure' : ''];
  /**
   * Equivalent to
   * <transition :name="name">
   *  <div
   *    v-show="visibility"
   *    :aria-hidden="!visibility"
   *    :class="kls"
   *    ref="popperRef"
   *    role="tooltip"
   *    @mouseenter=""
   *    @mouseleave=""
   *    @click="">
   *    <slot />
   *  </div>
   * </transition>
   */

  var mouseUpAndDown = stopPopperMouseEvent ? stop : NOOP;
  return vue.createVNode(vue.Transition, {
    name: name,
    'onAfterEnter': onAfterEnter,
    'onAfterLeave': onAfterLeave,
    'onBeforeEnter': onBeforeEnter,
    'onBeforeLeave': onBeforeLeave
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode('div', {
        'aria-hidden': String(!visibility),
        class: kls,
        style: popperStyle != null ? popperStyle : {},
        id: popperId,
        ref: popperRef != null ? popperRef : 'popperRef',
        role: 'tooltip',
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onClick: stop,
        onMouseDown: mouseUpAndDown,
        onMouseUp: mouseUpAndDown
      }, children, PatchFlags.CLASS | PatchFlags.STYLE | PatchFlags.PROPS | PatchFlags.HYDRATE_EVENTS, ['aria-hidden', 'onMouseenter', 'onMouseleave', 'onMouseDown', 'onMouseUp', 'onClick', 'id']), [[vue.vShow, visibility]])];
    })
  }, PatchFlags.PROPS, ['name', 'onAfterEnter', 'onAfterLeave', 'onBeforeEnter', 'onBeforeLeave']);
}

/**
 * @description 返回这个样式的颜色值
 * @param {String} type 样式名称 [ primary | success | warning | danger | text ]
 */
function typeColor(type) {
  if (type === void 0) {
    type = 'default';
  }

  var color = '';

  switch (type) {
    case 'primary':
      color = '#1089ff';
      break;

    case 'success':
      color = '#52c41a';
      break;

    case 'warning':
      color = '#fa8c16';
      break;

    case 'danger':
      color = '#f5222d';
      break;

    case 'default':
      color = '#35495E';
      break;

    default:
      color = type;
      break;
  }

  return color;
}

var print = function print(text, type, back) {
  if (type === void 0) {
    type = 'default';
  }

  if (back === void 0) {
    back = false;
  }

  if (typeof text === 'object') {
    // 如果是对象则调用打印对象方式
    console.dir(text);
    return;
  }

  if (back) {
    // 如果是打印带背景图的
    console.log("%c " + text + " ", "background:" + typeColor(type) + "; padding: 2px; border-radius: 2px;color: #fff;");
  } else {
    console.log("%c " + text + " ", "color: " + typeColor(type) + ";");
  }
};

var pretty = function pretty(title, text, type) {
  if (type === void 0) {
    type = 'primary';
  }

  console.log("%c " + title + " %c " + text + " %c", "background:" + typeColor(type) + ";border:1px solid " + typeColor(type) + "; padding: 1px; border-radius: 2px 0 0 2px; color: #fff;", "border:1px solid " + typeColor(type) + "; padding: 1px; border-radius: 0 2px 2px 0; color: " + typeColor(type) + ";", 'background:transparent');
};

var primary = function primary(text, back) {
  if (back === void 0) {
    back = false;
  }

  print(text, 'primary', back);
};

var success = function success(text, back) {
  if (back === void 0) {
    back = false;
  }

  print(text, 'success', back);
};

var info = function info(text, back) {
  if (back === void 0) {
    back = false;
  }

  print(text, 'info', back);
};

var warning$1 = function warning(text, back) {
  if (back === void 0) {
    back = false;
  }

  print(text, 'warning', back);
};

var danger = function danger(text, back) {
  if (back === void 0) {
    back = false;
  }

  print(text, 'danger', back);
};

var log = {
  print: print,
  pretty: pretty,
  primary: primary,
  info: info,
  success: success,
  warning: warning$1,
  danger: danger
};
var throwError = function throwError(scope, m) {
  pretty(scope, m, 'danger');
};
var throwWarn = function throwWarn(scope, m) {
  pretty(scope, m, 'warning');
};

function renderTrigger(trigger, extraProps) {
  var firstElement = getFirstValidNode(trigger, 1);

  if (!firstElement) {
    throwError('renderTrigger', 'trigger expects single rooted node');
  }

  return vue.cloneVNode(firstElement, extraProps);
}

function renderArrow(showArrow) {
  return showArrow ? (vue.openBlock(), vue.createBlock('div', {
    ref: 'arrowRef',
    class: 'bin-popper__arrow',
    'data-popper-arrow': ''
  }, null, PatchFlags.NEED_PATCH)) : (vue.openBlock(), vue.createBlock(vue.Comment, null, ''));
}

var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: 'transitionstart',
    WebkitTransition: 'webkitTransitionStart',
    MozTransition: 'mozTransitionStart',
    OTransition: 'oTransitionStart',
    msTransition: 'MSTransitionStart'
  },
  animationstart: {
    animation: 'animationstart',
    WebkitAnimation: 'webkitAnimationStart',
    MozAnimation: 'mozAnimationStart',
    OAnimation: 'oAnimationStart',
    msAnimation: 'MSAnimationStart'
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },
  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};
var startEvents = [];
var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }

  function process(EVENT_NAME_MAP, events) {
    for (var baseEventName in EVENT_NAME_MAP) {
      // eslint-disable-next-line no-prototype-builtins
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];

        for (var styleName in baseEvents) {
          if (styleName in style) {
            events.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }

  process(START_EVENT_NAME_MAP, startEvents);
  process(END_EVENT_NAME_MAP, endEvents);
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  // Start events
  startEvents: startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    startEvents.forEach(function (startEvent) {
      addEventListener(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }

    startEvents.forEach(function (startEvent) {
      removeEventListener(node, startEvent, eventListener);
    });
  },
  // End events
  endEvents: endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }

    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

var styleForPesudo = null; // 重置效果

function resetEffect$1(node) {
  if (!node || !(node instanceof Element)) {
    return;
  }

  node.parentNode && node.parentNode.removeChild(node);
  TransitionEvents.removeEndEventListener(node, onTransitionEnd$1);
}

function onTransitionEnd$1(e) {
  if (!e || e.animationName !== 'fadeEffect') {
    return;
  }

  resetEffect$1(e.target);
}

var ClickAnimation = {
  beforeMount: function beforeMount(el, binding) {
    el.addEventListener('click', function (e) {
      var node = el;
      var waveColor = getComputedStyle(node).getPropertyValue('border-top-color') || // Firefox Compatible
      getComputedStyle(node).getPropertyValue('border-color') || getComputedStyle(node).getPropertyValue('background-color');

      if (node) {
        node.style.position = 'relative';
        var ripple = node.querySelector('.bin-click-animating-node');
        resetEffect$1(ripple);
        ripple = document.createElement('span');
        ripple.className = 'bin-click-animating-node';
        node.appendChild(ripple); // 设置颜色

        styleForPesudo = styleForPesudo || document.createElement('style');

        if (waveColor && waveColor !== '#ffffff' && waveColor !== 'rgb(255, 255, 255)' && waveColor !== 'transparent') {
          styleForPesudo.innerHTML = "\n            .bin-click-animating-node {\n              --bin-wave-shadow-color: " + waveColor + ";\n            }";

          if (!document.body.contains(styleForPesudo)) {
            document.body.appendChild(styleForPesudo);
          }
        }

        TransitionEvents.addEndEventListener(ripple, onTransitionEnd$1);
        return false;
      }
    }, false);
  }
};

var nodeList = new Map();
var startClick;

if (!isServer) {
  on$1(document, 'mousedown', function (e) {
    return startClick = e;
  });
  on$1(document, 'mouseup', function (e) {
    for (var _iterator = _createForOfIteratorHelperLoose(nodeList.values()), _step; !(_step = _iterator()).done;) {
      var handlers = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(handlers), _step2; !(_step2 = _iterator2()).done;) {
        var documentHandler = _step2.value.documentHandler;
        documentHandler(e, startClick);
      }
    }
  });
}

function createDocumentHandler(el, binding) {
  var excludes = [];

  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else {
    // due to current implementation on binding type is wrong the type casting is necessary here
    excludes.push(binding.arg);
  }

  return function (mouseup, mousedown) {
    var popperRef = binding.instance.popperRef;
    var mouseUpTarget = mouseup.target;
    var mouseDownTarget = mousedown.target;
    var isBound = !binding || !binding.instance;
    var isTargetExists = !mouseUpTarget || !mouseDownTarget;
    var isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    var isSelf = el === mouseUpTarget;
    var isTargetExcluded = excludes.length && excludes.some(function (item) {
      return item == null ? void 0 : item.contains(mouseUpTarget);
    }) || excludes.length && excludes.includes(mouseDownTarget);
    var isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));

    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }

    binding.value(mouseup, mousedown);
  };
}

var ClickOutside = {
  beforeMount: function beforeMount(el, binding) {
    // there could be multiple handlers on the element
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }

    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated: function updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }

    var handlers = nodeList.get(el);
    var oldHandlerIndex = handlers.findIndex(function (item) {
      return item.bindingFn === binding.oldValue;
    });
    var newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };

    if (oldHandlerIndex >= 0) {
      // replace the old handler to the new handler
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },
  unmounted: function unmounted(el) {
    // remove all listeners when a component unmounted
    nodeList.delete(el);
  }
};

function resetEffect(node) {
  if (!node || !(node instanceof Element)) {
    return;
  }

  node.parentNode && node.parentNode.removeChild(node);
  TransitionEvents.removeEndEventListener(node, onTransitionEnd);
}

function onTransitionEnd(e) {
  if (!e || e.propertyName !== 'transform') {
    return;
  }

  resetEffect(e.target);
}

var Waves = {
  beforeMount: function beforeMount(el, binding) {
    el.addEventListener('click', function (e) {
      var wavesColor = binding.value || 'rgba(0, 0, 0, 0.15)';
      var node = el;

      if (node) {
        node.style.position = 'relative';
        node.style.overflow = 'hidden';
        var rect = node.getBoundingClientRect();
        var ripple = document.createElement('span');
        ripple.className = 'waves-ripple';
        ripple.style.height = ripple.style.width = Math.max(rect.width, rect.height) + 'px';
        node.appendChild(ripple); // 获得页面向左、向上卷动的距离

        var pageScroll = {
          left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
          top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        };
        ripple.style.top = e.pageY - rect.top - ripple.offsetHeight / 2 - pageScroll.top + 'px';
        ripple.style.left = e.pageX - rect.left - ripple.offsetWidth / 2 - pageScroll.left + 'px';
        ripple.style.backgroundColor = wavesColor;
        ripple.className = 'waves-ripple z-active';
        TransitionEvents.addEndEventListener(ripple, onTransitionEnd);
        return false;
      }
    }, false);
  }
};

var script$1H = {
  name: 'BEmpty',
  props: {
    title: {
      type: String,
      default: '暂无数据'
    }
  },
  data: function data() {
    return {
      text: this.title
    };
  },
  methods: {
    setTitle: function setTitle(title) {
      this.text = title;
    }
  }
};

var _hoisted_1$10 = {
  class: "bin-empty bin-empty-normal"
};
var _hoisted_2$G = {
  class: "bin-empty-image"
};

var _hoisted_3$u = /*#__PURE__*/vue.createVNode("svg", {
  class: "bin-empty-img-simple",
  width: "64",
  height: "41",
  viewBox: "0 0 64 41",
  xmlns: "http://www.w3.org/2000/svg"
}, [/*#__PURE__*/vue.createVNode("g", {
  transform: "translate(0 1)",
  fill: "none",
  "fill-rule": "evenodd"
}, [/*#__PURE__*/vue.createVNode("ellipse", {
  class: "bin-empty-img-simple-ellipse",
  cx: "32",
  cy: "33",
  rx: "32",
  ry: "7"
}), /*#__PURE__*/vue.createVNode("g", {
  class: "bin-empty-img-simple-g",
  "fill-rule": "nonzero"
}, [/*#__PURE__*/vue.createVNode("path", {
  d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
}), /*#__PURE__*/vue.createVNode("path", {
  d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
  class: "bin-empty-img-simple-path"
})])])], -1
/* HOISTED */
);

var _hoisted_4$l = {
  class: "bin-empty-description"
};
function render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$10, [vue.createVNode("div", _hoisted_2$G, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
    return [_hoisted_3$u];
  })]), vue.createVNode("p", _hoisted_4$l, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($data.text), 1
    /* TEXT */
    )];
  })])]);
}

script$1H.render = render$1C;
script$1H.__file = "src/components/empty/empty.vue";

var relativeCls = 'g-relative';
function createLoadingLikeDirective(Comp) {
  return {
    mounted: function mounted(el, binding) {
      var app = vue.createApp(Comp);
      var instance = app.mount(document.createElement('div'));
      var name = Comp.name;

      if (!el[name]) {
        el[name] = {};
      }

      el[name].instance = instance;
      var title = binding.arg;

      if (typeof title !== 'undefined') {
        instance.setTitle(title);
      }

      if (binding.value) {
        append(el);
      }
    },
    updated: function updated(el, binding) {
      var title = binding.arg;
      var name = Comp.name;

      if (typeof title !== 'undefined') {
        el[name].instance.setTitle(title);
      }

      if (binding.value !== binding.oldValue) {
        binding.value ? append(el) : remove(el);
      }
    }
  };

  function append(el) {
    var name = Comp.name;
    var style = getComputedStyle(el);

    if (['absolute', 'fixed', 'relative'].indexOf(style.position) === -1) {
      addClass(el, relativeCls);
    }

    el.appendChild(el[name].instance.$el);
  }

  function remove(el) {
    var name = Comp.name;
    removeClass(el, relativeCls);
    el.removeChild(el[name].instance.$el);
  }
}

var EmptyDirective = createLoadingLikeDirective(script$1H);

var prefixCls$i = 'bin-loading';
var script$1G = {
  name: 'BLoading',
  props: {
    showIcon: String,
    showText: String,
    fix: {
      type: Boolean,
      default: true
    },
    size: String
  },
  computed: {
    classes: function classes() {
      var _ref;

      return ["" + prefixCls$i, (_ref = {}, _ref[prefixCls$i + "-fix"] = this.fix, _ref[prefixCls$i + "-show-text"] = this.showText, _ref)];
    },
    textStyle: function textStyle() {
      return {
        fontSize: this.size + "px"
      };
    }
  },
  data: function data() {
    return {
      text: this.showText
    };
  },
  methods: {
    setTitle: function setTitle(title) {
      this.text = title;
    }
  }
};

var _hoisted_1$$ = {
  class: "bin-loading-inner"
};
var _hoisted_2$F = {
  key: 0
};

var _hoisted_3$t = /*#__PURE__*/vue.createVNode("svg", {
  class: "circular",
  viewBox: "25 25 50 50"
}, [/*#__PURE__*/vue.createVNode("circle", {
  class: "path",
  cx: "50",
  cy: "50",
  r: "20",
  fill: "none",
  "stroke-width": "5",
  "stroke-miterlimit": "10"
})], -1
/* HOISTED */
);

function render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade-in-linear"
  }, {
    default: vue.withCtx(function () {
      return [vue.createVNode("div", {
        class: $options.classes
      }, [vue.createVNode("div", _hoisted_1$$, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
        return [!$props.showIcon ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$F, [_hoisted_3$t])) : (vue.openBlock(), vue.createBlock("i", {
          key: 1,
          class: ["b-iconfont loading-icon icon-is-rotating", "b-icon-" + $props.showIcon]
        }, null, 2
        /* CLASS */
        ))];
      }), vue.renderSlot(_ctx.$slots, "text", {}, function () {
        return [$data.text ? (vue.openBlock(), vue.createBlock("div", {
          key: 0,
          class: "loading-text",
          style: $options.textStyle
        }, vue.toDisplayString($data.text), 5
        /* TEXT, STYLE */
        )) : vue.createCommentVNode("v-if", true)];
      })])], 2
      /* CLASS */
      )];
    }),
    _: 3
    /* FORWARDED */

  });
}

script$1G.render = render$1B;
script$1G.__file = "src/components/loading/loading.vue";

var LoadingDirective = createLoadingLikeDirective(script$1G);

var compName = 'BPopper';
var UPDATE_VISIBLE_EVENT = 'update:visible';
var script$1F = {
  name: compName,
  props: defaultProps$2,
  emits: [UPDATE_VISIBLE_EVENT, 'after-enter', 'after-leave', 'before-enter', 'before-leave'],
  setup: function setup(props, ctx) {
    if (!ctx.slots.trigger) {
      throwError(compName, 'Trigger must be provided');
    } // this is a reference that we need to pass down to child component
    // to obtain the child instance
    // return usePopper(props as IPopperOptions, ctx as SetupContext)


    var popperStates = usePopper(props, ctx);

    var forceDestroy = function forceDestroy() {
      return popperStates.doDestroy(true);
    };

    vue.onMounted(popperStates.initializePopper);
    vue.onBeforeUnmount(forceDestroy);
    vue.onActivated(popperStates.initializePopper);
    vue.onDeactivated(forceDestroy);
    return popperStates;
  },
  render: function render() {
    var _this = this;

    var $slots = this.$slots,
        appendToBody = this.appendToBody,
        kls = this.class,
        style = this.style,
        theme = this.theme,
        hide = this.hide,
        onPopperMouseEnter = this.onPopperMouseEnter,
        onPopperMouseLeave = this.onPopperMouseLeave,
        onAfterEnter = this.onAfterEnter,
        onAfterLeave = this.onAfterLeave,
        onBeforeEnter = this.onBeforeEnter,
        onBeforeLeave = this.onBeforeLeave,
        popperClass = this.popperClass,
        popperId = this.popperId,
        popperStyle = this.popperStyle,
        pure = this.pure,
        showArrow = this.showArrow,
        transition = this.transition,
        visibility = this.visibility,
        stopPopperMouseEvent = this.stopPopperMouseEvent;
    var isManual = this.isManualMode();
    var arrow = renderArrow(showArrow);
    var popper = renderPopper({
      theme: theme,
      name: transition,
      popperClass: popperClass,
      popperId: popperId,
      popperStyle: popperStyle,
      pure: pure,
      stopPopperMouseEvent: stopPopperMouseEvent,
      onMouseEnter: onPopperMouseEnter,
      onMouseLeave: onPopperMouseLeave,
      onAfterEnter: onAfterEnter,
      onAfterLeave: onAfterLeave,
      onBeforeEnter: onBeforeEnter,
      onBeforeLeave: onBeforeLeave,
      visibility: visibility
    }, [vue.renderSlot($slots, 'default', {}, function () {
      return [vue.toDisplayString(_this.content)];
    }), arrow]);

    var _t = $slots.trigger == null ? void 0 : $slots.trigger();

    var triggerProps = _extends$2({
      ariaDescribedby: popperId,
      class: kls,
      style: style,
      ref: 'triggerRef'
    }, this.events);

    var trigger = isManual ? renderTrigger(_t, triggerProps) : vue.withDirectives(renderTrigger(_t, triggerProps), [[ClickOutside, hide]]);
    return renderBlock(vue.Fragment, null, [trigger, vue.createVNode(vue.Teleport, // Vue did not support createVNode for Teleport
    {
      to: 'body',
      disabled: !appendToBody
    }, [popper], PatchFlags.PROPS, ['disabled'])]);
  }
};

script$1F.__file = "src/components/popper/src/index.vue";

script$1F.install = function (app) {
  app.component(script$1F.name, script$1F);
};

var hiddenTextarea;
var HIDDEN_STYLE = "\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n";
var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  var style = window.getComputedStyle(targetElement);
  var boxSizing = style.getPropertyValue('box-sizing');
  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  var contextStyle = CONTEXT_STYLE.map(function (name) {
    return name + ":" + style.getPropertyValue(name);
  }).join(';');
  return {
    contextStyle: contextStyle,
    paddingSize: paddingSize,
    borderSize: borderSize,
    boxSizing: boxSizing
  };
}

function calcTextareaHeight(targetElement, minRows, maxRows) {
  var _hiddenTextarea$paren;

  if (minRows === void 0) {
    minRows = 1;
  }

  if (maxRows === void 0) {
    maxRows = null;
  }

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  var _calculateNodeStyling = calculateNodeStyling(targetElement),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      contextStyle = _calculateNodeStyling.contextStyle;

  hiddenTextarea.setAttribute('style', contextStyle + ";" + HIDDEN_STYLE);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
  var height = hiddenTextarea.scrollHeight;
  var result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    var minHeight = singleRowHeight * minRows;

    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }

    height = Math.max(minHeight, height);
    result.minHeight = minHeight + "px";
  }

  if (maxRows !== null) {
    var maxHeight = singleRowHeight * maxRows;

    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }

    height = Math.min(maxHeight, height);
  }

  result.height = height + "px";
  (_hiddenTextarea$paren = hiddenTextarea.parentNode) == null ? void 0 : _hiddenTextarea$paren.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
}

var UPDATE_MODEL_EVENT = 'update:modelValue';
var CHANGE_EVENT = 'change';

function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1);},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e);}),(n.get("*")||[]).slice().map(function(n){n(t,e);});}}}

var FormKey = 'BForm';
var FormItemKey = 'BFormItem';
var FormEvents = {
  addField: 'form.addField',
  removeField: 'form.removeField',
  blur: 'form.blur',
  change: 'form.change'
};

function useFormLabelWidth() {
  var potentialLabelWidthArr = vue.ref([]);
  var autoLabelWidth = vue.computed(function () {
    if (!potentialLabelWidthArr.value.length) return '0';
    var max = Math.max.apply(Math, potentialLabelWidthArr.value);
    return max ? max + "px" : '';
  });

  function getLabelWidthIndex(width) {
    var index = potentialLabelWidthArr.value.indexOf(width);

    if (index === -1) {
      console.warn('[Element Warn][ElementForm]unexpected width ' + width);
    }

    return index;
  }

  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      var index = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }

  function deregisterLabelWidth(val) {
    var index = getLabelWidthIndex(val);
    index > -1 && potentialLabelWidthArr.value.splice(index, 1);
  }

  return {
    autoLabelWidth: autoLabelWidth,
    registerLabelWidth: registerLabelWidth,
    deregisterLabelWidth: deregisterLabelWidth
  };
}

var script$1E = {
  name: 'BForm',
  props: {
    model: Object,
    rules: Object,
    labelPosition: String,
    labelWidth: String,
    labelSuffix: {
      type: String,
      default: ''
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    disabled: Boolean,
    validateOnRuleChange: {
      type: Boolean,
      default: true
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: false
    }
  },
  emits: ['validate'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var formMitt = mitt();
    var fields = [];
    vue.watch(function () {
      return props.rules;
    }, function () {
      fields.forEach(function (field) {
        field.removeValidateEvents();
        field.addValidateEvents();
      });

      if (props.validateOnRuleChange) {
        validate(function () {
          return {};
        });
      }
    });
    formMitt.on(FormEvents.addField, function (field) {
      if (field) {
        fields.push(field);
      }
    });
    formMitt.on(FormEvents.removeField, function (field) {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    });

    var resetFields = function resetFields() {
      if (!props.model) {
        console.warn('[Element Warn][Form]model is required for resetFields to work.');
        return;
      }

      fields.forEach(function (field) {
        field.resetField();
      });
    };

    var clearValidate = function clearValidate(props) {
      if (props === void 0) {
        props = [];
      }

      var fds = props.length ? typeof props === 'string' ? fields.filter(function (field) {
        return props === field.prop;
      }) : fields.filter(function (field) {
        return props.indexOf(field.prop) > -1;
      }) : fields;
      fds.forEach(function (field) {
        field.clearValidate();
      });
    };

    var validate = function validate(callback) {
      if (!props.model) {
        console.warn('[Element Warn][Form]model is required for validate to work!');
        return;
      }

      var promise; // if no callback, return promise

      if (typeof callback !== 'function') {
        promise = new Promise(function (resolve, reject) {
          callback = function callback(valid, invalidFields) {
            if (valid) {
              resolve(true);
            } else {
              reject(invalidFields);
            }
          };
        });
      }

      if (fields.length === 0) {
        callback(true);
      }

      var valid = true;
      var count = 0;
      var invalidFields = {};

      for (var _iterator = _createForOfIteratorHelperLoose(fields), _step; !(_step = _iterator()).done;) {
        var field = _step.value;
        field.validate('', function (message, field) {
          if (message) {
            valid = false;
          }

          invalidFields = _extends$2({}, invalidFields, field);

          if (++count === fields.length) {
            callback(valid, invalidFields);
          }
        });
      }

      return promise;
    };

    var validateField = function validateField(props, cb) {
      props = [].concat(props);
      var fds = fields.filter(function (field) {
        return props.indexOf(field.prop) !== -1;
      });

      if (!fields.length) {
        console.warn('[Element Warn]please pass correct props!');
        return;
      }

      fds.forEach(function (field) {
        field.validate('', cb);
      });
    };

    var elForm = vue.reactive(_extends$2({
      formMitt: formMitt
    }, vue.toRefs(props), {
      resetFields: resetFields,
      clearValidate: clearValidate,
      validateField: validateField,
      emit: emit
    }, useFormLabelWidth()));
    vue.provide(FormKey, elForm);
    return {
      validate: validate,
      // export
      resetFields: resetFields,
      clearValidate: clearValidate,
      validateField: validateField
    };
  }
};

function render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("form", {
    class: ["bin-form", [$props.labelPosition ? 'bin-form--label-' + $props.labelPosition : '', {
      'bin-form--inline': $props.inline
    }]]
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$1E.render = render$1A;
script$1E.__file = "src/components/form/form.vue";

script$1E.install = function (app) {
  app.component(script$1E.name, script$1E);
};

var VALIDATE_STATE_MAP = {
  validating: 'b-icon-loading icon-is-rotating',
  success: 'b-icon-check-circle',
  error: 'b-icon-close-circle'
};
function useForm() {
  var BForm = vue.inject(FormKey, {});
  var BFormItem = vue.inject(FormItemKey, {});
  var validateState = vue.computed(function () {
    return BFormItem.validateState || '';
  });
  var validateIcon = vue.computed(function () {
    return VALIDATE_STATE_MAP[validateState.value];
  }); // blur, change,value

  function formEmit(type, value) {
    var _BFormItem$formItemMi;

    (_BFormItem$formItemMi = BFormItem.formItemMitt) == null ? void 0 : _BFormItem$formItemMi.emit(FormEvents[type], value);
  }

  return {
    BForm: BForm,
    BFormItem: BFormItem,
    validateState: validateState,
    validateIcon: validateIcon,
    formEmit: formEmit
  };
}

var prefixCls$h = 'bin-input';
var script$1D = {
  name: 'BInput',
  props: {
    type: {
      validator: function validator(value) {
        return ['text', 'textarea', 'password', 'url', 'email', 'date', 'number', 'tel'].includes(value);
      },
      default: 'text'
    },
    modelValue: {
      type: [String, Number],
      default: ''
    },
    size: {
      type: String,
      validator: function validator(value) {
        return ['small', 'large', 'default', 'mini', ''].includes(value);
      }
    },
    placeholder: {
      type: String,
      default: ''
    },
    maxlength: {
      type: Number
    },
    disabled: Boolean,
    icon: String,
    autosize: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    rows: {
      type: Number,
      default: 2
    },
    readonly: Boolean,
    name: String,
    number: Boolean,
    autofocus: Boolean,
    autocomplete: {
      validator: function validator(value) {
        return ['on', 'off'].includes(value);
      },
      default: 'off'
    },
    clearable: Boolean,
    elementId: String,
    wrap: {
      validator: function validator(value) {
        return ['hard', 'soft'].includes(value);
      },
      default: 'soft'
    },
    prefix: {
      type: String,
      default: ''
    },
    suffix: {
      type: String,
      default: ''
    },
    search: Boolean,
    noResize: Boolean,
    showWordCount: Boolean,
    validateEvent: {
      type: Boolean,
      default: true
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'enter', 'search', 'keydown', 'keyup', 'keypress', 'click', 'blur', 'focus', 'input', 'clear'],
  setup: function setup(props, ctx) {
    // data
    var data = vue.reactive({
      currentValue: props.modelValue,
      textareaStyles: {},
      isOnComposition: false
    });
    var inputRef = vue.ref(null);
    var textareaRef = vue.ref(null);
    var showPassword = vue.ref(false);

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        BFormItem = _useForm.BFormItem,
        validateState = _useForm.validateState,
        validateIcon = _useForm.validateIcon,
        formEmit = _useForm.formEmit; // watch


    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      setCurrentValue(val);
    }); // computed

    var wrapClasses = vue.computed(function () {
      var _ref;

      return [prefixCls$h + "-wrapper", (_ref = {}, _ref[prefixCls$h + "-wrapper-" + props.size] = !!props.size, _ref[prefixCls$h + "-type-" + props.type] = props.type, _ref[prefixCls$h + "-group-with-prepend"] = ctx.slots.prepend, _ref[prefixCls$h + "-group-with-append"] = ctx.slots.append || props.search, _ref[prefixCls$h + "-hide-icon"] = ctx.slots.append, _ref[prefixCls$h + "-with-search"] = props.search, _ref[prefixCls$h + "-with-word-count"] = props.showWordCount, _ref)];
    });
    var showPrefix = vue.computed(function () {
      return props.prefix !== '' || ctx.slots.prefix !== undefined;
    });
    var showSuffix = vue.computed(function () {
      return props.suffix !== '' || props.icon !== '' || props.search || validateState.value !== '' || ctx.slots.suffix !== undefined;
    });
    var inputDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var inputSize = vue.computed(function () {
      return props.size || BFormItem.size;
    });
    var inputType = vue.computed(function () {
      return props.type !== 'password' ? props.type : "" + (showPassword.value ? 'text' : 'password');
    });
    var inputClasses = vue.computed(function () {
      var _ref2;

      return ["" + prefixCls$h, (_ref2 = {}, _ref2[prefixCls$h + "-" + inputSize.value] = !!inputSize.value, _ref2[prefixCls$h + "-disabled"] = inputDisabled.value, _ref2[prefixCls$h + "-with-prefix"] = showPrefix.value, _ref2[prefixCls$h + "-with-suffix"] = showSuffix.value || props.search, _ref2)];
    });
    var closeClasses = vue.computed(function () {
      return [prefixCls$h + '-icon', prefixCls$h + '-icon-clear'];
    });
    var textareaStyle = vue.computed(function () {
      return _extends$2({
        resize: props.noResize ? 'none' : null
      }, data.textareaStyles);
    });
    var textareaClasses = vue.computed(function () {
      var _ref3;

      return ["" + prefixCls$h, (_ref3 = {}, _ref3[prefixCls$h + "-disabled"] = props.disabled, _ref3)];
    });
    var wordCount = vue.computed(function () {
      return data.currentValue.toString().length + (props.maxlength ? "/" + props.maxlength : '');
    }); // self methods

    var setCurrentValue = function setCurrentValue(value) {
      if (value === data.currentValue) return;
      vue.nextTick(function () {
        resizeTextarea();
      });
      data.currentValue = value;

      if (props.validateEvent) {
        formEmit('change', [value]);
      }
    };

    var resizeTextarea = function resizeTextarea() {
      var autosize = props.autosize;

      if (!autosize || props.type !== 'textarea') {
        return false;
      }

      var minRows = autosize.minRows || props.rows;
      var maxRows = autosize.maxRows || props.rows;
      data.textareaStyles = calcTextareaHeight(textareaRef.value, minRows, maxRows);
    }; // handle methods


    var handleEnter = function handleEnter(e) {
      ctx.emit('enter', e);
      if (props.search) ctx.emit('search', data.currentValue);
    };

    var handleKeydown = function handleKeydown(e) {
      ctx.emit('keydown', e);
    };

    var handleKeypress = function handleKeypress(e) {
      ctx.emit('keypress', e);
    };

    var handleKeyup = function handleKeyup(e) {
      ctx.emit('keyup', e);
    };

    var handleIconClick = function handleIconClick(e) {
      ctx.emit('click', e);
    };

    var handleFocus = function handleFocus(e) {
      ctx.emit('focus', e);
    };

    var handleBlur = function handleBlur(e) {
      ctx.emit('blur', e);

      if (props.validateEvent) {
        formEmit('blur', [props.modelValue]);
      }
    };

    var handleComposition = function handleComposition(e) {
      if (e.type === 'compositionstart') {
        data.isOnComposition = true;
      }

      if (e.type === 'compositionend') {
        data.isOnComposition = false;
        handleInput(e);
      }
    };

    var handleInput = function handleInput(e) {
      if (data.isOnComposition) return;
      var value = e.target.value;
      if (props.number && value !== '') value = Number.isNaN(Number(value)) ? value : Number(value);
      setCurrentValue(value);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      ctx.emit('input', value);
    };

    var handleChange = function handleChange(e) {
      ctx.emit(CHANGE_EVENT, e.target.value);
    };

    var handleTogglePass = function handleTogglePass() {
      showPassword.value = !showPassword.value;
    };

    var handleClear = function handleClear() {
      setCurrentValue('');
      ctx.emit(UPDATE_MODEL_EVENT, '');
      ctx.emit(CHANGE_EVENT, '');
      ctx.emit('clear');
    };

    var handleSearch = function handleSearch() {
      if (props.disabled) return false;
      inputRef == null ? void 0 : inputRef.value.focus();
      ctx.emit('search', data.currentValue);
    };

    var focus = function focus() {
      if (props.type === 'textarea') {
        textareaRef == null ? void 0 : textareaRef.value.focus();
      } else {
        inputRef == null ? void 0 : inputRef.value.focus();
      }
    };

    var blur = function blur() {
      if (props.type === 'textarea') {
        textareaRef == null ? void 0 : textareaRef.value.blur();
      } else {
        inputRef == null ? void 0 : inputRef.value.blur();
      }
    }; // mounted


    vue.onMounted(function () {
      if (props.type === 'textarea') {
        resizeTextarea();
      }
    });
    return _extends$2({
      inputRef: inputRef,
      textareaRef: textareaRef,
      showPassword: showPassword
    }, vue.toRefs(data), {
      handleEnter: handleEnter,
      handleKeydown: handleKeydown,
      handleKeypress: handleKeypress,
      handleKeyup: handleKeyup,
      handleIconClick: handleIconClick,
      handleFocus: handleFocus,
      handleBlur: handleBlur,
      handleComposition: handleComposition,
      handleInput: handleInput,
      handleChange: handleChange,
      handleClear: handleClear,
      handleSearch: handleSearch,
      handleTogglePass: handleTogglePass,
      focus: focus,
      blur: blur,
      BForm: BForm,
      BFormItem: BFormItem,
      validateState: validateState,
      validateIcon: validateIcon,
      formEmit: formEmit,
      inputDisabled: inputDisabled,
      inputSize: inputSize,
      wrapClasses: wrapClasses,
      showPrefix: showPrefix,
      showSuffix: showSuffix,
      inputClasses: inputClasses,
      closeClasses: closeClasses,
      inputType: inputType,
      textareaStyle: textareaStyle,
      textareaClasses: textareaClasses,
      wordCount: wordCount
    });
  }
};

var _hoisted_1$_ = {
  key: 0,
  class: "bin-input-group-prepend"
};
var _hoisted_2$E = {
  key: 2,
  class: "bin-input-suffix"
};
var _hoisted_3$s = {
  key: 3,
  class: "bin-input-prefix"
};
var _hoisted_4$k = {
  key: 4,
  class: "bin-input-word-count"
};
var _hoisted_5$h = {
  key: 5,
  class: "bin-input-group-append"
};
var _hoisted_6$a = {
  key: 0,
  class: "bin-input-word-count"
};
function render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.wrapClasses
  }, [$props.type !== 'textarea' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [_ctx.$slots.prepend ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$_, [vue.renderSlot(_ctx.$slots, "prepend")])) : vue.createCommentVNode("v-if", true), vue.createCommentVNode("清空按钮"), $props.clearable && _ctx.currentValue && !$props.disabled ? (vue.openBlock(), vue.createBlock("span", {
    key: 1,
    class: $setup.closeClasses
  }, [vue.createVNode("i", {
    class: "b-iconfont b-icon-close-circle-fill",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClear && $setup.handleClear.apply($setup, arguments);
    })
  })], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), $setup.showSuffix ? (vue.openBlock(), vue.createBlock("span", _hoisted_2$E, [$props.icon ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: ["b-iconfont", ['b-icon-' + $props.icon, 'bin-input-icon', 'bin-input-icon-normal']],
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.handleIconClick && $setup.handleIconClick.apply($setup, arguments);
    })
  }, null, 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), $props.search ? (vue.openBlock(), vue.createBlock("i", {
    key: 1,
    class: ["b-iconfont b-icon-search", ['bin-input-icon', 'bin-input-icon-normal', 'bin-input-search-icon']],
    onClick: _cache[3] || (_cache[3] = vue.withModifiers(function () {
      return $setup.handleSearch && $setup.handleSearch.apply($setup, arguments);
    }, ["stop"]))
  })) : vue.createCommentVNode("v-if", true), $props.type === 'password' ? (vue.openBlock(), vue.createBlock("i", {
    key: 2,
    class: ["b-iconfont bin-input-icon bin-input-icon-normal bin-input-view-icon", $setup.showPassword ? 'b-icon-eye' : 'b-icon-eye-close'],
    onClick: _cache[4] || (_cache[4] = vue.withModifiers(function () {
      return $setup.handleTogglePass && $setup.handleTogglePass.apply($setup, arguments);
    }, ["stop"]))
  }, null, 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "suffix", {}, function () {
    return [$props.suffix ? (vue.openBlock(), vue.createBlock("i", {
      key: 0,
      class: ["b-iconfont", ['b-icon-' + $props.suffix]]
    }, null, 2
    /* CLASS */
    )) : vue.createCommentVNode("v-if", true)];
  }), $setup.validateState ? (vue.openBlock(), vue.createBlock("i", {
    key: 3,
    class: ['b-iconfont', 'bin-input__validateIcon', $setup.validateIcon]
  }, null, 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true)])) : vue.createCommentVNode("v-if", true), vue.createVNode("input", {
    id: $props.elementId,
    autocomplete: $props.type === 'password' ? 'new-password' : $props.autocomplete,
    ref: "inputRef",
    type: $setup.inputType,
    class: $setup.inputClasses,
    placeholder: $props.placeholder,
    disabled: $setup.inputDisabled,
    maxlength: $props.maxlength,
    readonly: $props.readonly,
    name: $props.name,
    value: _ctx.currentValue,
    number: $props.number,
    autofocus: $props.autofocus,
    onKeyup: [_cache[5] || (_cache[5] = vue.withKeys(function () {
      return $setup.handleEnter && $setup.handleEnter.apply($setup, arguments);
    }, ["enter"])), _cache[6] || (_cache[6] = function () {
      return $setup.handleKeyup && $setup.handleKeyup.apply($setup, arguments);
    })],
    onKeypress: _cache[7] || (_cache[7] = function () {
      return $setup.handleKeypress && $setup.handleKeypress.apply($setup, arguments);
    }),
    onKeydown: _cache[8] || (_cache[8] = function () {
      return $setup.handleKeydown && $setup.handleKeydown.apply($setup, arguments);
    }),
    onFocus: _cache[9] || (_cache[9] = function () {
      return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
    }),
    onBlur: _cache[10] || (_cache[10] = function () {
      return $setup.handleBlur && $setup.handleBlur.apply($setup, arguments);
    }),
    onCompositionstart: _cache[11] || (_cache[11] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onCompositionupdate: _cache[12] || (_cache[12] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onCompositionend: _cache[13] || (_cache[13] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onInput: _cache[14] || (_cache[14] = function () {
      return $setup.handleInput && $setup.handleInput.apply($setup, arguments);
    }),
    onChange: _cache[15] || (_cache[15] = function () {
      return $setup.handleChange && $setup.handleChange.apply($setup, arguments);
    })
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , ["id", "autocomplete", "type", "placeholder", "disabled", "maxlength", "readonly", "name", "value", "number", "autofocus"]), $setup.showPrefix ? (vue.openBlock(), vue.createBlock("span", _hoisted_3$s, [vue.renderSlot(_ctx.$slots, "prefix", {}, function () {
    return [$props.prefix ? (vue.openBlock(), vue.createBlock("i", {
      key: 0,
      class: ["b-iconfont", ['b-icon-' + $props.prefix]]
    }, null, 2
    /* CLASS */
    )) : vue.createCommentVNode("v-if", true)];
  })])) : vue.createCommentVNode("v-if", true), $props.showWordCount ? (vue.openBlock(), vue.createBlock("span", _hoisted_4$k, vue.toDisplayString($setup.wordCount), 1
  /* TEXT */
  )) : vue.createCommentVNode("v-if", true), _ctx.$slots.append ? (vue.openBlock(), vue.createBlock("span", _hoisted_5$h, [vue.renderSlot(_ctx.$slots, "append")])) : vue.createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 1
  }, [vue.createVNode("textarea", {
    id: $props.elementId,
    wrap: $props.wrap,
    autocomplete: $props.autocomplete,
    ref: "textareaRef",
    class: $setup.textareaClasses,
    style: $setup.textareaStyle,
    placeholder: $props.placeholder,
    disabled: $setup.inputDisabled,
    rows: $props.rows,
    maxlength: $props.maxlength,
    readonly: $props.readonly,
    name: $props.name,
    value: _ctx.currentValue,
    autofocus: $props.autofocus,
    onKeyup: [_cache[16] || (_cache[16] = vue.withKeys(function () {
      return $setup.handleEnter && $setup.handleEnter.apply($setup, arguments);
    }, ["enter"])), _cache[17] || (_cache[17] = function () {
      return $setup.handleKeyup && $setup.handleKeyup.apply($setup, arguments);
    })],
    onKeypress: _cache[18] || (_cache[18] = function () {
      return $setup.handleKeypress && $setup.handleKeypress.apply($setup, arguments);
    }),
    onKeydown: _cache[19] || (_cache[19] = function () {
      return $setup.handleKeydown && $setup.handleKeydown.apply($setup, arguments);
    }),
    onFocus: _cache[20] || (_cache[20] = function () {
      return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
    }),
    onBlur: _cache[21] || (_cache[21] = function () {
      return $setup.handleBlur && $setup.handleBlur.apply($setup, arguments);
    }),
    onChange: _cache[22] || (_cache[22] = function () {
      return $setup.handleChange && $setup.handleChange.apply($setup, arguments);
    }),
    onCompositionstart: _cache[23] || (_cache[23] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onCompositionupdate: _cache[24] || (_cache[24] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onCompositionend: _cache[25] || (_cache[25] = function () {
      return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
    }),
    onInput: _cache[26] || (_cache[26] = function () {
      return $setup.handleInput && $setup.handleInput.apply($setup, arguments);
    })
  }, null, 46
  /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
  , ["id", "wrap", "autocomplete", "placeholder", "disabled", "rows", "maxlength", "readonly", "name", "value", "autofocus"]), $props.showWordCount ? (vue.openBlock(), vue.createBlock("span", _hoisted_6$a, vue.toDisplayString($setup.wordCount), 1
  /* TEXT */
  )) : vue.createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  ))], 2
  /* CLASS */
  );
}

script$1D.render = render$1z;
script$1D.__file = "src/components/input/input.vue";

var EVENT_CODE = {
  tab: 'Tab',
  enter: 'Enter',
  space: 'Space',
  left: 'ArrowLeft',
  // 37
  up: 'ArrowUp',
  // 38
  right: 'ArrowRight',
  // 39
  down: 'ArrowDown',
  // 40
  esc: 'Escape',
  delete: 'Delete',
  backspace: 'Backspace'
};
/**
 * Trigger an event
 * mouseenter, mouseleave, mouseover, keyup, change, click, etc.
 * @param  {HTMLElement} elm
 * @param  {String} name
 * @param  {*} opts
 */

var triggerEvent = function triggerEvent(elm, name) {
  var eventName;

  if (name.includes('mouse') || name.includes('click')) {
    eventName = 'MouseEvents';
  } else if (name.includes('key')) {
    eventName = 'KeyboardEvent';
  } else {
    eventName = 'HTMLEvents';
  }

  var evt = document.createEvent(eventName);

  for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    opts[_key - 2] = arguments[_key];
  }

  evt.initEvent.apply(evt, [name].concat(opts));
  elm.dispatchEvent(evt);
  return elm;
};

function scrollIntoView(container, selected) {
  if (isServer) return;

  if (!selected) {
    container.scrollTop = 0;
    return;
  }

  var offsetParents = [];
  var pointer = selected.offsetParent;

  while (pointer !== null && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }

  var top = selected.offsetTop + offsetParents.reduce(function (prev, curr) {
    return prev + curr.offsetTop;
  }, 0);
  var bottom = top + selected.offsetHeight;
  var viewRectTop = container.scrollTop;
  var viewRectBottom = viewRectTop + container.clientHeight;

  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}

function isKorean(text) {
  var reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}

/**
 * @description 更新标题
 * @param {String} title 标题
 */
function title(title) {
  if (title) {
    window.document.title = title;
  }
}
/**
 * @description 复制到剪切板
 * @param content
 */

function copy(content) {
  return new Promise(function (resolve) {
    var copyInput = document.createElement('textarea');
    copyInput.value = content;
    copyInput.setAttribute('id', 'b-copy-temp');
    document.body.appendChild(copyInput);
    copyInput.select(); // 选择对象

    var result = document.execCommand('Copy'); // 执行浏览器复制命令

    copyInput.style.display = 'none';
    document.body.removeChild(document.getElementById('b-copy-temp'));
    resolve(result);
  });
}
/**
 * @description 打开新页面
 * @param {String} url 地址
 * @param target
 */

function open(url, target) {
  if (target === void 0) {
    target = false;
  }

  var a = document.createElement('a');
  a.setAttribute('href', url);

  if (target) {
    a.setAttribute('target', '_blank');
  }

  a.setAttribute('id', 'b-link-temp');
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(document.getElementById('b-link-temp'));
}
/**
 * @description 日期格式化
 * @param time
 * @param cFormat
 * @param weekArray
 */

function parseTime(time, cFormat, weekArray) {
  if (cFormat === void 0) {
    cFormat = '{y}-{m}-{d} {h}:{i}:{s}';
  }

  if (arguments.length === 0) {
    return null;
  }

  var type = typeOf(time);
  var date;

  switch (type) {
    case 'date':
      date = time;
      break;

    case 'number':
      date = new Date(time);
      break;

    case 'string':
      if (typeof time === 'string') {
        date = new Date(time.replace(/-/g, '/'));
      }

      break;

    default:
      return null;
  }

  var formatObj = {
    y: date.getFullYear(),
    m: date.getMonth() + 1,
    d: date.getDate(),
    h: date.getHours(),
    i: date.getMinutes(),
    s: date.getSeconds(),
    a: date.getDay()
  };
  return cFormat.replace(/{([ymdhisa])+}/g, function (result, key) {
    var value = formatObj[key];

    if (key === 'a') {
      if (weekArray && weekArray.length === 7) {
        return weekArray[value];
      }

      return ['日', '一', '二', '三', '四', '五', '六'][value];
    }

    if (result.length > 0 && value < 10) {
      // 补0
      value = '0' + value;
    }

    return value || 0;
  });
}
/**
 * 获取区间范围，如近一周，近三个月，后一个月等
 * @param days 为负值时往前，正为之后的日期
 * @param mode
 * @returns {*}
 */

function rangeTime(days, mode) {
  if (mode === void 0) {
    mode = '{y}-{m}-{d}';
  }

  var startDate = new Date();
  var endDate = new Date();

  if (days < 0) {
    startDate.setTime(startDate.getTime() + 3600 * 1000 * 24 * days);
  } else {
    endDate.setTime(endDate.getTime() + 3600 * 1000 * 24 * days);
  }

  var startDateStr = parseTime(startDate, mode);
  var endDateStr = parseTime(endDate, mode);
  return {
    startDate: startDate,
    endDate: endDate,
    startDateStr: startDateStr,
    endDateStr: endDateStr
  };
}
/**
 * @description 精准判断对象类型
 * @param obj
 */

function typeOf(obj) {
  var toString = Object.prototype.toString;
  var map = {
    '[object Boolean]': 'boolean',
    '[object Number]': 'number',
    '[object String]': 'string',
    '[object Function]': 'function',
    '[object Array]': 'array',
    '[object Date]': 'date',
    '[object RegExp]': 'regExp',
    '[object Undefined]': 'undefined',
    '[object Null]': 'null',
    '[object Object]': 'object'
  };
  return map[toString.call(obj)];
}
/**
 * @description 深拷贝
 * @param data
 */

function deepCopy(data) {
  var t = typeOf(data);
  var o;

  if (t === 'array') {
    o = [];
  } else if (t === 'object') {
    o = {};
  } else {
    return data;
  }

  if (t === 'array') {
    for (var i = 0; i < data.length; i++) {
      o.push(deepCopy(data[i]));
    }
  } else if (t === 'object') {
    for (var _i in data) {
      o[_i] = deepCopy(data[_i]);
    }
  }

  return o;
}
/**
 * 在某个区间随机一个整数
 * @param min 最小值
 * @param max 最大值
 * @return {number}
 */

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * 打乱某个数组
 * @return {number}
 */

function shuffle(arr) {
  var newArr = arr.slice(); // 复制一个新数组

  for (var i = 0; i < newArr.length; i++) {
    var j = getRandomInt(0, i); // 在0-当前循环的位置随机一个位置做交换

    swap(arr, i, j);
  }

  return newArr;
} // 交换两个数组内容

function swap(arr, i, j) {
  var t = arr[i];
  arr[i] = arr[j];
  arr[j] = t;
}
/**
 * 节流函数，(限制函数的执行频率)返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param immediate 是否立即执行 true 则先调用，false不先调用
 * @return {function}             返回客户调用函数
 */

function throttle$2(func, wait, immediate) {
  var timeoutID;
  var lastExec = 0;

  function wrapper() {
    var self = this;
    var elapsed = Number(new Date()) - lastExec;
    var args = arguments;

    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }

    function clear() {
      timeoutID = undefined;
    }

    function exec() {
      lastExec = Number(new Date());
      func.apply(self, args);
    }

    if (immediate && !timeoutID) {
      exec();
    }

    clearExistingTimeout();

    if (immediate === undefined && elapsed > wait) {
      exec();
    } else {
      timeoutID = setTimeout(immediate ? clear : exec, immediate === undefined ? wait - elapsed : wait);
    }
  }

  return wrapper;
}
/**
 * 防抖函数，(限制函数的执行频率) 保证再一系列调用时间内，只调用一次
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @return {function}             返回客户调用函数
 */

function debounce(func, wait) {
  return throttle$2(func, wait, false);
} // 判断是否是对象或数组

function isObject$1(obj) {
  return typeof obj === 'object' && obj !== null;
} // 判定对象数组相等

function isEqual$1(obj1, obj2) {
  // 两个数据有任何一个不是对象或数组
  if (!isObject$1(obj1) || !isObject$1(obj2)) {
    // 值类型(注意：参与equal的一般不会是函数)
    return obj1 === obj2;
  } // 如果传的两个参数都是同一个对象或数组


  if (obj1 === obj2) {
    return true;
  } // 两个都是对象或数组，而且不相等
  // 1.先比较obj1和obj2的key的个数，是否一样


  var obj1Keys = Object.keys(obj1);
  var obj2Keys = Object.keys(obj2);

  if (obj1Keys.length !== obj2Keys.length) {
    return false;
  } // 如果key的个数相等,就是第二步
  // 2.以obj1为基准，和obj2依次递归比较


  for (var key in obj1) {
    // 比较当前key的value  --- 递归
    var res = isEqual$1(obj1[key], obj2[key]);

    if (!res) {
      return false;
    }
  } // 3.全相等


  return true;
}

var util = /*#__PURE__*/Object.freeze({
  __proto__: null,
  title: title,
  copy: copy,
  open: open,
  parseTime: parseTime,
  rangeTime: rangeTime,
  typeOf: typeOf,
  deepCopy: deepCopy,
  getRandomInt: getRandomInt,
  shuffle: shuffle,
  swap: swap,
  throttle: throttle$2,
  debounce: debounce,
  isObject: isObject$1,
  isEqual: isEqual$1
});

function useSelectStates(props) {
  var selectEmitter = mitt();
  return vue.reactive({
    options: new Map(),
    cachedOptions: new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: '',
    hoverIndex: -1,
    query: '',
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: '',
    currentPlaceholder: '请选择',
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    selectEmitter: selectEmitter,
    prefixWidth: null,
    tagInMultiLine: false
  });
}
var useSelect = function useSelect(props, states, ctx) {
  // template refs
  var reference = vue.ref(null);
  var input = vue.ref(null);
  var popper = vue.ref(null);
  var tags = vue.ref(null);
  var selectWrapper = vue.ref(null);
  var scrollbar = vue.ref(null);
  var hoverOption = vue.ref(-1);

  var _useForm = useForm(),
      BForm = _useForm.BForm,
      BFormItem = _useForm.BFormItem,
      formEmit = _useForm.formEmit;

  var readonly = vue.computed(function () {
    return !props.filterable || props.multiple || !isIE() && !isEdge() && !states.visible;
  });
  var selectDisabled = vue.computed(function () {
    return props.disabled || BForm.disabled;
  });
  var showClose = vue.computed(function () {
    var hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== undefined && props.modelValue !== null && props.modelValue !== '';
    return props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
  });
  var iconClass = vue.computed(function () {
    return props.remote && props.filterable ? '' : states.visible ? 'down is-reverse' : 'down';
  });
  var debounceTime = vue.computed(function () {
    return props.remote ? 300 : 0;
  });
  var emptyText = vue.computed(function () {
    if (props.loading) {
      return props.loadingText || '正在加载';
    } else {
      if (props.remote && states.query === '' && states.options.size === 0) return false;

      if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props.noMatchText || '没有匹配数据';
      }

      if (states.options.size === 0) {
        return props.noDataText || '暂无数据';
      }
    }

    return null;
  });
  var optionsArray = vue.computed(function () {
    return Array.from(states.options.values());
  });
  var cachedOptionsArray = vue.computed(function () {
    return Array.from(states.cachedOptions.values());
  });
  var showNewOption = vue.computed(function () {
    var hasExistingOption = optionsArray.value.filter(function (option) {
      return !option.created;
    }).some(function (option) {
      return option.currentLabel === states.query;
    });
    return props.filterable && props.allowCreate && states.query !== '' && !hasExistingOption;
  });
  var selectSize = vue.computed(function () {
    return props.size || BFormItem.size;
  });
  var collapseTagSize = vue.computed(function () {
    return ['small', 'mini'].indexOf(selectSize.value) > -1 ? 'mini' : 'small';
  });
  var dropMenuVisible = vue.computed(function () {
    return states.visible && emptyText.value !== false;
  }); // watch

  vue.watch(function () {
    return selectDisabled.value;
  }, function () {
    vue.nextTick(function () {
      resetInputHeight();
    });
  });
  vue.watch(function () {
    return props.placeholder;
  }, function (val) {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  vue.watch(function () {
    return props.modelValue;
  }, function (val, oldVal) {
    if (props.multiple) {
      resetInputHeight();

      if (val && val.length > 0 || input.value && states.query !== '') {
        states.currentPlaceholder = '';
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }

      if (props.filterable && !props.reserveKeyword) {
        states.query = '';
        handleQueryChange(states.query);
      }
    }

    setSelected();

    if (props.filterable && !props.multiple) {
      states.inputLength = 20;
    }

    if (!isEqual$1(val, oldVal)) {
      formEmit('change', val);
    }
  }, {
    flush: 'post',
    deep: true
  });
  vue.watch(function () {
    return states.visible;
  }, function (val) {
    if (!val) {
      input.value && input.value.blur();
      states.query = '';
      states.previousQuery = null;
      states.selectedLabel = '';
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      vue.nextTick(function () {
        if (input.value && input.value.value === '' && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });

      if (!props.multiple) {
        if (states.selected) {
          if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }

          if (props.filterable) states.query = states.selectedLabel;
        }

        if (props.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      var _popper$value;

      (_popper$value = popper.value) == null ? void 0 : _popper$value.update == null ? void 0 : _popper$value.update();

      if (props.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props.remote ? '' : states.selectedLabel;

        if (props.multiple) {
          input.value.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = states.selectedLabel;
            states.selectedLabel = '';
          }
        }

        handleQueryChange(states.query);

        if (!props.multiple && !props.remote) {
          states.selectEmitter.emit('OptionQueryChange', '');
          states.selectEmitter.emit('OptionGroupQueryChange');
        }
      }
    }

    ctx.emit('visible-change', val);
  });
  vue.watch( // fix `Array.prototype.push/splice/..` cannot trigger non-deep watcher
  // https://github.com/vuejs/vue-next/issues/2116
  function () {
    return states.options.entries();
  }, function () {
    var _popper$value2, _selectWrapper$value;

    if (isServer) return;
    (_popper$value2 = popper.value) == null ? void 0 : _popper$value2.update == null ? void 0 : _popper$value2.update();

    if (props.multiple) {
      resetInputHeight();
    }

    var inputs = ((_selectWrapper$value = selectWrapper.value) == null ? void 0 : _selectWrapper$value.querySelectorAll('input')) || [];

    if ([].indexOf.call(inputs, document.activeElement) === -1) {
      setSelected();
    }

    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: 'post'
  });
  vue.watch(function () {
    return states.hoverIndex;
  }, function (val) {
    if (typeof val === 'number' && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }

    optionsArray.value.forEach(function (option) {
      option.hover = hoverOption.value === option;
    });
  }); // methods

  var resetInputHeight = function resetInputHeight() {
    if (props.collapseTags && !props.filterable) return;
    vue.nextTick(function () {
      if (!reference.value) return;
      var inputChildNodes = reference.value.$el.childNodes;
      var input = [].filter.call(inputChildNodes, function (item) {
        return item.tagName === 'INPUT';
      })[0];
      var _tags = tags.value;
      var sizeInMap = states.initialInputHeight || 40;
      input.style.height = states.selected.length === 0 ? sizeInMap + 'px' : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap) + 'px';
      states.tagInMultiLine = parseFloat(input.style.height) > sizeInMap;

      if (states.visible && emptyText.value !== false) {
        var _popper$value3;

        (_popper$value3 = popper.value) == null ? void 0 : _popper$value3.update == null ? void 0 : _popper$value3.update();
      }
    });
  };

  var handleQueryChange = function handleQueryChange(val) {
    if (states.previousQuery === val || states.isOnComposition) return;

    if (states.previousQuery === null && (typeof props.filterMethod === 'function' || typeof props.remoteMethod === 'function')) {
      states.previousQuery = val;
      return;
    }

    states.previousQuery = val;
    vue.nextTick(function () {
      var _popper$value4;

      if (states.visible) (_popper$value4 = popper.value) == null ? void 0 : _popper$value4.update == null ? void 0 : _popper$value4.update();
    });
    states.hoverIndex = -1;

    if (props.multiple && props.filterable) {
      vue.nextTick(function () {
        var length = input.value.length * 15 + 20;
        states.inputLength = props.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }

    if (props.remote && typeof props.remoteMethod === 'function') {
      states.hoverIndex = -1;
      props.remoteMethod(val);
    } else if (typeof props.filterMethod === 'function') {
      props.filterMethod(val);
      states.selectEmitter.emit('OptionGroupQueryChange');
    } else {
      states.filteredOptionsCount = states.optionsCount;
      states.selectEmitter.emit('OptionQueryChange', val);
      states.selectEmitter.emit('OptionGroupQueryChange');
    }

    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };

  var managePlaceholder = function managePlaceholder() {
    if (states.currentPlaceholder !== '') {
      states.currentPlaceholder = input.value.value ? '' : states.cachedPlaceHolder;
    }
  };

  var checkDefaultFirstOption = function checkDefaultFirstOption() {
    states.hoverIndex = -1; // highlight the created option

    var hasCreated = false;

    for (var i = states.options.size - 1; i >= 0; i--) {
      if (optionsArray.value[i].created) {
        hasCreated = true;
        states.hoverIndex = i;
        break;
      }
    }

    if (hasCreated) return;

    for (var _i = 0; _i !== states.options.size; ++_i) {
      var option = optionsArray.value[_i];

      if (states.query) {
        // highlight first options that passes the filter
        if (!option.disabled && !option.groupDisabled && option.visible) {
          states.hoverIndex = _i;
          break;
        }
      } else {
        // highlight currently selected option
        if (option.itemSelected) {
          states.hoverIndex = _i;
          break;
        }
      }
    }
  };

  var setSelected = function setSelected() {
    if (!props.multiple) {
      var _option$props;

      var option = getOption(props.modelValue);

      if ((_option$props = option.props) != null && _option$props.created) {
        states.createdLabel = option.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }

      states.selectedLabel = option.currentLabel || '';
      states.selected = option;
      if (props.filterable) states.query = states.selectedLabel;
      return;
    }

    var result = [];

    if (Array.isArray(props.modelValue)) {
      props.modelValue.forEach(function (value) {
        result.push(getOption(value));
      });
    }

    states.selected = result;
    vue.nextTick(function () {
      resetInputHeight();
    });
  };

  var getOption = function getOption(value) {
    var option;
    var isObjectValue = toRawType(value).toLowerCase() === 'object';
    var isNull = toRawType(value).toLowerCase() === 'null';
    var isUndefined = toRawType(value).toLowerCase() === 'undefined';

    for (var i = states.cachedOptions.size - 1; i >= 0; i--) {
      var cachedOption = cachedOptionsArray.value[i];
      var isEqualValue = isObjectValue ? getValueByPath(cachedOption.value, props.valueKey) === getValueByPath(value, props.valueKey) : cachedOption.value === value;

      if (isEqualValue) {
        option = {
          value: value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }

    if (option) return option;
    var label = !isObjectValue && !isNull && !isUndefined ? value : '';
    var newOption = {
      value: value,
      currentLabel: label
    };

    if (props.multiple) {
      newOption.hitState = false;
    }

    return newOption;
  };

  var resetHoverIndex = function resetHoverIndex() {
    setTimeout(function () {
      if (!props.multiple) {
        states.hoverIndex = optionsArray.value.indexOf(states.selected);
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map(function (item) {
            return optionsArray.value.indexOf(item);
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };

  var handleResize = function handleResize() {
    var _popper$value5;

    resetInputWidth();
    (_popper$value5 = popper.value) == null ? void 0 : _popper$value5.update == null ? void 0 : _popper$value5.update();
    if (props.multiple) resetInputHeight();
  };

  var resetInputWidth = function resetInputWidth() {
    var _reference$value;

    states.inputWidth = (_reference$value = reference.value) == null ? void 0 : _reference$value.$el.getBoundingClientRect().width;
  };

  var onInputChange = function onInputChange() {
    if (props.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };

  var debouncedOnInputChange = debounce(onInputChange, debounceTime.value);
  var debouncedQueryChange = debounce(function (e) {
    handleQueryChange(e.target.value);
  }, debounceTime.value);

  var emitChange = function emitChange(val) {
    if (!isEqual$1(props.modelValue, val)) {
      ctx.emit(CHANGE_EVENT, val);
    }
  };

  var deletePrevTag = function deletePrevTag(e) {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      var value = props.modelValue.slice();
      value.pop();
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }

    if (e.target.value.length === 1 && props.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };

  var deleteTag = function deleteTag(event, tag) {
    var index = states.selected.indexOf(tag);

    if (index > -1 && !selectDisabled.value) {
      var value = props.modelValue.slice();
      value.splice(index, 1);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit('remove-tag', tag.value);
    }

    event.stopPropagation();
  };

  var deleteSelected = function deleteSelected(event) {
    event.stopPropagation();
    var value = props.multiple ? [] : '';

    if (typeof value !== 'string') {
      for (var _iterator = _createForOfIteratorHelperLoose(states.selected), _step; !(_step = _iterator()).done;) {
        var item = _step.value;
        if (item.isDisabled) value.push(item.value);
      }
    }

    ctx.emit(UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.visible = false;
    ctx.emit('clear');
  };

  var handleOptionSelect = function handleOptionSelect(option, byClick) {
    if (props.multiple) {
      var value = (props.modelValue || []).slice();
      var optionIndex = getValueIndex(value, option.value);

      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
        value.push(option.value);
      }

      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);

      if (option.created) {
        states.query = '';
        handleQueryChange('');
        states.inputLength = 20;
      }

      if (props.filterable) input.value.focus();
    } else {
      ctx.emit(UPDATE_MODEL_EVENT, option.value);
      emitChange(option.value);
      states.visible = false;
    }

    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible) return;
    vue.nextTick(function () {
      scrollToOption(option);
    });
  };

  var getValueIndex = function getValueIndex(arr, value) {
    if (arr === void 0) {
      arr = [];
    }

    if (!isObject$2(value)) return arr.indexOf(value);
    var valueKey = props.valueKey;
    var index = -1;
    arr.some(function (item, i) {
      if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {
        index = i;
        return true;
      }

      return false;
    });
    return index;
  };

  var setSoftFocus = function setSoftFocus() {
    states.softFocus = true;

    var _input = input.value || reference.value;

    if (_input) {
      _input.focus();
    }
  };

  var scrollToOption = function scrollToOption(option) {
    var _scrollbar$value;

    var targetOption = Array.isArray(option) ? option[0] : option;
    var target = null;

    if (targetOption != null && targetOption.value) {
      var options = optionsArray.value.filter(function (item) {
        return item.value === targetOption.value;
      });

      if (options.length > 0) {
        target = options[0].$el;
      }
    }

    if (popper.value && target) {
      var _popper$value6, _popper$value6$popper;

      var menu = (_popper$value6 = popper.value) == null ? void 0 : (_popper$value6$popper = _popper$value6.popperRef) == null ? void 0 : _popper$value6$popper.querySelector == null ? void 0 : _popper$value6$popper.querySelector('.bin-select-dropdown__wrap');

      if (menu) {
        scrollIntoView(menu, target);
      }
    }

    (_scrollbar$value = scrollbar.value) == null ? void 0 : _scrollbar$value.handleScroll();
  };

  var onOptionCreate = function onOptionCreate(vm) {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };

  var onOptionDestroy = function onOptionDestroy(key) {
    states.optionsCount--;
    states.filteredOptionsCount--;
    states.options.delete(key);
  };

  var resetInputState = function resetInputState(e) {
    if (e.code !== EVENT_CODE.backspace) toggleLastOptionHitState(false);
    states.inputLength = input.value.length * 15 + 20;
    resetInputHeight();
  };

  var toggleLastOptionHitState = function toggleLastOptionHitState(hit) {
    if (!Array.isArray(states.selected)) return;
    var option = states.selected[states.selected.length - 1];
    if (!option) return;

    if (hit === true || hit === false) {
      option.hitState = hit;
      return hit;
    }

    option.hitState = !option.hitState;
    return option.hitState;
  };

  var handleComposition = function handleComposition(event) {
    var text = event.target.value;

    if (event.type === 'compositionend') {
      states.isOnComposition = false;
      vue.nextTick(function () {
        return handleQueryChange(text);
      });
    } else {
      var lastCharacter = text[text.length - 1] || '';
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };

  var handleMenuEnter = function handleMenuEnter() {
    vue.nextTick(function () {
      return scrollToOption(states.selected);
    });
  };

  var handleFocus = function handleFocus(event) {
    if (!states.softFocus) {
      if (props.automaticDropdown || props.filterable) {
        states.visible = true;

        if (props.filterable) {
          states.menuVisibleOnFocus = true;
        }
      }

      ctx.emit('focus', event);
    } else {
      states.softFocus = false;
    }
  };

  var blur = function blur() {
    states.visible = false;
    reference.value.blur();
  };

  var handleBlur = function handleBlur(event) {
    // https://github.com/ElemeFE/element/pull/10822
    vue.nextTick(function () {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit('blur', event);
      }
    });
    states.softFocus = false;
  };

  var handleClearClick = function handleClearClick(event) {
    deleteSelected(event);
  };

  var handleClose = function handleClose() {
    states.visible = false;
  };

  var toggleMenu = function toggleMenu() {
    if (props.automaticDropdown) return;

    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }

      if (states.visible) {
        (input.value || reference.value).focus();
      }
    }
  };

  var selectOption = function selectOption() {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], undefined);
      }
    }
  };

  var getValueKey = function getValueKey(item) {
    return isObject$2(item.value) ? getValueByPath(item.value, props.valueKey) : item.value;
  };

  var optionsAllDisabled = vue.computed(function () {
    return optionsArray.value.filter(function (option) {
      return option.visible;
    }).every(function (option) {
      return option.disabled;
    });
  });

  var navigateOptions = function navigateOptions(direction) {
    if (!states.visible) {
      states.visible = true;
      return;
    }

    if (states.options.size === 0 || states.filteredOptionsCount === 0) return;

    if (!optionsAllDisabled.value) {
      if (direction === 'next') {
        states.hoverIndex++;

        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction === 'prev') {
        states.hoverIndex--;

        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }

      var option = optionsArray.value[states.hoverIndex];

      if (option.disabled === true || option.groupDisabled === true || !option.visible) {
        navigateOptions(direction);
      }

      vue.nextTick(function () {
        return scrollToOption(hoverOption.value);
      });
    }
  };

  return {
    optionsArray: optionsArray,
    selectSize: selectSize,
    handleResize: handleResize,
    debouncedOnInputChange: debouncedOnInputChange,
    debouncedQueryChange: debouncedQueryChange,
    deletePrevTag: deletePrevTag,
    deleteTag: deleteTag,
    deleteSelected: deleteSelected,
    handleOptionSelect: handleOptionSelect,
    scrollToOption: scrollToOption,
    readonly: readonly,
    resetInputHeight: resetInputHeight,
    showClose: showClose,
    iconClass: iconClass,
    showNewOption: showNewOption,
    collapseTagSize: collapseTagSize,
    setSelected: setSelected,
    managePlaceholder: managePlaceholder,
    selectDisabled: selectDisabled,
    emptyText: emptyText,
    toggleLastOptionHitState: toggleLastOptionHitState,
    resetInputState: resetInputState,
    handleComposition: handleComposition,
    onOptionCreate: onOptionCreate,
    onOptionDestroy: onOptionDestroy,
    handleMenuEnter: handleMenuEnter,
    handleFocus: handleFocus,
    blur: blur,
    handleBlur: handleBlur,
    handleClearClick: handleClearClick,
    handleClose: handleClose,
    toggleMenu: toggleMenu,
    selectOption: selectOption,
    getValueKey: getValueKey,
    navigateOptions: navigateOptions,
    dropMenuVisible: dropMenuVisible,
    // DOM ref
    reference: reference,
    input: input,
    popper: popper,
    tags: tags,
    selectWrapper: selectWrapper,
    scrollbar: scrollbar
  };
};

/**
 * Hook that monitoring the ref value to lock or unlock the screen.
 * When the trigger became true, it assumes modal is now opened and vice versa.
 * @param trigger {boolean}
 */

var useLockScreen = (function (trigger) {
  if (!vue.isRef(trigger)) {
    throwError('useLockScreen', 'You need to pass a ref param to this function');
  }

  var scrollBarWidth = 0;
  var withoutHiddenClass = false;
  var bodyPaddingRight = '0';
  var computedBodyPaddingRight = 0;
  var timer = null;
  vue.watch(trigger, function (val) {
    if (val) {
      if (timer) clearTimeout(timer);
      withoutHiddenClass = !hasClass(document.body, 'bin-popup-parent--hidden');

      if (withoutHiddenClass) {
        bodyPaddingRight = document.body.style.paddingRight;
        computedBodyPaddingRight = parseInt(getStyle(document.body, 'paddingRight'), 10);
      }

      scrollBarWidth = getScrollBarWidth();
      var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
      var bodyOverflowY = getStyle(document.body, 'overflowY');

      if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && withoutHiddenClass) {
        document.body.style.paddingRight = computedBodyPaddingRight + scrollBarWidth + 'px';
      }

      addClass(document.body, 'bin-popup-parent--hidden');
    } else {
      timer = setTimeout(function () {
        if (withoutHiddenClass) {
          document.body.style.paddingRight = bodyPaddingRight;
          removeClass(document.body, 'bin-popup-parent--hidden');
        }

        withoutHiddenClass = true;
      }, 300);
    }
  });
});

/**
 * This method provides dialogable components the ability to restore previously activated element before
 * the dialog gets opened
 */

var useRestoreActive = (function (toggle, initialFocus) {
  var previousActive;
  vue.watch(function () {
    return toggle.value;
  }, function (val) {
    if (val) {
      previousActive = document.activeElement;

      if (vue.isRef(initialFocus)) {
        initialFocus.value.focus == null ? void 0 : initialFocus.value.focus();
      }
    } else {
      if (process.env.NODE_ENV === 'testing') {
        previousActive.focus.call(previousActive);
      } else {
        previousActive.focus();
      }
    }
  });
});

var modalStack = [];

var closeModal = function closeModal(e) {
  if (modalStack.length === 0) return;

  if (e.code === EVENT_CODE.esc) {
    e.stopPropagation();
    var topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};

var useModal = (function (instance, visibleRef) {
  vue.watch(function () {
    return visibleRef.value;
  }, function (val) {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.findIndex(function (modal) {
        return modal === instance;
      }), 1);
    }
  });
});

if (!isServer) {
  on$1(document, 'keydown', closeModal);
}

function tryOnUnmounted(fn) {
  vue.getCurrentInstance() && vue.onUnmounted(fn);
}

function isFunction$1(val) {
  return typeof val === 'function';
}

function useTimeoutFn(handle, wait, native) {
  if (native === void 0) {
    native = false;
  }

  if (!isFunction$1(handle)) {
    throw new Error('handle is not Function!');
  }

  var _useTimeoutRef = useTimeoutRef(wait),
      readyRef = _useTimeoutRef.readyRef,
      stop = _useTimeoutRef.stop,
      start = _useTimeoutRef.start;

  if (native) {
    handle();
  } else {
    vue.watch(readyRef, function (maturity) {
      maturity && handle();
    }, {
      immediate: false
    });
  }

  return {
    readyRef: readyRef,
    stop: stop,
    start: start
  };
}
function useTimeoutRef(wait) {
  var readyRef = vue.ref(false);
  var timer = null;

  function stop() {
    readyRef.value = false;
    timer && window.clearTimeout(timer);
  }

  function start() {
    stop();
    timer = setTimeout(function () {
      readyRef.value = true;
    }, wait);
  }

  start();
  tryOnUnmounted(stop);
  return {
    readyRef: readyRef,
    stop: stop,
    start: start
  };
}

function useModalDrag (context) {
  var getStyle = function getStyle(dom, attr) {
    return getComputedStyle(dom)[attr];
  };

  var drag = function drag(wrap) {
    if (!wrap) return;
    wrap.setAttribute('data-drag', vue.unref(context.draggable));
    var dialogHeaderEl = wrap.querySelector('.bin-modal-header');
    var dragDom = wrap;
    if (!dialogHeaderEl || !dragDom || !vue.unref(context.draggable)) return;
    dialogHeaderEl.style.cursor = 'move';

    dialogHeaderEl.onmousedown = function (e) {
      if (!e) return; // 鼠标按下，计算当前元素距离可视区的距离

      var disX = e.clientX;
      var disY = e.clientY;
      var screenWidth = document.body.clientWidth; // body当前宽度

      var screenHeight = document.documentElement.clientHeight; // 可见区域高度(应为body高度，可某些环境下无法获取)

      var dragDomWidth = dragDom.offsetWidth; // 对话框宽度

      var dragDomHeight = dragDom.offsetHeight; // 对话框高度

      var minDragDomLeft = dragDom.offsetLeft;
      var maxDragDomLeft = screenWidth - dragDom.offsetLeft - dragDomWidth;
      var minDragDomTop = dragDom.offsetTop;
      var maxDragDomTop = screenHeight - dragDom.offsetTop - dragDomHeight; // 获取到的值带px 正则匹配替换

      var domLeft = getStyle(dragDom, 'left');
      var domTop = getStyle(dragDom, 'top');
      var styL = +domLeft;
      var styT = +domTop; // 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px

      if (domLeft.includes('%')) {
        styL = +document.body.clientWidth * (+domLeft.replace(/%/g, '') / 100);
        styT = +document.body.clientHeight * (+domTop.replace(/%/g, '') / 100);
      } else {
        styL = +domLeft.replace(/px/g, '');
        styT = +domTop.replace(/px/g, '');
      }

      document.onmousemove = function (e) {
        // 通过事件委托，计算移动的距离
        var left = e.clientX - disX;
        var top = e.clientY - disY; // 边界处理

        if (-left > minDragDomLeft) {
          left = -minDragDomLeft;
        } else if (left > maxDragDomLeft) {
          left = maxDragDomLeft;
        }

        if (-top > minDragDomTop) {
          top = -minDragDomTop;
        } else if (top > maxDragDomTop) {
          top = maxDragDomTop;
        } // 移动当前元素


        dragDom.style.cssText += ";left:" + (left + styL) + "px;top:" + (top + styT) + "px;";
      };

      document.onmouseup = function () {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
  };

  var handleDrag = function handleDrag() {
    var dragWraps = document.querySelectorAll('.bin-modal-wrap');

    for (var _i = 0, _Array$from = Array.from(dragWraps); _i < _Array$from.length; _i++) {
      var wrap = _Array$from[_i];
      if (!wrap) continue;
      var display = getStyle(wrap.parentElement, 'display');
      var draggable = wrap.getAttribute('data-drag');

      if (display !== 'none') {
        // 拖拽位置
        if (draggable === null || vue.unref(context.destroyOnClose)) {
          drag(wrap);
        }
      }
    }
  };

  vue.watchEffect(function () {
    if (!vue.unref(context.visible) || !vue.unref(context.draggable)) {
      return;
    }

    useTimeoutFn(function () {
      handleDrag();
    }, 30);
  });
}

var useFocus = (function (el) {
  return {
    focus: function focus() {
      var _el$value;

      (_el$value = el.value) == null ? void 0 : _el$value.focus == null ? void 0 : _el$value.focus();
    }
  };
});

// For individual build sharing injection key, we had to make `Symbol` to string
var selectGroupKey = 'SelectGroup';
var selectKey = 'Select';
var selectEvents = {
  queryChange: 'OptionQueryChange',
  groupQueryChange: 'OptionGroupQueryChange'
};

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle$1 (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index$2 = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* istanbul ignore next */

var resizeHandler = function resizeHandler(entries) {
  for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
    var entry = _step.value;
    var listeners = entry.target.__resizeListeners__ || [];

    if (listeners.length) {
      listeners.forEach(function (fn) {
        fn();
      });
    }
  }
};
/* istanbul ignore next */


var addResizeListener = function addResizeListener(element, fn) {
  if (isServer || !element) return;

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new index$2(resizeHandler);

    element.__ro__.observe(element);
  }

  element.__resizeListeners__.push(fn);
};
/* istanbul ignore next */

var removeResizeListener = function removeResizeListener(element, fn) {
  if (!element || !element.__resizeListeners__) return;

  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

  if (!element.__resizeListeners__.length) {
    element.__ro__.disconnect();
  }
};

var id = "2344785";
var name$1 = "bin-ui-next";
var font_family = "b-iconfont";
var css_prefix_text = "b-icon-";
var description = "";
var glyphs = [
	{
		icon_id: "4765741",
		name: "time-circle",
		font_class: "time-circle",
		unicode: "e7a4",
		unicode_decimal: 59300
	},
	{
		icon_id: "4765742",
		name: "time out",
		font_class: "timeout",
		unicode: "e7a5",
		unicode_decimal: 59301
	},
	{
		icon_id: "4765886",
		name: "issues close",
		font_class: "issuesclose",
		unicode: "e7a6",
		unicode_decimal: 59302
	},
	{
		icon_id: "4765964",
		name: "close-square",
		font_class: "close-square",
		unicode: "e7aa",
		unicode_decimal: 59306
	},
	{
		icon_id: "4765970",
		name: "code library",
		font_class: "codelibrary",
		unicode: "e7ac",
		unicode_decimal: 59308
	},
	{
		icon_id: "4766857",
		name: "calendar-check",
		font_class: "calendar-check",
		unicode: "e834",
		unicode_decimal: 59444
	},
	{
		icon_id: "4766881",
		name: "laptop",
		font_class: "laptop",
		unicode: "e836",
		unicode_decimal: 59446
	},
	{
		icon_id: "4766884",
		name: "cluster",
		font_class: "cluster",
		unicode: "e837",
		unicode_decimal: 59447
	},
	{
		icon_id: "4766973",
		name: "wrench",
		font_class: "wrench",
		unicode: "e838",
		unicode_decimal: 59448
	},
	{
		icon_id: "4936512",
		name: "time-circle-fill",
		font_class: "time-circle-fill",
		unicode: "e89f",
		unicode_decimal: 59551
	},
	{
		icon_id: "4936693",
		name: "shop-fill",
		font_class: "shop-fill",
		unicode: "e8a0",
		unicode_decimal: 59552
	},
	{
		icon_id: "4936696",
		name: "golden-fill",
		font_class: "golden-fill",
		unicode: "e8a1",
		unicode_decimal: 59553
	},
	{
		icon_id: "4936697",
		name: "build-fill",
		font_class: "build-fill",
		unicode: "e8a2",
		unicode_decimal: 59554
	},
	{
		icon_id: "4936969",
		name: "sketch",
		font_class: "sketch",
		unicode: "e8a3",
		unicode_decimal: 59555
	},
	{
		icon_id: "4936970",
		name: "Gitlab",
		font_class: "Gitlab",
		unicode: "e8a4",
		unicode_decimal: 59556
	},
	{
		icon_id: "4936977",
		name: "Gitlab-fill",
		font_class: "Gitlab-fill",
		unicode: "e8a5",
		unicode_decimal: 59557
	},
	{
		icon_id: "4936978",
		name: "dropbox",
		font_class: "dropbox",
		unicode: "e8a6",
		unicode_decimal: 59558
	},
	{
		icon_id: "4936979",
		name: "dingtalk",
		font_class: "dingtalk",
		unicode: "e8a7",
		unicode_decimal: 59559
	},
	{
		icon_id: "5756280",
		name: "apartment",
		font_class: "apartment",
		unicode: "e8a8",
		unicode_decimal: 59560
	},
	{
		icon_id: "5756283",
		name: "robot",
		font_class: "robot",
		unicode: "e8a9",
		unicode_decimal: 59561
	},
	{
		icon_id: "8094809",
		name: "merge-cells",
		font_class: "merge-cells",
		unicode: "e901",
		unicode_decimal: 59649
	},
	{
		icon_id: "8094816",
		name: "solit-cells",
		font_class: "solit-cells",
		unicode: "e902",
		unicode_decimal: 59650
	},
	{
		icon_id: "8094817",
		name: "format painter",
		font_class: "formatpainter",
		unicode: "e903",
		unicode_decimal: 59651
	},
	{
		icon_id: "8094818",
		name: "insert row right",
		font_class: "insertrowright",
		unicode: "e904",
		unicode_decimal: 59652
	},
	{
		icon_id: "8094819",
		name: "format painter-fill",
		font_class: "formatpainter-fill",
		unicode: "e905",
		unicode_decimal: 59653
	},
	{
		icon_id: "8094820",
		name: "insert row left",
		font_class: "insertrowleft",
		unicode: "e906",
		unicode_decimal: 59654
	},
	{
		icon_id: "8094821",
		name: "translate",
		font_class: "translate",
		unicode: "e907",
		unicode_decimal: 59655
	},
	{
		icon_id: "9229178",
		name: "Field-time",
		font_class: "Field-time",
		unicode: "e90e",
		unicode_decimal: 59662
	},
	{
		icon_id: "9229180",
		name: "Partition",
		font_class: "Partition",
		unicode: "e90f",
		unicode_decimal: 59663
	},
	{
		icon_id: "9230695",
		name: "group",
		font_class: "group",
		unicode: "e917",
		unicode_decimal: 59671
	},
	{
		icon_id: "29934",
		name: "loading",
		font_class: "loading1",
		unicode: "e64f",
		unicode_decimal: 58959
	},
	{
		icon_id: "4325757",
		name: "icon_loading",
		font_class: "loading2",
		unicode: "eb80",
		unicode_decimal: 60288
	},
	{
		icon_id: "7239803",
		name: "loading",
		font_class: "loading",
		unicode: "e73c",
		unicode_decimal: 59196
	},
	{
		icon_id: "4936624",
		name: "folder-open-fill",
		font_class: "folder-open-fill",
		unicode: "e873",
		unicode_decimal: 59507
	},
	{
		icon_id: "4936626",
		name: "database-fill",
		font_class: "database-fill",
		unicode: "e874",
		unicode_decimal: 59508
	},
	{
		icon_id: "4936627",
		name: "container-fill",
		font_class: "container-fill",
		unicode: "e875",
		unicode_decimal: 59509
	},
	{
		icon_id: "4936628",
		name: "sever-fill",
		font_class: "sever-fill",
		unicode: "e876",
		unicode_decimal: 59510
	},
	{
		icon_id: "4936630",
		name: "image-fill",
		font_class: "image-fill",
		unicode: "e877",
		unicode_decimal: 59511
	},
	{
		icon_id: "4936631",
		name: "id card-fill",
		font_class: "idcard-fill",
		unicode: "e878",
		unicode_decimal: 59512
	},
	{
		icon_id: "4936633",
		name: "credit card-fill",
		font_class: "creditcard-fill",
		unicode: "e879",
		unicode_decimal: 59513
	},
	{
		icon_id: "4936635",
		name: "read-fill",
		font_class: "read-fill",
		unicode: "e87a",
		unicode_decimal: 59514
	},
	{
		icon_id: "4936637",
		name: "delete-fill",
		font_class: "delete-fill",
		unicode: "e87b",
		unicode_decimal: 59515
	},
	{
		icon_id: "4936638",
		name: "notification-fill",
		font_class: "notification-fill",
		unicode: "e87c",
		unicode_decimal: 59516
	},
	{
		icon_id: "4936639",
		name: "flag-fill",
		font_class: "flag-fill",
		unicode: "e87d",
		unicode_decimal: 59517
	},
	{
		icon_id: "4936642",
		name: "rest-fill",
		font_class: "rest-fill",
		unicode: "e87e",
		unicode_decimal: 59518
	},
	{
		icon_id: "4936644",
		name: "skin-fill",
		font_class: "skin-fill",
		unicode: "e87f",
		unicode_decimal: 59519
	},
	{
		icon_id: "4936646",
		name: "sound-fill",
		font_class: "sound-fill",
		unicode: "e880",
		unicode_decimal: 59520
	},
	{
		icon_id: "4936649",
		name: "bulb-fill",
		font_class: "bulb-fill",
		unicode: "e881",
		unicode_decimal: 59521
	},
	{
		icon_id: "4936650",
		name: "bell-fill",
		font_class: "bell-fill",
		unicode: "e882",
		unicode_decimal: 59522
	},
	{
		icon_id: "4936651",
		name: "filter-fill",
		font_class: "filter-fill",
		unicode: "e883",
		unicode_decimal: 59523
	},
	{
		icon_id: "4936652",
		name: "fire-fill",
		font_class: "fire-fill",
		unicode: "e884",
		unicode_decimal: 59524
	},
	{
		icon_id: "4936653",
		name: "funnel plot-fill",
		font_class: "funnelplot-fill",
		unicode: "e885",
		unicode_decimal: 59525
	},
	{
		icon_id: "4936654",
		name: "gift-fill",
		font_class: "gift-fill",
		unicode: "e886",
		unicode_decimal: 59526
	},
	{
		icon_id: "4936655",
		name: "hourglass-fill",
		font_class: "hourglass-fill",
		unicode: "e887",
		unicode_decimal: 59527
	},
	{
		icon_id: "4936656",
		name: "home-fill",
		font_class: "home-fill",
		unicode: "e888",
		unicode_decimal: 59528
	},
	{
		icon_id: "4936657",
		name: "trophy-fill",
		font_class: "trophy-fill",
		unicode: "e889",
		unicode_decimal: 59529
	},
	{
		icon_id: "4936659",
		name: "location-fill",
		font_class: "location-fill",
		unicode: "e88a",
		unicode_decimal: 59530
	},
	{
		icon_id: "4936665",
		name: "cloud-fill",
		font_class: "cloud-fill",
		unicode: "e88b",
		unicode_decimal: 59531
	},
	{
		icon_id: "4936668",
		name: "eye-fill",
		font_class: "eye-fill",
		unicode: "e88c",
		unicode_decimal: 59532
	},
	{
		icon_id: "4936669",
		name: "like-fill",
		font_class: "like-fill",
		unicode: "e88d",
		unicode_decimal: 59533
	},
	{
		icon_id: "4936671",
		name: "lock-fill",
		font_class: "lock-fill",
		unicode: "e88e",
		unicode_decimal: 59534
	},
	{
		icon_id: "4936673",
		name: "star-fill",
		font_class: "star-fill",
		unicode: "e88f",
		unicode_decimal: 59535
	},
	{
		icon_id: "4936674",
		name: "unlock-fill",
		font_class: "unlock-fill",
		unicode: "e890",
		unicode_decimal: 59536
	},
	{
		icon_id: "4936675",
		name: "alert-fill",
		font_class: "alert-fill",
		unicode: "e891",
		unicode_decimal: 59537
	},
	{
		icon_id: "4936679",
		name: "edit-fill",
		font_class: "edit-fill",
		unicode: "e892",
		unicode_decimal: 59538
	},
	{
		icon_id: "4936680",
		name: "pushpin-fill",
		font_class: "pushpin-fill",
		unicode: "e893",
		unicode_decimal: 59539
	},
	{
		icon_id: "4936681",
		name: "rocket-fill",
		font_class: "rocket-fill",
		unicode: "e894",
		unicode_decimal: 59540
	},
	{
		icon_id: "4765721",
		name: "check-circle",
		font_class: "check-circle",
		unicode: "e77d",
		unicode_decimal: 59261
	},
	{
		icon_id: "4936682",
		name: "thunderbolt-fill",
		font_class: "thunderbolt-fill",
		unicode: "e895",
		unicode_decimal: 59541
	},
	{
		icon_id: "4765724",
		name: "compass",
		font_class: "compass",
		unicode: "e77e",
		unicode_decimal: 59262
	},
	{
		icon_id: "4936683",
		name: "tag-fill",
		font_class: "tag-fill",
		unicode: "e896",
		unicode_decimal: 59542
	},
	{
		icon_id: "4765725",
		name: "close-circle",
		font_class: "close-circle",
		unicode: "e77f",
		unicode_decimal: 59263
	},
	{
		icon_id: "4936684",
		name: "wrench-fill",
		font_class: "wrench-fill",
		unicode: "e897",
		unicode_decimal: 59543
	},
	{
		icon_id: "4765727",
		name: "info-circle",
		font_class: "info-circle",
		unicode: "e780",
		unicode_decimal: 59264
	},
	{
		icon_id: "4936688",
		name: "error-fill",
		font_class: "error-fill",
		unicode: "e898",
		unicode_decimal: 59544
	},
	{
		icon_id: "4765728",
		name: "left-circle",
		font_class: "left-circle",
		unicode: "e781",
		unicode_decimal: 59265
	},
	{
		icon_id: "4936690",
		name: "mail-fill",
		font_class: "mail-fill",
		unicode: "e899",
		unicode_decimal: 59545
	},
	{
		icon_id: "4765729",
		name: "down-circle",
		font_class: "down-circle",
		unicode: "e782",
		unicode_decimal: 59266
	},
	{
		icon_id: "4936692",
		name: "printer-fill",
		font_class: "printer-fill",
		unicode: "e89a",
		unicode_decimal: 59546
	},
	{
		icon_id: "4765731",
		name: "copyright",
		font_class: "copyright",
		unicode: "e783",
		unicode_decimal: 59267
	},
	{
		icon_id: "4936694",
		name: "setting-fill",
		font_class: "setting-fill",
		unicode: "e89b",
		unicode_decimal: 59547
	},
	{
		icon_id: "4765732",
		name: "minus-circle",
		font_class: "minus-circle",
		unicode: "e784",
		unicode_decimal: 59268
	},
	{
		icon_id: "4936976",
		name: "Youtube",
		font_class: "Youtube",
		unicode: "e89c",
		unicode_decimal: 59548
	},
	{
		icon_id: "4765734",
		name: "plus-circle",
		font_class: "plus-circle",
		unicode: "e785",
		unicode_decimal: 59269
	},
	{
		icon_id: "5756279",
		name: "zoom out",
		font_class: "zoomout",
		unicode: "e89d",
		unicode_decimal: 59549
	},
	{
		icon_id: "4765735",
		name: "play-circle",
		font_class: "play-circle",
		unicode: "e786",
		unicode_decimal: 59270
	},
	{
		icon_id: "5756284",
		name: "zoom in",
		font_class: "zoomin",
		unicode: "e89e",
		unicode_decimal: 59550
	},
	{
		icon_id: "4765736",
		name: "question-circle",
		font_class: "question-circle",
		unicode: "e787",
		unicode_decimal: 59271
	},
	{
		icon_id: "6598313",
		name: "bug-fill",
		font_class: "bug-fill",
		unicode: "e8e8",
		unicode_decimal: 59624
	},
	{
		icon_id: "4765738",
		name: "right-circle",
		font_class: "right-circle",
		unicode: "e788",
		unicode_decimal: 59272
	},
	{
		icon_id: "6598314",
		name: "bug",
		font_class: "bug",
		unicode: "e8e9",
		unicode_decimal: 59625
	},
	{
		icon_id: "4765739",
		name: "smile",
		font_class: "smile",
		unicode: "e789",
		unicode_decimal: 59273
	},
	{
		icon_id: "6598318",
		name: "verified",
		font_class: "verified",
		unicode: "e8ea",
		unicode_decimal: 59626
	},
	{
		icon_id: "4765743",
		name: "earth",
		font_class: "earth",
		unicode: "e78a",
		unicode_decimal: 59274
	},
	{
		icon_id: "6598321",
		name: "switch user",
		font_class: "switchuser",
		unicode: "e8eb",
		unicode_decimal: 59627
	},
	{
		icon_id: "4765745",
		name: "up-circle",
		font_class: "up-circle",
		unicode: "e78b",
		unicode_decimal: 59275
	},
	{
		icon_id: "6598339",
		name: "caret-down",
		font_class: "caret-down",
		unicode: "e8ec",
		unicode_decimal: 59628
	},
	{
		icon_id: "4765746",
		name: "warning-circle",
		font_class: "warning-circle",
		unicode: "e78c",
		unicode_decimal: 59276
	},
	{
		icon_id: "6598341",
		name: "caret-up",
		font_class: "caret-up",
		unicode: "e8ed",
		unicode_decimal: 59629
	},
	{
		icon_id: "4765811",
		name: "sync",
		font_class: "sync",
		unicode: "e78d",
		unicode_decimal: 59277
	},
	{
		icon_id: "6598342",
		name: "caret-right",
		font_class: "caret-right",
		unicode: "e8ee",
		unicode_decimal: 59630
	},
	{
		icon_id: "4765837",
		name: "undo",
		font_class: "undo",
		unicode: "e78e",
		unicode_decimal: 59278
	},
	{
		icon_id: "6598343",
		name: "caret-left",
		font_class: "caret-left",
		unicode: "e8ef",
		unicode_decimal: 59631
	},
	{
		icon_id: "4765838",
		name: "redo",
		font_class: "redo",
		unicode: "e78f",
		unicode_decimal: 59279
	},
	{
		icon_id: "6598347",
		name: "search",
		font_class: "search",
		unicode: "e8f0",
		unicode_decimal: 59632
	},
	{
		icon_id: "4765852",
		name: "reload",
		font_class: "reload",
		unicode: "e790",
		unicode_decimal: 59280
	},
	{
		icon_id: "6598348",
		name: "retweet",
		font_class: "retweet",
		unicode: "e8f1",
		unicode_decimal: 59633
	},
	{
		icon_id: "4765866",
		name: "message",
		font_class: "message",
		unicode: "e791",
		unicode_decimal: 59281
	},
	{
		icon_id: "6598349",
		name: "login",
		font_class: "login",
		unicode: "e8f2",
		unicode_decimal: 59634
	},
	{
		icon_id: "4765881",
		name: "dashboard",
		font_class: "dashboard",
		unicode: "e792",
		unicode_decimal: 59282
	},
	{
		icon_id: "7834345",
		name: "plus",
		font_class: "plus",
		unicode: "e8fe",
		unicode_decimal: 59646
	},
	{
		icon_id: "4765887",
		name: "poweroff",
		font_class: "poweroff",
		unicode: "e793",
		unicode_decimal: 59283
	},
	{
		icon_id: "8092167",
		name: "eye-close",
		font_class: "eye-close",
		unicode: "e8ff",
		unicode_decimal: 59647
	},
	{
		icon_id: "4765888",
		name: "logout",
		font_class: "logout",
		unicode: "e794",
		unicode_decimal: 59284
	},
	{
		icon_id: "8094805",
		name: "clear",
		font_class: "clear",
		unicode: "e900",
		unicode_decimal: 59648
	},
	{
		icon_id: "4765890",
		name: "pie chart",
		font_class: "piechart",
		unicode: "e795",
		unicode_decimal: 59285
	},
	{
		icon_id: "9230691",
		name: "compress",
		font_class: "compress",
		unicode: "e914",
		unicode_decimal: 59668
	},
	{
		icon_id: "4765891",
		name: "setting",
		font_class: "setting",
		unicode: "e796",
		unicode_decimal: 59286
	},
	{
		icon_id: "9230692",
		name: "expend",
		font_class: "expend",
		unicode: "e915",
		unicode_decimal: 59669
	},
	{
		icon_id: "4765896",
		name: "eye",
		font_class: "eye",
		unicode: "e797",
		unicode_decimal: 59287
	},
	{
		icon_id: "9230696",
		name: "send",
		font_class: "send",
		unicode: "e916",
		unicode_decimal: 59670
	},
	{
		icon_id: "4765897",
		name: "location",
		font_class: "location",
		unicode: "e798",
		unicode_decimal: 59288
	},
	{
		icon_id: "4765957",
		name: "edit-square",
		font_class: "edit-square",
		unicode: "e799",
		unicode_decimal: 59289
	},
	{
		icon_id: "4765958",
		name: "export",
		font_class: "export",
		unicode: "e79a",
		unicode_decimal: 59290
	},
	{
		icon_id: "4765959",
		name: "save",
		font_class: "save",
		unicode: "e79b",
		unicode_decimal: 59291
	},
	{
		icon_id: "4765960",
		name: "Import",
		font_class: "Import",
		unicode: "e79c",
		unicode_decimal: 59292
	},
	{
		icon_id: "4765962",
		name: "app store",
		font_class: "appstore",
		unicode: "e79d",
		unicode_decimal: 59293
	},
	{
		icon_id: "4765966",
		name: "layout",
		font_class: "layout",
		unicode: "e79e",
		unicode_decimal: 59294
	},
	{
		icon_id: "4765969",
		name: "control",
		font_class: "control",
		unicode: "e79f",
		unicode_decimal: 59295
	},
	{
		icon_id: "4765971",
		name: "detail",
		font_class: "detail",
		unicode: "e7a0",
		unicode_decimal: 59296
	},
	{
		icon_id: "4765972",
		name: "minus-square",
		font_class: "minus-square",
		unicode: "e7a1",
		unicode_decimal: 59297
	},
	{
		icon_id: "4765973",
		name: "plus-square",
		font_class: "plus-square",
		unicode: "e7a2",
		unicode_decimal: 59298
	},
	{
		icon_id: "4765975",
		name: "project",
		font_class: "project",
		unicode: "e7a3",
		unicode_decimal: 59299
	},
	{
		icon_id: "4766253",
		name: "check-square",
		font_class: "check-square",
		unicode: "e7a8",
		unicode_decimal: 59304
	},
	{
		icon_id: "4766265",
		name: "border",
		font_class: "border",
		unicode: "e7a9",
		unicode_decimal: 59305
	},
	{
		icon_id: "4766289",
		name: "add user",
		font_class: "adduser",
		unicode: "e7ae",
		unicode_decimal: 59310
	},
	{
		icon_id: "4766290",
		name: "delete team",
		font_class: "deleteteam",
		unicode: "e7af",
		unicode_decimal: 59311
	},
	{
		icon_id: "4766291",
		name: "delete user",
		font_class: "deleteuser",
		unicode: "e7b0",
		unicode_decimal: 59312
	},
	{
		icon_id: "4766292",
		name: "addteam",
		font_class: "addteam",
		unicode: "e7b1",
		unicode_decimal: 59313
	},
	{
		icon_id: "4766293",
		name: "user",
		font_class: "user",
		unicode: "e7b2",
		unicode_decimal: 59314
	},
	{
		icon_id: "4766294",
		name: "team",
		font_class: "team",
		unicode: "e7b3",
		unicode_decimal: 59315
	},
	{
		icon_id: "4766297",
		name: "area chart",
		font_class: "areachart",
		unicode: "e7b4",
		unicode_decimal: 59316
	},
	{
		icon_id: "4766298",
		name: "line chart",
		font_class: "linechart",
		unicode: "e7b5",
		unicode_decimal: 59317
	},
	{
		icon_id: "4766299",
		name: "bar chart",
		font_class: "barchart",
		unicode: "e7b6",
		unicode_decimal: 59318
	},
	{
		icon_id: "4766300",
		name: "point map",
		font_class: "pointmap",
		unicode: "e7b7",
		unicode_decimal: 59319
	},
	{
		icon_id: "4766438",
		name: "container",
		font_class: "container",
		unicode: "e7b8",
		unicode_decimal: 59320
	},
	{
		icon_id: "4766439",
		name: "database",
		font_class: "database",
		unicode: "e7b9",
		unicode_decimal: 59321
	},
	{
		icon_id: "4766440",
		name: "sever",
		font_class: "sever",
		unicode: "e7ba",
		unicode_decimal: 59322
	},
	{
		icon_id: "4766451",
		name: "mobile",
		font_class: "mobile",
		unicode: "e7bb",
		unicode_decimal: 59323
	},
	{
		icon_id: "4766454",
		name: "book",
		font_class: "book",
		unicode: "e7bc",
		unicode_decimal: 59324
	},
	{
		icon_id: "4766459",
		name: "file done",
		font_class: "filedone",
		unicode: "e7bd",
		unicode_decimal: 59325
	},
	{
		icon_id: "4766460",
		name: "reconciliation",
		font_class: "reconciliation",
		unicode: "e7be",
		unicode_decimal: 59326
	},
	{
		icon_id: "4766461",
		name: "file -exception",
		font_class: "file-exception",
		unicode: "e7bf",
		unicode_decimal: 59327
	},
	{
		icon_id: "4766462",
		name: "file sync",
		font_class: "filesync",
		unicode: "e7c0",
		unicode_decimal: 59328
	},
	{
		icon_id: "4766463",
		name: "file search",
		font_class: "filesearch",
		unicode: "e7c1",
		unicode_decimal: 59329
	},
	{
		icon_id: "4766464",
		name: "solution",
		font_class: "solution",
		unicode: "e7c2",
		unicode_decimal: 59330
	},
	{
		icon_id: "4766465",
		name: "file protect",
		font_class: "fileprotect",
		unicode: "e7c3",
		unicode_decimal: 59331
	},
	{
		icon_id: "4766468",
		name: "file-add",
		font_class: "file-add",
		unicode: "e7c4",
		unicode_decimal: 59332
	},
	{
		icon_id: "4766469",
		name: "file-excel",
		font_class: "file-excel",
		unicode: "e7c5",
		unicode_decimal: 59333
	},
	{
		icon_id: "4766470",
		name: "file-exclamation",
		font_class: "file-exclamation",
		unicode: "e7c6",
		unicode_decimal: 59334
	},
	{
		icon_id: "4766472",
		name: "file-pdf",
		font_class: "file-pdf",
		unicode: "e7c7",
		unicode_decimal: 59335
	},
	{
		icon_id: "4766473",
		name: "file-image",
		font_class: "file-image",
		unicode: "e7c8",
		unicode_decimal: 59336
	},
	{
		icon_id: "4766474",
		name: "file-markdown",
		font_class: "file-markdown",
		unicode: "e7c9",
		unicode_decimal: 59337
	},
	{
		icon_id: "4766475",
		name: "file-unknown",
		font_class: "file-unknown",
		unicode: "e7ca",
		unicode_decimal: 59338
	},
	{
		icon_id: "4766476",
		name: "file-ppt",
		font_class: "file-ppt",
		unicode: "e7cb",
		unicode_decimal: 59339
	},
	{
		icon_id: "4766477",
		name: "file-word",
		font_class: "file-word",
		unicode: "e7cc",
		unicode_decimal: 59340
	},
	{
		icon_id: "4766478",
		name: "file",
		font_class: "file",
		unicode: "e7cd",
		unicode_decimal: 59341
	},
	{
		icon_id: "4766480",
		name: "file-text",
		font_class: "file-text",
		unicode: "e7ce",
		unicode_decimal: 59342
	},
	{
		icon_id: "4766481",
		name: "file-copy",
		font_class: "file-copy",
		unicode: "e7cf",
		unicode_decimal: 59343
	},
	{
		icon_id: "4766507",
		name: "audit",
		font_class: "audit",
		unicode: "e7d0",
		unicode_decimal: 59344
	},
	{
		icon_id: "4766513",
		name: "safety certificate",
		font_class: "safetycertificate",
		unicode: "e7d1",
		unicode_decimal: 59345
	},
	{
		icon_id: "4766675",
		name: "alert",
		font_class: "alert",
		unicode: "e7d2",
		unicode_decimal: 59346
	},
	{
		icon_id: "4766676",
		name: "delete",
		font_class: "delete",
		unicode: "e7d3",
		unicode_decimal: 59347
	},
	{
		icon_id: "4766677",
		name: "hourglass",
		font_class: "hourglass",
		unicode: "e7d4",
		unicode_decimal: 59348
	},
	{
		icon_id: "4766678",
		name: "bulb",
		font_class: "bulb",
		unicode: "e7d5",
		unicode_decimal: 59349
	},
	{
		icon_id: "4766679",
		name: "experiment",
		font_class: "experiment",
		unicode: "e7d6",
		unicode_decimal: 59350
	},
	{
		icon_id: "4766680",
		name: "bell",
		font_class: "bell",
		unicode: "e7d7",
		unicode_decimal: 59351
	},
	{
		icon_id: "4766681",
		name: "trophy",
		font_class: "trophy",
		unicode: "e7d8",
		unicode_decimal: 59352
	},
	{
		icon_id: "4766682",
		name: "rest",
		font_class: "rest",
		unicode: "e7d9",
		unicode_decimal: 59353
	},
	{
		icon_id: "4766684",
		name: "skin",
		font_class: "skin",
		unicode: "e7da",
		unicode_decimal: 59354
	},
	{
		icon_id: "4766685",
		name: "home",
		font_class: "home",
		unicode: "e7db",
		unicode_decimal: 59355
	},
	{
		icon_id: "4766686",
		name: "bank",
		font_class: "bank",
		unicode: "e7dc",
		unicode_decimal: 59356
	},
	{
		icon_id: "4766688",
		name: "filter",
		font_class: "filter",
		unicode: "e7dd",
		unicode_decimal: 59357
	},
	{
		icon_id: "4766689",
		name: "funnel plot",
		font_class: "funnelplot",
		unicode: "e7de",
		unicode_decimal: 59358
	},
	{
		icon_id: "4766692",
		name: "like",
		font_class: "like",
		unicode: "e7df",
		unicode_decimal: 59359
	},
	{
		icon_id: "4766694",
		name: "unlock",
		font_class: "unlock",
		unicode: "e7e0",
		unicode_decimal: 59360
	},
	{
		icon_id: "4766695",
		name: "lock",
		font_class: "lock",
		unicode: "e7e1",
		unicode_decimal: 59361
	},
	{
		icon_id: "4766767",
		name: "flag",
		font_class: "flag",
		unicode: "e7e2",
		unicode_decimal: 59362
	},
	{
		icon_id: "4766778",
		name: "rocket",
		font_class: "rocket",
		unicode: "e7e3",
		unicode_decimal: 59363
	},
	{
		icon_id: "4766779",
		name: "shopping",
		font_class: "shopping",
		unicode: "e7e4",
		unicode_decimal: 59364
	},
	{
		icon_id: "4766846",
		name: "folder",
		font_class: "folder",
		unicode: "e7e5",
		unicode_decimal: 59365
	},
	{
		icon_id: "4766847",
		name: "folder-open",
		font_class: "folder-open",
		unicode: "e7e6",
		unicode_decimal: 59366
	},
	{
		icon_id: "4766848",
		name: "folder-add",
		font_class: "folder-add",
		unicode: "e7e7",
		unicode_decimal: 59367
	},
	{
		icon_id: "4766849",
		name: "deployment unit",
		font_class: "deploymentunit",
		unicode: "e7e8",
		unicode_decimal: 59368
	},
	{
		icon_id: "4766858",
		name: "calendar",
		font_class: "calendar",
		unicode: "e7e9",
		unicode_decimal: 59369
	},
	{
		icon_id: "4766862",
		name: "select",
		font_class: "select",
		unicode: "e7ea",
		unicode_decimal: 59370
	},
	{
		icon_id: "4766872",
		name: "build",
		font_class: "build",
		unicode: "e7eb",
		unicode_decimal: 59371
	},
	{
		icon_id: "4766874",
		name: "sliders",
		font_class: "sliders",
		unicode: "e7ec",
		unicode_decimal: 59372
	},
	{
		icon_id: "4766885",
		name: "gateway",
		font_class: "gateway",
		unicode: "e7ed",
		unicode_decimal: 59373
	},
	{
		icon_id: "4766887",
		name: "printer",
		font_class: "printer",
		unicode: "e7ee",
		unicode_decimal: 59374
	},
	{
		icon_id: "4766888",
		name: "read",
		font_class: "read",
		unicode: "e7ef",
		unicode_decimal: 59375
	},
	{
		icon_id: "4766900",
		name: "cloud-server",
		font_class: "cloud-server",
		unicode: "e7f0",
		unicode_decimal: 59376
	},
	{
		icon_id: "4766901",
		name: "cloud-upload",
		font_class: "cloud-upload",
		unicode: "e7f1",
		unicode_decimal: 59377
	},
	{
		icon_id: "4766902",
		name: "cloud",
		font_class: "cloud",
		unicode: "e7f2",
		unicode_decimal: 59378
	},
	{
		icon_id: "4766903",
		name: "cloud-download",
		font_class: "cloud-download",
		unicode: "e7f3",
		unicode_decimal: 59379
	},
	{
		icon_id: "4766904",
		name: "cloud-sync",
		font_class: "cloud-sync",
		unicode: "e7f4",
		unicode_decimal: 59380
	},
	{
		icon_id: "4766905",
		name: "video",
		font_class: "video",
		unicode: "e7f5",
		unicode_decimal: 59381
	},
	{
		icon_id: "4766906",
		name: "notification",
		font_class: "notification",
		unicode: "e7f6",
		unicode_decimal: 59382
	},
	{
		icon_id: "4766907",
		name: "sound",
		font_class: "sound",
		unicode: "e7f7",
		unicode_decimal: 59383
	},
	{
		icon_id: "4766911",
		name: "radar chart",
		font_class: "radarchart",
		unicode: "e7f8",
		unicode_decimal: 59384
	},
	{
		icon_id: "4766917",
		name: "image",
		font_class: "image",
		unicode: "e7f9",
		unicode_decimal: 59385
	},
	{
		icon_id: "4766918",
		name: "mail",
		font_class: "mail",
		unicode: "e7fa",
		unicode_decimal: 59386
	},
	{
		icon_id: "4766919",
		name: "table",
		font_class: "table",
		unicode: "e7fb",
		unicode_decimal: 59387
	},
	{
		icon_id: "4766920",
		name: "id card",
		font_class: "idcard",
		unicode: "e7fc",
		unicode_decimal: 59388
	},
	{
		icon_id: "4766921",
		name: "credit card",
		font_class: "creditcard",
		unicode: "e7fd",
		unicode_decimal: 59389
	},
	{
		icon_id: "4766951",
		name: "heart",
		font_class: "heart",
		unicode: "e7fe",
		unicode_decimal: 59390
	},
	{
		icon_id: "4766952",
		name: "block",
		font_class: "block",
		unicode: "e7ff",
		unicode_decimal: 59391
	},
	{
		icon_id: "4766953",
		name: "error",
		font_class: "error",
		unicode: "e800",
		unicode_decimal: 59392
	},
	{
		icon_id: "4766954",
		name: "star",
		font_class: "star",
		unicode: "e801",
		unicode_decimal: 59393
	},
	{
		icon_id: "4766956",
		name: "heat map",
		font_class: "heatmap",
		unicode: "e802",
		unicode_decimal: 59394
	},
	{
		icon_id: "4766958",
		name: "attachment",
		font_class: "attachment",
		unicode: "e803",
		unicode_decimal: 59395
	},
	{
		icon_id: "4766959",
		name: "edit",
		font_class: "edit",
		unicode: "e804",
		unicode_decimal: 59396
	},
	{
		icon_id: "4766960",
		name: "key",
		font_class: "key",
		unicode: "e805",
		unicode_decimal: 59397
	},
	{
		icon_id: "4766965",
		name: "link",
		font_class: "link",
		unicode: "e806",
		unicode_decimal: 59398
	},
	{
		icon_id: "4766969",
		name: "pushpin",
		font_class: "pushpin",
		unicode: "e807",
		unicode_decimal: 59399
	},
	{
		icon_id: "4766970",
		name: "phone",
		font_class: "phone",
		unicode: "e808",
		unicode_decimal: 59400
	},
	{
		icon_id: "4766971",
		name: "shake",
		font_class: "shake",
		unicode: "e809",
		unicode_decimal: 59401
	},
	{
		icon_id: "4766975",
		name: "tags",
		font_class: "tags",
		unicode: "e80a",
		unicode_decimal: 59402
	},
	{
		icon_id: "4766982",
		name: "scissor",
		font_class: "scissor",
		unicode: "e80b",
		unicode_decimal: 59403
	},
	{
		icon_id: "4766984",
		name: "mr",
		font_class: "mr",
		unicode: "e80c",
		unicode_decimal: 59404
	},
	{
		icon_id: "4766985",
		name: "share",
		font_class: "share",
		unicode: "e80d",
		unicode_decimal: 59405
	},
	{
		icon_id: "4766986",
		name: "branches",
		font_class: "branches",
		unicode: "e80e",
		unicode_decimal: 59406
	},
	{
		icon_id: "4766995",
		name: "fork",
		font_class: "fork",
		unicode: "e80f",
		unicode_decimal: 59407
	},
	{
		icon_id: "4767011",
		name: "right",
		font_class: "right",
		unicode: "e810",
		unicode_decimal: 59408
	},
	{
		icon_id: "4767012",
		name: "left",
		font_class: "left",
		unicode: "e811",
		unicode_decimal: 59409
	},
	{
		icon_id: "4767013",
		name: "up",
		font_class: "up",
		unicode: "e812",
		unicode_decimal: 59410
	},
	{
		icon_id: "4767014",
		name: "down",
		font_class: "down",
		unicode: "e813",
		unicode_decimal: 59411
	},
	{
		icon_id: "4767015",
		name: "fullscreen",
		font_class: "fullscreen",
		unicode: "e814",
		unicode_decimal: 59412
	},
	{
		icon_id: "4767016",
		name: "fullscreen-exit",
		font_class: "fullscreen-exit",
		unicode: "e815",
		unicode_decimal: 59413
	},
	{
		icon_id: "4767018",
		name: "doubleleft",
		font_class: "doubleleft",
		unicode: "e816",
		unicode_decimal: 59414
	},
	{
		icon_id: "4767019",
		name: "double right",
		font_class: "doubleright",
		unicode: "e817",
		unicode_decimal: 59415
	},
	{
		icon_id: "4767020",
		name: "arrowright",
		font_class: "arrowright",
		unicode: "e818",
		unicode_decimal: 59416
	},
	{
		icon_id: "4767021",
		name: "arrowup",
		font_class: "arrowup",
		unicode: "e819",
		unicode_decimal: 59417
	},
	{
		icon_id: "4767022",
		name: "arrowleft",
		font_class: "arrowleft",
		unicode: "e81a",
		unicode_decimal: 59418
	},
	{
		icon_id: "4767023",
		name: "arrowdown",
		font_class: "arrowdown",
		unicode: "e81b",
		unicode_decimal: 59419
	},
	{
		icon_id: "4767025",
		name: "upload",
		font_class: "upload",
		unicode: "e81c",
		unicode_decimal: 59420
	},
	{
		icon_id: "4767027",
		name: "vertical-align-botto",
		font_class: "vertical-align-botto",
		unicode: "e81d",
		unicode_decimal: 59421
	},
	{
		icon_id: "4767044",
		name: "swap",
		font_class: "swap",
		unicode: "e81e",
		unicode_decimal: 59422
	},
	{
		icon_id: "4767045",
		name: "stock",
		font_class: "stock",
		unicode: "e81f",
		unicode_decimal: 59423
	},
	{
		icon_id: "4767050",
		name: "indent",
		font_class: "indent",
		unicode: "e820",
		unicode_decimal: 59424
	},
	{
		icon_id: "4767051",
		name: "outdent",
		font_class: "outdent",
		unicode: "e821",
		unicode_decimal: 59425
	},
	{
		icon_id: "4767059",
		name: "menu",
		font_class: "menu",
		unicode: "e822",
		unicode_decimal: 59426
	},
	{
		icon_id: "4767060",
		name: "unordered list",
		font_class: "unorderedlist",
		unicode: "e823",
		unicode_decimal: 59427
	},
	{
		icon_id: "4767061",
		name: "ordered list",
		font_class: "orderedlist",
		unicode: "e824",
		unicode_decimal: 59428
	},
	{
		icon_id: "4767072",
		name: "pic-center",
		font_class: "pic-center",
		unicode: "e825",
		unicode_decimal: 59429
	},
	{
		icon_id: "4767073",
		name: "pic-right",
		font_class: "pic-right",
		unicode: "e826",
		unicode_decimal: 59430
	},
	{
		icon_id: "4767074",
		name: "pic-left",
		font_class: "pic-left",
		unicode: "e827",
		unicode_decimal: 59431
	},
	{
		icon_id: "4767091",
		name: "code",
		font_class: "code",
		unicode: "e828",
		unicode_decimal: 59432
	},
	{
		icon_id: "4767093",
		name: "check",
		font_class: "check",
		unicode: "e829",
		unicode_decimal: 59433
	},
	{
		icon_id: "4767094",
		name: "ellipsis",
		font_class: "ellipsis",
		unicode: "e82a",
		unicode_decimal: 59434
	},
	{
		icon_id: "4767096",
		name: "close",
		font_class: "close",
		unicode: "e82b",
		unicode_decimal: 59435
	},
	{
		icon_id: "4767097",
		name: "enter",
		font_class: "enter",
		unicode: "e82c",
		unicode_decimal: 59436
	},
	{
		icon_id: "4767098",
		name: "line",
		font_class: "line",
		unicode: "e82d",
		unicode_decimal: 59437
	},
	{
		icon_id: "4767099",
		name: "minus",
		font_class: "minus",
		unicode: "e82e",
		unicode_decimal: 59438
	},
	{
		icon_id: "4767100",
		name: "question",
		font_class: "question",
		unicode: "e82f",
		unicode_decimal: 59439
	},
	{
		icon_id: "4767102",
		name: "rollback",
		font_class: "rollback",
		unicode: "e830",
		unicode_decimal: 59440
	},
	{
		icon_id: "4767106",
		name: "bg-colors",
		font_class: "bg-colors",
		unicode: "e831",
		unicode_decimal: 59441
	},
	{
		icon_id: "4936456",
		name: "drag",
		font_class: "drag",
		unicode: "e842",
		unicode_decimal: 59458
	},
	{
		icon_id: "4936458",
		name: "gift",
		font_class: "gift",
		unicode: "e843",
		unicode_decimal: 59459
	},
	{
		icon_id: "4936459",
		name: "stop",
		font_class: "stop",
		unicode: "e844",
		unicode_decimal: 59460
	},
	{
		icon_id: "4936460",
		name: "fire",
		font_class: "fire",
		unicode: "e845",
		unicode_decimal: 59461
	},
	{
		icon_id: "4936461",
		name: "thunderbolt",
		font_class: "thunderbolt",
		unicode: "e846",
		unicode_decimal: 59462
	},
	{
		icon_id: "4936478",
		name: "check-circle-fill",
		font_class: "check-circle-fill",
		unicode: "e847",
		unicode_decimal: 59463
	},
	{
		icon_id: "4936479",
		name: "left-circle-fill",
		font_class: "left-circle-fill",
		unicode: "e848",
		unicode_decimal: 59464
	},
	{
		icon_id: "4936480",
		name: "down-circle-fill",
		font_class: "down-circle-fill",
		unicode: "e849",
		unicode_decimal: 59465
	},
	{
		icon_id: "4936481",
		name: "minus-circle-fill",
		font_class: "minus-circle-fill",
		unicode: "e84a",
		unicode_decimal: 59466
	},
	{
		icon_id: "4936482",
		name: "close-circle-fill",
		font_class: "close-circle-fill",
		unicode: "e84b",
		unicode_decimal: 59467
	},
	{
		icon_id: "4936483",
		name: "info-circle-fill",
		font_class: "info-circle-fill",
		unicode: "e84c",
		unicode_decimal: 59468
	},
	{
		icon_id: "4936484",
		name: "up-circle-fill",
		font_class: "up-circle-fill",
		unicode: "e84d",
		unicode_decimal: 59469
	},
	{
		icon_id: "4936485",
		name: "right-circle-fill",
		font_class: "right-circle-fill",
		unicode: "e84e",
		unicode_decimal: 59470
	},
	{
		icon_id: "4936486",
		name: "plus-circle-fill",
		font_class: "plus-circle-fill",
		unicode: "e84f",
		unicode_decimal: 59471
	},
	{
		icon_id: "4936487",
		name: "question-circle-fill",
		font_class: "question-circle-fill",
		unicode: "e850",
		unicode_decimal: 59472
	},
	{
		icon_id: "4936501",
		name: "copyright-circle-fil",
		font_class: "copyright-circle-fil",
		unicode: "e851",
		unicode_decimal: 59473
	},
	{
		icon_id: "4936507",
		name: "play-circle-fill",
		font_class: "play-circle-fill",
		unicode: "e852",
		unicode_decimal: 59474
	},
	{
		icon_id: "4936509",
		name: "smile-fill",
		font_class: "smile-fill",
		unicode: "e853",
		unicode_decimal: 59475
	},
	{
		icon_id: "4936511",
		name: "warning-circle-fill",
		font_class: "warning-circle-fill",
		unicode: "e854",
		unicode_decimal: 59476
	},
	{
		icon_id: "4936519",
		name: "heart-fill",
		font_class: "heart-fill",
		unicode: "e855",
		unicode_decimal: 59477
	},
	{
		icon_id: "4936520",
		name: "pie chart-circle-fil",
		font_class: "piechart-circle-fil",
		unicode: "e856",
		unicode_decimal: 59478
	},
	{
		icon_id: "4936521",
		name: "dashboard-fill",
		font_class: "dashboard-fill",
		unicode: "e857",
		unicode_decimal: 59479
	},
	{
		icon_id: "4936522",
		name: "message-fill",
		font_class: "message-fill",
		unicode: "e858",
		unicode_decimal: 59480
	},
	{
		icon_id: "4936529",
		name: "check-square-fill",
		font_class: "check-square-fill",
		unicode: "e859",
		unicode_decimal: 59481
	},
	{
		icon_id: "4936531",
		name: "minus-square-fill",
		font_class: "minus-square-fill",
		unicode: "e85a",
		unicode_decimal: 59482
	},
	{
		icon_id: "4936532",
		name: "close-square-fill",
		font_class: "close-square-fill",
		unicode: "e85b",
		unicode_decimal: 59483
	},
	{
		icon_id: "4936538",
		name: "plus-square-fill",
		font_class: "plus-square-fill",
		unicode: "e85c",
		unicode_decimal: 59484
	},
	{
		icon_id: "4936543",
		name: "carry out-fill",
		font_class: "carryout-fill",
		unicode: "e85d",
		unicode_decimal: 59485
	},
	{
		icon_id: "4936544",
		name: "calendar-fill",
		font_class: "calendar-fill",
		unicode: "e85e",
		unicode_decimal: 59486
	},
	{
		icon_id: "4936571",
		name: "detail-fill",
		font_class: "detail-fill",
		unicode: "e85f",
		unicode_decimal: 59487
	},
	{
		icon_id: "4936583",
		name: "layout-fill",
		font_class: "layout-fill",
		unicode: "e860",
		unicode_decimal: 59488
	},
	{
		icon_id: "4936584",
		name: "app store-fill",
		font_class: "appstore-fill",
		unicode: "e861",
		unicode_decimal: 59489
	},
	{
		icon_id: "4936585",
		name: "mobile-fill",
		font_class: "mobile-fill",
		unicode: "e862",
		unicode_decimal: 59490
	},
	{
		icon_id: "4936591",
		name: "safety certificate-f",
		font_class: "safetycertificate-f",
		unicode: "e863",
		unicode_decimal: 59491
	},
	{
		icon_id: "4936602",
		name: "file-exclamation-fil",
		font_class: "file-exclamation-fil",
		unicode: "e864",
		unicode_decimal: 59492
	},
	{
		icon_id: "4936604",
		name: "file-add-fill",
		font_class: "file-add-fill",
		unicode: "e865",
		unicode_decimal: 59493
	},
	{
		icon_id: "4936605",
		name: "file-fill",
		font_class: "file-fill",
		unicode: "e866",
		unicode_decimal: 59494
	},
	{
		icon_id: "4936606",
		name: "file-excel-fill",
		font_class: "file-excel-fill",
		unicode: "e867",
		unicode_decimal: 59495
	},
	{
		icon_id: "4936607",
		name: "file-markdown-fill",
		font_class: "file-markdown-fill",
		unicode: "e868",
		unicode_decimal: 59496
	},
	{
		icon_id: "4936608",
		name: "file-text-fill",
		font_class: "file-text-fill",
		unicode: "e869",
		unicode_decimal: 59497
	},
	{
		icon_id: "4936609",
		name: "file-ppt-fill",
		font_class: "file-ppt-fill",
		unicode: "e86a",
		unicode_decimal: 59498
	},
	{
		icon_id: "4936610",
		name: "file-unknown-fill",
		font_class: "file-unknown-fill",
		unicode: "e86b",
		unicode_decimal: 59499
	},
	{
		icon_id: "4936611",
		name: "file-word-fill",
		font_class: "file-word-fill",
		unicode: "e86c",
		unicode_decimal: 59500
	},
	{
		icon_id: "4936612",
		name: "file-zip-fill",
		font_class: "file-zip-fill",
		unicode: "e86d",
		unicode_decimal: 59501
	},
	{
		icon_id: "4936613",
		name: "file-pdf-fill",
		font_class: "file-pdf-fill",
		unicode: "e86e",
		unicode_decimal: 59502
	},
	{
		icon_id: "4936615",
		name: "file-image-fill",
		font_class: "file-image-fill",
		unicode: "e86f",
		unicode_decimal: 59503
	},
	{
		icon_id: "4936618",
		name: "file-copy-fill",
		font_class: "file-copy-fill",
		unicode: "e870",
		unicode_decimal: 59504
	},
	{
		icon_id: "4936622",
		name: "folder-add-fill",
		font_class: "folder-add-fill",
		unicode: "e871",
		unicode_decimal: 59505
	},
	{
		icon_id: "4936623",
		name: "folder-fill",
		font_class: "folder-fill",
		unicode: "e872",
		unicode_decimal: 59506
	}
];
var icon$1 = {
	id: id,
	name: name$1,
	font_family: font_family,
	css_prefix_text: css_prefix_text,
	description: description,
	glyphs: glyphs
};

var BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left'
  }
};
function renderThumbStyle(_ref) {
  var move = _ref.move,
      size = _ref.size,
      bar = _ref.bar;
  var style = {};
  var translate = "translate" + bar.axis + "(" + move + "%)";
  style[bar.size] = size;
  style.transform = translate;
  style.msTransform = translate;
  style.webkitTransform = translate;
  return style;
} // 数组转换成对象

function toObject$1(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend$1(res, arr[i]);
    }
  }

  return res;
}

function extend$1(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}

var Bar = {
  name: 'Bar',
  props: {
    vertical: Boolean,
    size: String,
    move: Number
  },
  setup: function setup(props) {
    var instance = vue.getCurrentInstance();
    var thumb = vue.ref(null);
    var wrap = vue.inject('scroll-bar-wrap', {});
    var bar = vue.computed(function () {
      return BAR_MAP[props.vertical ? 'vertical' : 'horizontal'];
    });
    var barStore = vue.ref({});
    var cursorDown = vue.ref(null);

    var clickThumbHandler = function clickThumbHandler(e) {
      // prevent click event of right button
      if (e.ctrlKey || e.button === 2) {
        return;
      }

      startDrag(e);
      barStore.value[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
    };

    var clickTrackHandler = function clickTrackHandler(e) {
      var offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      var thumbHalf = thumb.value[bar.value.offset] / 2;
      var thumbPositionPercentage = (offset - thumbHalf) * 100 / instance.vnode.el[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };

    var startDrag = function startDrag(e) {
      e.stopImmediatePropagation();
      cursorDown.value = true;
      on$1(document, 'mousemove', mouseMoveDocumentHandler);
      on$1(document, 'mouseup', mouseUpDocumentHandler);

      document.onselectstart = function () {
        return false;
      };
    };

    var mouseMoveDocumentHandler = function mouseMoveDocumentHandler(e) {
      if (cursorDown.value === false) return;
      var prevPage = barStore.value[bar.value.axis];
      if (!prevPage) return;
      var offset = (instance.vnode.el.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      var thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / instance.vnode.el[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };

    function mouseUpDocumentHandler() {
      cursorDown.value = false;
      barStore.value[bar.value.axis] = 0;
      off$1(document, 'mousemove', mouseMoveDocumentHandler);
      document.onselectstart = null;
    }

    vue.onUnmounted(function () {
      off$1(document, 'mouseup', mouseUpDocumentHandler);
    });
    return function () {
      return vue.h('div', {
        class: ['bin-scrollbar__bar', 'is-' + bar.value.key],
        onMousedown: clickTrackHandler
      }, vue.h('div', {
        ref: thumb,
        class: 'bin-scrollbar__thumb',
        onMousedown: clickThumbHandler,
        style: renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        })
      }));
    };
  }
};

var script$1C = {
  name: 'BScrollbar',
  components: {
    Bar: Bar
  },
  props: {
    native: {
      type: Boolean,
      default: false
    },
    wrapStyle: {
      type: [String, Array],
      default: ''
    },
    wrapClass: {
      type: [String, Array],
      default: ''
    },
    viewClass: {
      type: [String, Array],
      default: ''
    },
    viewStyle: {
      type: [String, Array],
      default: ''
    },
    noresize: Boolean,
    // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
    tag: {
      type: String,
      default: 'div'
    }
  },
  setup: function setup(props) {
    var sizeWidth = vue.ref('0');
    var sizeHeight = vue.ref('0');
    var moveX = vue.ref(0);
    var moveY = vue.ref(0);
    var wrap = vue.ref(null);
    var resize = vue.ref(null);
    vue.provide('scroll-bar-wrap', wrap);

    var handleScroll = function handleScroll() {
      if (!props.native && wrap.value) {
        moveY.value = wrap.value.scrollTop * 100 / wrap.value.clientHeight;
        moveX.value = wrap.value.scrollLeft * 100 / wrap.value.clientWidth;
      }
    };

    var update = function update() {
      if (!wrap.value) return;
      var heightPercentage = wrap.value.clientHeight * 100 / wrap.value.scrollHeight;
      var widthPercentage = wrap.value.clientWidth * 100 / wrap.value.scrollWidth;
      sizeHeight.value = heightPercentage < 100 ? heightPercentage + '%' : '';
      sizeWidth.value = widthPercentage < 100 ? widthPercentage + '%' : '';
    };

    vue.onMounted(function () {
      if (props.native) return;
      vue.nextTick(update);

      if (!props.noresize) {
        on$1(window, 'resize', update);
        addResizeListener(resize.value, update);
      }
    });
    vue.onBeforeUnmount(function () {
      if (props.native) return;

      if (!props.noresize) {
        off$1(window, 'resize', update);
        removeResizeListener(resize.value, update);
      }
    });
    var style = vue.computed(function () {
      var style = props.wrapStyle;

      if (Array.isArray(props.wrapStyle)) {
        style = toObject$1(props.wrapStyle);
      }

      return style;
    });
    return {
      moveX: moveX,
      moveY: moveY,
      sizeWidth: sizeWidth,
      sizeHeight: sizeHeight,
      style: style,
      wrap: wrap,
      resize: resize,
      update: update,
      handleScroll: handleScroll
    };
  }
};

var _hoisted_1$Z = {
  class: "bin-scrollbar"
};
function render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_bar = vue.resolveComponent("bar");

  return vue.openBlock(), vue.createBlock("div", _hoisted_1$Z, [vue.createVNode("div", {
    ref: "wrap",
    class: [$props.wrapClass, 'bin-scrollbar__wrap', $props.native ? '' : 'bin-scrollbar__wrap--hidden-default'],
    style: $setup.style,
    onScroll: _cache[1] || (_cache[1] = function () {
      return $setup.handleScroll && $setup.handleScroll.apply($setup, arguments);
    })
  }, [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($props.tag), {
    ref: "resize",
    class: ['bin-scrollbar__view', $props.viewClass],
    style: $props.viewStyle
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["class", "style"]))], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  ), !$props.native ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createVNode(_component_bar, {
    move: $setup.moveX,
    size: $setup.sizeWidth
  }, null, 8
  /* PROPS */
  , ["move", "size"]), vue.createVNode(_component_bar, {
    vertical: "",
    move: $setup.moveY,
    size: $setup.sizeHeight
  }, null, 8
  /* PROPS */
  , ["move", "size"])], 64
  /* STABLE_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)]);
}

script$1C.render = render$1y;
script$1C.__file = "src/components/scrollbar/scrollbar.vue";

var validSize = function validSize(val) {
  return ['', 'large', 'default', 'small', 'mini'].includes(val);
};

var script$1B = {
  name: 'BButton',
  directives: {
    clickAnimation: ClickAnimation,
    waves: Waves
  },
  props: {
    type: {
      type: String,
      validator: function validator(val) {
        return ['default', 'primary', 'success', 'warning', 'info', 'danger', 'text'].includes(val);
      }
    },
    size: {
      type: String,
      validator: validSize
    },
    icon: String,
    iconStyle: Object,
    loading: Boolean,
    loadingIcon: String,
    disabled: Boolean,
    plain: Boolean,
    round: Boolean,
    dashed: Boolean,
    transparent: Boolean,
    background: Boolean,
    animationType: {
      type: String,
      validator: function validator(val) {
        return ['click', 'waves'].includes(val);
      },
      default: 'click'
    },
    textColor: String,
    nativeType: {
      type: String,
      default: 'button',
      validator: function validator(val) {
        return ['button', 'submit', 'reset'].includes(val);
      }
    }
  },
  emits: ['click'],
  computed: {
    waveColor: function waveColor() {
      return this.type === 'default' || this.type === 'dashed' || this.plain || this.transparent || this.dashed ? 'rgba(0, 0, 0, 0.25)' : 'rgba(255, 255, 255, 0.3)';
    },
    textStyle: function textStyle() {
      var colorMap = {
        primary: '#1089ff',
        success: '#52c41a',
        info: '#35495E',
        warning: '#fa8c16',
        danger: '#f5222d'
      };
      var color = this.textColor ? colorMap[this.textColor] ? colorMap[this.textColor] : this.textColor : null;
      return color ? {
        color: color
      } : null;
    },
    iconStyles: function iconStyles() {
      return _extends$2({}, this.textStyle, this.iconStyle);
    },
    btnClass: function btnClass() {
      var _ref;

      return ["bin-button--" + (this.type || 'default'), (_ref = {}, _ref["bin-button--" + this.size] = this.size, _ref['is-disabled'] = this.disabled, _ref['is-loading'] = this.loading, _ref['is-plain'] = this.plain, _ref['is-round'] = this.round, _ref['is-dashed'] = this.dashed, _ref['is-transparent'] = this.transparent, _ref['is-background'] = this.background, _ref)];
    }
  },
  methods: {
    handleClick: function handleClick(e) {
      this.$emit('click', e);
    }
  }
};

function render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  var _ref;

  var _directive_click_animation = vue.resolveDirective("click-animation");

  var _directive_waves = vue.resolveDirective("waves");

  return $props.type !== 'text' && $props.animationType === 'click' ? vue.withDirectives((vue.openBlock(), vue.createBlock("button", {
    key: 0,
    class: ["bin-button", $options.btnClass],
    disabled: $props.disabled || $props.loading,
    type: $props.nativeType,
    onClick: _cache[1] || (_cache[1] = function () {
      return $options.handleClick && $options.handleClick.apply($options, arguments);
    })
  }, [$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: ["button-loading icon-is-rotating", ['b-iconfont', "b-icon-" + ($props.loadingIcon || 'loading')]],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), $props.icon && !$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 1,
    class: ['b-iconfont', 'b-icon-' + $props.icon],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), _ctx.$slots.default ? (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    style: $options.textStyle
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["disabled", "type"])), [[_directive_click_animation]]) : $props.type !== 'text' && $props.animationType === 'waves' ? vue.withDirectives((vue.openBlock(), vue.createBlock("button", {
    key: 1,
    class: ["bin-button", $options.btnClass],
    disabled: $props.disabled || $props.loading,
    type: $props.nativeType,
    onClick: _cache[2] || (_cache[2] = function () {
      return $options.handleClick && $options.handleClick.apply($options, arguments);
    })
  }, [$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: ["button-loading icon-is-rotating", ['b-iconfont', "b-icon-" + ($props.loadingIcon || 'loading')]],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), $props.icon && !$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 1,
    class: ['b-iconfont', 'b-icon-' + $props.icon],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), _ctx.$slots.default ? (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    style: $options.textStyle
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["disabled", "type"])), [[_directive_waves, $options.waveColor]]) : (vue.openBlock(), vue.createBlock("button", {
    key: 2,
    disabled: $props.disabled || $props.loading,
    type: $props.nativeType,
    class: ["bin-button", [(_ref = {}, _ref["bin-button--" + $props.type] = $props.type, _ref['is-disabled'] = $props.disabled, _ref['is-loading'] = $props.loading, _ref)]],
    onClick: _cache[3] || (_cache[3] = function () {
      return $options.handleClick && $options.handleClick.apply($options, arguments);
    })
  }, [$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: ["button-loading icon-is-rotating", ['b-iconfont', "b-icon-" + ($props.loadingIcon || 'loading')]],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), $props.icon && !$props.loading ? (vue.openBlock(), vue.createBlock("i", {
    key: 1,
    class: ['b-iconfont', 'b-icon-' + $props.icon],
    style: $options.iconStyles
  }, null, 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), _ctx.$slots.default ? (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    style: $options.textStyle
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["disabled", "type"]));
}

script$1B.render = render$1x;
script$1B.__file = "src/components/button/button.vue";

var script$1A = {
  name: 'BIconSelect',
  components: {
    BEmpty: script$1H,
    BIcon: script$1I,
    BButton: script$1B,
    BScrollbar: script$1C,
    BInput: script$1D,
    BPopper: script$1F
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    modelValue: String,
    size: {
      type: String,
      validator: function validator(value) {
        return ['small', 'large', 'default', 'mini'].includes(value);
      },
      default: 'default'
    },
    disabled: Boolean,
    clearable: Boolean,
    placeholder: {
      type: String,
      default: '选择图标'
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: String,
      default: 'close-circle-fill'
    },
    popperClass: String
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'clear', 'visible-change', 'focus', 'blur'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var popper = vue.ref(null);
    var input = vue.ref(null);
    var reference = vue.ref(null);
    var selectedLabel = vue.ref(props.modelValue);
    var visible = vue.ref(false);
    var inputHovering = vue.ref(false);
    var icons = vue.ref(icon$1.glyphs.map(function (i) {
      return i.font_class;
    }));
    var query = vue.ref('');
    var popperPaneRef = vue.computed(function () {
      var _popper$value;

      return (_popper$value = popper.value) == null ? void 0 : _popper$value.popperRef;
    });
    var showClose = vue.computed(function () {
      return selectedLabel.value && inputHovering.value;
    });
    var iconClass = vue.computed(function () {
      return visible.value ? 'down is-reverse' : 'down';
    });
    var inputSize = vue.computed(function () {
      return props.size || BForm.size;
    });
    var showIcons = vue.computed(function () {
      return query.value ? icons.value.filter(function (i) {
        return i.includes(query.value);
      }) : icons.value;
    });

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        formEmit = _useForm.formEmit;

    function handleSelect(name) {
      changeValue(name);
      toggleMenu();
    }

    function toggleMenu() {
      visible.value = !visible.value;
    }

    function handleClose() {
      visible.value = false;
      query.value = '';
    }

    function handleClearClick() {
      emit('clear');
      changeValue('');
    }

    function changeValue(val) {
      selectedLabel.value = val;
      emit(UPDATE_MODEL_EVENT, val);
      emit(CHANGE_EVENT, val);
      formEmit('change', val);
    }

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      selectedLabel.value = val;
    });
    return {
      reference: reference,
      input: input,
      popper: popper,
      query: query,
      popperPaneRef: popperPaneRef,
      selectedLabel: selectedLabel,
      visible: visible,
      icons: icons,
      inputHovering: inputHovering,
      showClose: showClose,
      iconClass: iconClass,
      showIcons: showIcons,
      inputSize: inputSize,
      toggleMenu: toggleMenu,
      handleSelect: handleSelect,
      handleClose: handleClose,
      handleClearClick: handleClearClick
    };
  }
};

var _withId = /*#__PURE__*/vue.withScopeId("data-v-0040dfb1");

vue.pushScopeId("data-v-0040dfb1");

var _hoisted_1$Y = {
  class: "select-trigger"
};
var _hoisted_2$D = {
  class: "bin-icon-select-panel__query"
};

var _hoisted_3$r = /*#__PURE__*/vue.createTextVNode("没有匹配图标");

vue.popScopeId();

var render$1w = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  var _component_b_button = vue.resolveComponent("b-button");

  var _component_b_input = vue.resolveComponent("b-input");

  var _component_b_scrollbar = vue.resolveComponent("b-scrollbar");

  var _component_b_empty = vue.resolveComponent("b-empty");

  var _component_b_popper = vue.resolveComponent("b-popper");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.withDirectives((vue.openBlock(), vue.createBlock("div", {
    ref: "selectWrapper",
    class: "bin-icon-select",
    onClick: _cache[7] || (_cache[7] = vue.withModifiers(function () {
      return $setup.toggleMenu && $setup.toggleMenu.apply($setup, arguments);
    }, ["stop"]))
  }, [vue.createVNode(_component_b_popper, {
    ref: "popper",
    visible: $setup.visible,
    "onUpdate:visible": _cache[6] || (_cache[6] = function ($event) {
      return $setup.visible = $event;
    }),
    placement: "bottom-start",
    "append-to-body": $props.appendToBody,
    "popper-class": "bin-icon-select__popper " + $props.popperClass,
    "manual-mode": "",
    theme: "light",
    pure: "",
    trigger: "click",
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    "show-arrow": false,
    offset: 4,
    transition: "zoom-in-top"
  }, {
    trigger: _withId(function () {
      return [vue.createVNode("div", _hoisted_1$Y, [vue.createVNode(_component_b_input, {
        ref: "reference",
        modelValue: $setup.selectedLabel,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) {
          return $setup.selectedLabel = $event;
        }),
        type: "text",
        placeholder: $props.placeholder,
        size: $setup.inputSize,
        disabled: $props.disabled,
        readonly: true,
        "validate-event": false,
        class: {
          'is-focus': $setup.visible
        },
        onMouseenter: _cache[3] || (_cache[3] = function ($event) {
          return $setup.inputHovering = true;
        }),
        onMouseleave: _cache[4] || (_cache[4] = function ($event) {
          return $setup.inputHovering = false;
        })
      }, {
        prepend: _withId(function () {
          return [vue.createVNode(_component_b_button, {
            style: {
              "width": "40px",
              "padding": "0"
            }
          }, {
            default: _withId(function () {
              return [vue.createVNode(_component_b_icon, {
                name: $setup.selectedLabel,
                size: "16"
              }, null, 8
              /* PROPS */
              , ["name"])];
            }),
            _: 1
            /* STABLE */

          })];
        }),
        suffix: _withId(function () {
          return [vue.withDirectives(vue.createVNode("i", {
            class: ['bin-select__caret', 'b-iconfont', 'b-icon-' + $setup.iconClass]
          }, null, 2
          /* CLASS */
          ), [[vue.vShow, !$setup.showClose]]), $setup.showClose ? (vue.openBlock(), vue.createBlock("i", {
            key: 0,
            class: "bin-select__caret is-show-close b-iconfont b-icon-close-circle-fill",
            onClick: _cache[1] || (_cache[1] = function () {
              return $setup.handleClearClick && $setup.handleClearClick.apply($setup, arguments);
            })
          })) : vue.createCommentVNode("v-if", true)];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["modelValue", "placeholder", "size", "disabled", "class"])])];
    }),
    default: _withId(function () {
      return [vue.createVNode("div", _hoisted_2$D, [vue.createVNode(_component_b_input, {
        modelValue: $setup.query,
        "onUpdate:modelValue": _cache[5] || (_cache[5] = function ($event) {
          return $setup.query = $event;
        }),
        placeholder: "输入图标名称搜索",
        size: "small",
        clearable: ""
      }, null, 8
      /* PROPS */
      , ["modelValue"])]), vue.withDirectives(vue.createVNode(_component_b_scrollbar, {
        ref: "scrollbar",
        tag: "ul",
        "wrap-class": "bin-icon-select-panel__wrap",
        "view-class": "icon-list"
      }, {
        default: _withId(function () {
          return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.showIcons, function (name) {
            return vue.openBlock(), vue.createBlock("li", {
              key: name,
              class: "list-complete-item",
              title: name,
              onClick: function onClick($event) {
                return $setup.handleSelect(name);
              }
            }, [vue.createVNode("i", {
              class: ['b-iconfont', 'b-icon-' + name]
            }, null, 2
            /* CLASS */
            )], 8
            /* PROPS */
            , ["title", "onClick"]);
          }), 128
          /* KEYED_FRAGMENT */
          ))];
        }),
        _: 1
        /* STABLE */

      }, 512
      /* NEED_PATCH */
      ), [[vue.vShow, $setup.visible && $setup.showIcons.length]]), vue.withDirectives(vue.createVNode(_component_b_empty, null, {
        default: _withId(function () {
          return [_hoisted_3$r];
        }),
        _: 1
        /* STABLE */

      }, 512
      /* NEED_PATCH */
      ), [[vue.vShow, $setup.showIcons.length === 0]])];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["visible", "append-to-body", "popper-class"])], 512
  /* NEED_PATCH */
  )), [[_directive_click_outside, $setup.handleClose, $setup.popperPaneRef]]);
});

script$1A.render = render$1w;
script$1A.__scopeId = "data-v-0040dfb1";
script$1A.__file = "src/components/icon-select/icon-select.vue";

script$1A.install = function (app) {
  app.component(script$1A.name, script$1A);
};

script$1B.install = function (app) {
  app.component(script$1B.name, script$1B);
};

var script$1z = {
  name: 'BButtonGroup'
};

var _hoisted_1$X = {
  class: "bin-button-group"
};
function render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$X, [vue.renderSlot(_ctx.$slots, "default")]);
}

script$1z.render = render$1v;
script$1z.__file = "src/components/button/button-group.vue";

script$1z.install = function (app) {
  app.component(script$1z.name, script$1z);
};

script$1C.install = function (app) {
  app.component(script$1C.name, script$1C);
};

var script$1y = {
  name: 'BBackTop',
  props: {
    visibilityHeight: {
      type: Number,
      default: 400
    },
    target: {
      type: String,
      default: ''
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    },
    duration: {
      type: Number,
      default: 1000
    }
  },
  emits: ['click'],
  setup: function setup(props, ctx) {
    var el = vue.ref(null);
    var container = vue.ref(null);
    var visible = vue.ref(false);
    var styleBottom = vue.computed(function () {
      return props.bottom + "px";
    });
    var styleRight = vue.computed(function () {
      return props.right + "px";
    });

    var onScroll = function onScroll() {
      visible.value = el.value.scrollTop >= props.visibilityHeight;
    };

    var handleClick = function handleClick(event) {
      scrollTop(el.value, el.value.scrollTop, 0, props.duration);
      ctx.emit('click', event);
    };

    var throttledScrollHandler = throttle$2(onScroll, 50);
    vue.onMounted(function () {
      container.value = document;
      el.value = document.documentElement;

      if (props.target) {
        el.value = document.querySelector(props.target);

        if (!el.value) {
          throw new Error("target is not existed: " + props.target);
        }

        container.value = el.value;
      }

      on$1(container.value, 'scroll', throttledScrollHandler);
    });
    vue.onBeforeUnmount(function () {
      off$1(container.value, 'scroll', throttledScrollHandler);
    });
    return {
      el: el,
      container: container,
      visible: visible,
      styleBottom: styleBottom,
      styleRight: styleRight,
      handleClick: handleClick
    };
  }
};

var _hoisted_1$W = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-back-top-inner"
}, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-caret-up"
})], -1
/* HOISTED */
);

function render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade-in"
  }, {
    default: vue.withCtx(function () {
      return [$setup.visible ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        style: {
          'right': $setup.styleRight,
          'bottom': $setup.styleBottom
        },
        class: "bin-back-top",
        onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
          return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
        }, ["stop"]))
      }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
        return [_hoisted_1$W];
      })], 4
      /* STYLE */
      )) : vue.createCommentVNode("v-if", true)];
    }),
    _: 3
    /* FORWARDED */

  });
}

script$1y.render = render$1u;
script$1y.__file = "src/components/back-top/back-top.vue";

script$1y.install = function (app) {
  app.component(script$1y.name, script$1y);
};

script$1H.install = function (app) {
  app.component(script$1H.name, script$1H);
};

script$1G.install = function (app) {
  app.component(script$1G.name, script$1G);
};

var prefixCls$g = 'bin-row';
var script$1x = {
  name: 'BRow',
  props: {
    type: {
      type: String,
      validator: function validator(value) {
        return ['flex'].includes(value);
      }
    },
    align: {
      type: String,
      validator: function validator(value) {
        return ['top', 'middle', 'bottom'].includes(value);
      }
    },
    justify: {
      type: String,
      validator: function validator(value) {
        return ['start', 'end', 'center', 'space-around', 'space-between'].includes(value);
      }
    },
    gutter: {
      type: Number,
      default: 0
    },
    className: String
  },
  setup: function setup(props) {
    vue.provide('BRow', props.gutter);
    var classes = vue.computed(function () {
      var _ref;

      return [(_ref = {}, _ref["" + prefixCls$g] = !props.type, _ref[prefixCls$g + "-" + props.type] = !!props.type, _ref[prefixCls$g + "-" + props.type + "-" + props.align] = !!props.align, _ref[prefixCls$g + "-" + props.type + "-" + props.justify] = !!props.justify, _ref["" + props.className] = !!props.className, _ref)];
    });
    var styles = vue.computed(function () {
      var style = {};

      if (props.gutter !== 0) {
        style = {
          marginLeft: props.gutter / -2 + 'px',
          marginRight: props.gutter / -2 + 'px'
        };
      }

      return style;
    });
    return {
      classes: classes,
      styles: styles
    };
  }
};

function render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.classes,
    style: $setup.styles
  }, [vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  );
}

script$1x.render = render$1t;
script$1x.__file = "src/components/row/row.vue";

script$1x.install = function (app) {
  app.component(script$1x.name, script$1x);
};

var prefixCls$f = 'bin-col';
var script$1w = {
  name: 'BCol',
  props: {
    span: [Number, String],
    order: [Number, String],
    offset: [Number, String],
    push: [Number, String],
    pull: [Number, String],
    className: String,
    xs: [Number, Object],
    sm: [Number, Object],
    md: [Number, Object],
    lg: [Number, Object],
    xl: [Number, Object],
    xxl: [Number, Object]
  },
  setup: function setup(props) {
    var gutter = vue.inject('BRow', 0);
    var classes = vue.computed(function () {
      var _ref;

      var classList = ["" + prefixCls$f, (_ref = {}, _ref[prefixCls$f + "-span-" + props.span] = props.span, _ref[prefixCls$f + "-order-" + props.order] = props.order, _ref[prefixCls$f + "-offset-" + props.offset] = props.offset, _ref[prefixCls$f + "-push-" + props.push] = props.push, _ref[prefixCls$f + "-pull-" + props.pull] = props.pull, _ref["" + props.className] = !!props.className, _ref)];
      ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].forEach(function (size) {
        if (typeof props[size] === 'number') {
          classList.push(prefixCls$f + "-span-" + size + "-" + props[size]);
        } else if (typeof props[size] === 'object') {
          var propItem = props[size];
          Object.keys(propItem).forEach(function (prop) {
            classList.push(prop !== 'span' ? prefixCls$f + "-" + size + "-" + prop + "-" + propItem[prop] : prefixCls$f + "-span-" + size + "-" + propItem[prop]);
          });
        }
      });
      return classList;
    });
    var styles = vue.computed(function () {
      var style = {};

      if (gutter !== 0) {
        style = {
          paddingLeft: gutter / 2 + 'px',
          paddingRight: gutter / 2 + 'px'
        };
      }

      return style;
    });
    return {
      gutter: gutter,
      classes: classes,
      styles: styles
    };
  }
};

function render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.classes,
    style: $setup.styles
  }, [vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  );
}

script$1w.render = render$1s;
script$1w.__file = "src/components/col/col.vue";

script$1w.install = function (app) {
  app.component(script$1w.name, script$1w);
};

var script$1v = {
  name: 'BSpace',
  props: {
    prefixCls: {
      type: String,
      default: 'bin-space'
    }
  },
  setup: function setup(props) {
    return {
      classes: vue.computed(function () {
        return props.prefixCls + "__item";
      })
    };
  }
};

function render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.classes
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$1v.render = render$1r;
script$1v.__file = "src/components/space/item.vue";

var SizeMap = {
  mini: 4,
  small: 8,
  default: 16,
  large: 24
};
var defaultProps$1 = {
  direction: {
    type: String,
    default: 'horizontal'
  },
  class: {
    type: [String, Object, Array],
    default: ''
  },
  style: {
    type: [String, Array, Object]
  },
  alignment: {
    type: String,
    default: 'center'
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: [Object, String, Number],
    default: null,
    validator: function validator(val) {
      return vue.isVNode(val) || isNumber(val) || isString(val);
    }
  },
  wrap: {
    type: Boolean,
    default: false
  },
  size: {
    type: [String, Array, Number],
    validator: function validator(val) {
      return validSize(val) || isNumber(val) || isArray$1(val);
    }
  }
};
function useSpace(props) {
  var classes = vue.computed(function () {
    return ['bin-space', "bin-space--" + props.direction, props.class];
  });
  var horizontalSize = vue.ref(0);
  var verticalSize = vue.ref(0);
  vue.watch(function () {
    return [props.size, props.wrap, props.direction];
  }, function (_ref) {
    var _ref$ = _ref[0],
        size = _ref$ === void 0 ? 'small' : _ref$,
        wrap = _ref[1],
        dir = _ref[2];

    // when the specified size have been given
    if (isArray$1(size)) {
      var _size$ = size[0],
          h = _size$ === void 0 ? 0 : _size$,
          _size$2 = size[1],
          v = _size$2 === void 0 ? 0 : _size$2;
      horizontalSize.value = h;
      verticalSize.value = v;
    } else {
      var val;

      if (isNumber(size)) {
        val = size;
      } else {
        val = SizeMap[size] || SizeMap.small;
      }

      if (wrap && dir === 'horizontal') {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === 'horizontal') {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  }, {
    immediate: true
  });
  var containerStyle = vue.computed(function () {
    var wrapKls = props.wrap ? {
      flexWrap: 'wrap',
      marginBottom: "-" + verticalSize.value + "px"
    } : null;
    var alignment = {
      alignItems: props.alignment
    };
    return [wrapKls, alignment, props.style];
  });
  var itemStyle = vue.computed(function () {
    return {
      paddingBottom: verticalSize.value + "px",
      marginRight: horizontalSize.value + "px"
    };
  });
  return {
    classes: classes,
    containerStyle: containerStyle,
    itemStyle: itemStyle
  };
}

var Space = {
  name: 'BSpace',
  props: defaultProps$1,
  setup: function setup(props) {
    return useSpace(props);
  },
  render: function render(ctx) {
    var classes = ctx.classes,
        $slots = ctx.$slots,
        containerStyle = ctx.containerStyle,
        itemStyle = ctx.itemStyle,
        spacer = ctx.spacer,
        prefixCls = ctx.prefixCls;
    var children = vue.renderSlot($slots, 'default', {
      key: 0
    }, function () {
      return [];
    }); // retrieve the children out via a simple for loop
    // the edge case here is that when users uses directives like <v-for>, <v-if>
    // we need to go one layer deeper

    if (children.children.length === 0) return null; // loop the children, if current children is rendered via `renderList` or `<v-for>`

    if (isArray$1(children.children)) {
      var extractedChildren = [];
      children.children.forEach(function (child, loopKey) {
        if (isFragment(child)) {
          if (isArray$1(child.children)) {
            child.children.forEach(function (nested, key) {
              extractedChildren.push(vue.createVNode(script$1v, {
                style: _extends$2({}, itemStyle, {
                  marginRight: loopKey === children.children.length ? null : itemStyle.marginRight
                }),
                prefixCls: prefixCls,
                key: "nested-" + key
              }, {
                default: function _default() {
                  return [nested];
                }
              }, PatchFlags.PROPS | PatchFlags.STYLE, ['style', 'prefixCls']));
            });
          } // if the current child is valid vnode, then append this current vnode
          // to item as child node.

        } else if (isValidElementNode(child)) {
          extractedChildren.push(vue.createVNode(script$1v, {
            style: _extends$2({}, itemStyle, {
              marginRight: loopKey === children.children.length - 1 ? null : itemStyle.marginRight
            }),
            prefixCls: prefixCls,
            key: "LoopKey" + loopKey
          }, {
            default: function _default() {
              return [child];
            }
          }, PatchFlags.PROPS | PatchFlags.STYLE, ['style', 'prefixCls']));
        }
      });

      if (spacer) {
        // track the current rendering index, when encounters the last element
        // then no need to add a spacer after it.
        var len = extractedChildren.length - 1;
        extractedChildren = extractedChildren.reduce(function (acc, child, idx) {
          return idx === len ? [].concat(acc, [child]) : [].concat(acc, [child, vue.createVNode('span', {
            style: [itemStyle, 'width: 100%'],
            key: idx
          }, [vue.isVNode(spacer) ? spacer : vue.createTextVNode(spacer, PatchFlags.TEXT)], PatchFlags.STYLE)]);
        }, []);
      } // spacer container.


      return vue.createVNode('div', {
        class: classes,
        style: containerStyle
      }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
    }

    return children.children;
  }
};

Space.install = function (app) {
  app.component(Space.name, Space);
};

var script$1u = {
  name: 'BCollapseTransition',
  setup: function setup() {
    return {
      on: {
        beforeEnter: function beforeEnter(el) {
          addClass(el, 'collapse-transition');
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.height = '0';
          el.style.paddingTop = '0';
          el.style.paddingBottom = '0';
        },
        enter: function enter(el) {
          el.dataset.oldOverflow = el.style.overflow;

          if (el.scrollHeight !== 0) {
            el.style.height = el.scrollHeight + 'px';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = '';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }

          el.style.overflow = 'hidden';
        },
        afterEnter: function afterEnter(el) {
          // for safari: remove class then reset height is necessary
          removeClass(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave: function beforeLeave(el) {
          if (!el.dataset) el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.height = el.scrollHeight + 'px';
          el.style.overflow = 'hidden';
        },
        leave: function leave(el) {
          if (el.scrollHeight !== 0) {
            // for safari: add class after set height, or it will jump to zero height suddenly, weired
            addClass(el, 'collapse-transition');
            el.style.height = '0';
            el.style.paddingTop = '0';
            el.style.paddingBottom = '0';
          }
        },
        afterLeave: function afterLeave(el) {
          removeClass(el, 'collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      }
    };
  }
};

function render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, vue.toHandlers($setup.on), {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
    /* FORWARDED */

  }, 16
  /* FULL_PROPS */
  );
}

script$1u.render = render$1q;
script$1u.__file = "src/components/collapse-transition/collapse-transition.vue";

script$1u.install = function (app) {
  app.component(script$1u.name, script$1u);
};

var script$1t = {
  name: 'BDivider',
  props: {
    type: {
      type: String,
      default: 'horizontal',
      // 'horizontal', 'vertical'
      validator: function validator(val) {
        return ['horizontal', 'vertical'].includes(val);
      }
    },
    align: {
      type: String,
      default: 'center',
      // 'left', 'right', 'center'
      validator: function validator(val) {
        return ['left', 'center', 'right'].includes(val);
      }
    },
    dashed: {
      type: Boolean,
      default: false
    }
  }
};

function render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  var _ref;

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-divider', "bin-divider-" + $props.type, (_ref = {}, _ref['bin-divider-dashed'] = !!$props.dashed, _ref)]
  }, [_ctx.$slots.default ? (vue.openBlock(), vue.createBlock("span", {
    key: 0,
    class: ['bin-divider-inner-text', "is-" + $props.align]
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$1t.render = render$1p;
script$1t.__file = "src/components/divider/divider.vue";

script$1t.install = function (app) {
  app.component(script$1t.name, script$1t);
};

var SHOW_EVENT = 'show';
var HIDE_EVENT = 'hide';
function usePopover(props, ctx) {
  var popperStyle = vue.computed(function () {
    var _width;

    if (isString(props.width)) {
      _width = props.width;
    } else {
      _width = props.width + 'px';
    }

    return {
      width: _width,
      zIndex: transferIncrease()
    };
  });
  var popperProps = usePopper(props, ctx);
  vue.watch(popperProps.visibility, function (val) {
    ctx.emit(val ? SHOW_EVENT : HIDE_EVENT);
  });
  return _extends$2({}, popperProps, {
    popperStyle: popperStyle
  });
}

var _hoist = {
  key: 0,
  class: 'bin-popover__title',
  role: 'title'
};
var _content = {
  key: 1,
  class: 'bin-popover__body',
  role: 'body'
};
var script$1s = {
  name: 'BPopover',
  components: {
    BPopper: script$1F
  },
  props: _extends$2({}, defaultProps$2, {
    content: {
      type: String
    },
    trigger: {
      type: String,
      default: 'click'
    },
    title: {
      type: String
    },
    transition: {
      type: String,
      default: 'fade-in-linear'
    },
    width: {
      type: [String, Number],
      default: 150
    }
  }),
  emits: ['update:visible', 'after-enter', 'after-leave', SHOW_EVENT, HIDE_EVENT],
  setup: function setup(props, ctx) {
    if (process.env.NODE_ENV !== 'production' && props.visible && !ctx.slots.reference) {
      throwWarn('BPopover', ' You cannot init popover without given reference');
    }

    return usePopover(props, ctx);
  },
  render: function render() {
    var _this = this;

    var $slots = this.$slots;
    var trigger = $slots.default ? $slots.default() : null;
    var title = renderIf(this.title, 'div', _hoist, vue.toDisplayString(this.title), PatchFlags.TEXT);
    var content = $slots.content ? vue.renderSlot($slots, 'content', {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_this.content), PatchFlags.TEXT)];
    }) : renderIf(this.content, 'div', _content, vue.toDisplayString(this.content), PatchFlags.TEXT);
    var events = this.events,
        onAfterEnter = this.onAfterEnter,
        onAfterLeave = this.onAfterLeave,
        onPopperMouseEnter = this.onPopperMouseEnter,
        onPopperMouseLeave = this.onPopperMouseLeave,
        popperStyle = this.popperStyle,
        popperId = this.popperId,
        popperClass = this.popperClass,
        showArrow = this.showArrow,
        transition = this.transition,
        visibility = this.visibility;
    var kls = [this.content ? 'bin-popover--plain' : '', 'bin-popover', popperClass].join(' ');
    var popover = renderPopper({
      theme: Theme.LIGHT,
      name: transition,
      popperClass: kls,
      popperStyle: popperStyle,
      popperId: popperId,
      visibility: visibility,
      onMouseEnter: onPopperMouseEnter,
      onMouseLeave: onPopperMouseLeave,
      onAfterEnter: onAfterEnter,
      onAfterLeave: onAfterLeave,
      stopPopperMouseEvent: false
    }, [title, content, renderArrow(showArrow)]); // when user uses popover directively, trigger will be null so that we only
    // render a popper.md window for displaying contents

    var _trigger = trigger ? renderTrigger(trigger, _extends$2({
      ariaDescribedby: popperId,
      ref: 'triggerRef'
    }, events)) : vue.createCommentVNode('v-if', true);

    return renderBlock(vue.Fragment, null, [this.trigger === 'click' ? vue.withDirectives(_trigger, [[ClickOutside, this.hide]]) : _trigger, vue.createVNode(vue.Teleport, {
      disabled: !this.appendToBody,
      to: 'body'
    }, [popover], PatchFlags.PROPS, ['disabled'])]);
  }
};

script$1s.__file = "src/components/popover/popover.vue";

script$1s.install = function (app) {
  app.component(script$1s.name, script$1s);
};

var Tooltip = {
  name: 'BTooltip',
  components: {
    BPopper: script$1F
  },
  props: _extends$2({}, defaultProps$2, {
    manual: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      validator: function validator(val) {
        return typeof val === 'boolean';
      },
      default: undefined
    },
    openDelay: {
      type: Number,
      default: 0
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: Number,
      default: 0
    }
  }),
  emits: [UPDATE_MODEL_EVENT],
  setup: function setup(props, ctx) {
    // when manual mode is true, v-model must be passed down
    if (props.manual && typeof props.modelValue === 'undefined') {
      throwError('[BTooltip]', 'You need to pass a v-model to b-tooltip when `manual` is true');
    }

    var popper = vue.ref(null);

    var onUpdateVisible = function onUpdateVisible(val) {
      ctx.emit(UPDATE_MODEL_EVENT, val);
    };

    var updatePopper = function updatePopper() {
      return popper.value.update();
    };

    return {
      popper: popper,
      onUpdateVisible: onUpdateVisible,
      updatePopper: updatePopper
    };
  },
  render: function render() {
    var _this = this;

    var $slots = this.$slots,
        content = this.content,
        manual = this.manual,
        openDelay = this.openDelay,
        onUpdateVisible = this.onUpdateVisible,
        showAfter = this.showAfter,
        visibleArrow = this.visibleArrow,
        modelValue = this.modelValue,
        tabindex = this.tabindex;

    var throwErrorTip = function throwErrorTip() {
      throwError('[BTooltip]', 'you need to provide a valid default slot.');
    };

    return vue.h(script$1F, _extends$2({}, Object.keys(defaultProps$2).reduce(function (result, key) {
      var _extends2;

      return _extends$2({}, result, (_extends2 = {}, _extends2[key] = _this[key], _extends2));
    }, {}), {
      ref: 'popper',
      manualMode: manual,
      showAfter: openDelay || showAfter,
      // this is for mapping API due to we decided to rename the current openDelay API to showAfter for better readability,
      showArrow: visibleArrow,
      visible: modelValue,
      'onUpdate:visible': onUpdateVisible
    }), {
      default: function _default() {
        return $slots.content ? $slots.content() : content;
      },
      trigger: function trigger() {
        if ($slots.default) {
          var firstVnode = getFirstValidNode($slots.default(), 1);
          if (!firstVnode) throwErrorTip();
          return vue.cloneVNode(firstVnode, {
            tabindex: tabindex
          }, true);
        }

        throwErrorTip();
      }
    });
  }
};

Tooltip.install = function (app) {
  app.component(Tooltip.name, Tooltip);
};

var SubMenu = /*#__PURE__*/function () {
  function SubMenu(parent, domNode) {
    this.subIndex = 0;
    this.parent = parent;
    this.domNode = domNode;
    this.subMenuItems = [];
    this.init();
  }

  var _proto = SubMenu.prototype;

  _proto.init = function init() {
    this.subMenuItems = this.domNode.querySelectorAll('li');
    this.addListeners();
  };

  _proto.gotoSubIndex = function gotoSubIndex(idx) {
    if (idx === this.subMenuItems.length) {
      idx = 0;
    } else if (idx < 0) {
      idx = this.subMenuItems.length - 1;
    }

    this.subMenuItems[idx].focus();
    this.subIndex = idx;
  };

  _proto.addListeners = function addListeners() {
    var _this = this;

    var parentNode = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, function (el) {
      el.addEventListener('keydown', function (event) {
        var prevDef = false;

        switch (event.code) {
          case EVENT_CODE.down:
            {
              _this.gotoSubIndex(_this.subIndex + 1);

              prevDef = true;
              break;
            }

          case EVENT_CODE.up:
            {
              _this.gotoSubIndex(_this.subIndex - 1);

              prevDef = true;
              break;
            }

          case EVENT_CODE.tab:
            {
              triggerEvent(parentNode, 'mouseleave');
              break;
            }

          case EVENT_CODE.enter:
          case EVENT_CODE.space:
            {
              prevDef = true;
              event.currentTarget.click();
              break;
            }
        }

        if (prevDef) {
          event.preventDefault();
          event.stopPropagation();
        }

        return false;
      });
    });
  };

  return SubMenu;
}();

var MenuItem = /*#__PURE__*/function () {
  function MenuItem(domNode) {
    this.domNode = domNode;
    this.submenu = null;
    this.init();
  }

  var _proto = MenuItem.prototype;

  _proto.init = function init() {
    this.domNode.setAttribute('tabindex', '0');
    var menuChild = this.domNode.querySelector('.bin-menu');

    if (menuChild) {
      this.submenu = new SubMenu(this, menuChild);
    }

    this.addListeners();
  };

  _proto.addListeners = function addListeners() {
    var _this = this;

    this.domNode.addEventListener('keydown', function (event) {
      var prevDef = false;

      switch (event.code) {
        case EVENT_CODE.down:
          {
            triggerEvent(event.currentTarget, 'mouseenter');
            _this.submenu && _this.submenu.gotoSubIndex(0);
            prevDef = true;
            break;
          }

        case EVENT_CODE.up:
          {
            triggerEvent(event.currentTarget, 'mouseenter');
            _this.submenu && _this.submenu.gotoSubIndex(_this.submenu.subMenuItems.length - 1);
            prevDef = true;
            break;
          }

        case EVENT_CODE.tab:
          {
            triggerEvent(event.currentTarget, 'mouseleave');
            break;
          }

        case EVENT_CODE.enter:
        case EVENT_CODE.space:
          {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
      }

      if (prevDef) {
        event.preventDefault();
      }
    });
  };

  return MenuItem;
}();

var Menu = /*#__PURE__*/function () {
  function Menu(domNode) {
    this.domNode = domNode;
    this.init();
  }

  var _proto = Menu.prototype;

  _proto.init = function init() {
    var menuChildren = this.domNode.childNodes;
    [].filter.call(menuChildren, function (child) {
      return child.nodeType === 1;
    }).forEach(function (child) {
      new MenuItem(child);
    });
  };

  return Menu;
}();

var script$1r = {
  name: 'BMenuCollapseTransition',
  setup: function setup() {
    return {
      on: {
        beforeEnter: function beforeEnter(el) {
          el.style.opacity = 0.2;
        },
        enter: function enter(el) {
          addClass(el, 'bin-opacity-transition');
          el.style.opacity = 1;
        },
        afterEnter: function afterEnter(el) {
          removeClass(el, 'bin-opacity-transition');
          el.style.opacity = '';
        },
        beforeLeave: function beforeLeave(el) {
          if (!el.dataset) el.dataset = {};

          if (hasClass(el, 'bin-menu--collapse')) {
            removeClass(el, 'bin-menu--collapse');
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth;
            addClass(el, 'bin-menu--collapse');
          } else {
            addClass(el, 'bin-menu--collapse');
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth;
            removeClass(el, 'bin-menu--collapse');
          }

          el.style.width = el.scrollWidth + 'px';
          el.style.overflow = 'hidden';
        },
        leave: function leave(el) {
          addClass(el, 'horizontal-collapse-transition');
          el.style.width = el.dataset.scrollWidth + 'px';
        }
      }
    };
  }
};

function render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, vue.mergeProps({
    mode: "out-in"
  }, vue.toHandlers($setup.on)), {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
    /* FORWARDED */

  }, 16
  /* FULL_PROPS */
  );
}

script$1r.render = render$1o;
script$1r.__file = "src/components/menu/menu-collapse-transition.vue";

function useMenuColor(color) {
  if (color === void 0) {
    color = '';
  }

  var menuBarColor = vue.ref('');

  function calcColorChannels(c) {
    var rawColor = c.replace('#', '');

    if (/^[0-9a-fA-F]{3}$/.test(rawColor)) {
      var _color = rawColor.split('');

      for (var i = 2; i >= 0; i--) {
        _color.splice(i, 0, _color[i]);
      }

      rawColor = _color.join('');
    }

    if (/^[0-9a-fA-F]{6}$/.test(rawColor)) {
      return {
        red: parseInt(rawColor.slice(0, 2), 16),
        green: parseInt(rawColor.slice(2, 4), 16),
        blue: parseInt(rawColor.slice(4, 6), 16)
      };
    } else {
      return {
        red: 255,
        green: 255,
        blue: 255
      };
    }
  }

  function mixColor(color, percent) {
    if (percent === void 0) {
      percent = 0.2;
    }

    var _calcColorChannels = calcColorChannels(color),
        red = _calcColorChannels.red,
        green = _calcColorChannels.green,
        blue = _calcColorChannels.blue;

    if (percent > 0) {
      // shade given color
      red *= 1 - percent;
      green *= 1 - percent;
      blue *= 1 - percent;
    } else {
      // tint given color
      red += (255 - red) * percent;
      green += (255 - green) * percent;
      blue += (255 - blue) * percent;
    }

    return "rgb(" + Math.round(red) + ", " + Math.round(green) + ", " + Math.round(blue) + ")";
  }

  if (!color) {
    return menuBarColor;
  }

  menuBarColor.value = mixColor(color);
  return menuBarColor;
}

var script$1q = {
  name: 'BMenu',
  componentName: 'BMenu',
  components: {
    BMenuCollapseTransition: script$1r
  },
  props: {
    mode: {
      type: String,
      default: 'vertical'
    },
    defaultActive: {
      type: String,
      default: ''
    },
    defaultOpeneds: Array,
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      default: 'hover'
    },
    collapse: Boolean,
    backgroundColor: {
      type: String
    },
    textColor: {
      type: String
    },
    activeTextColor: {
      type: String
    },
    collapseTransition: {
      type: Boolean,
      default: true
    }
  },
  emits: ['close', 'open', 'select'],
  setup: function setup(props, ctx) {
    // data
    var openedMenus = vue.ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
    var instance = vue.getCurrentInstance();
    var activeIndex = vue.ref(props.defaultActive);
    var items = vue.ref({});
    var submenus = vue.ref({});
    var alteredCollapse = vue.ref(false);
    var rootMenuEmitter = mitt();
    var router = instance.appContext.config.globalProperties.$router;
    var hoverBackground = useMenuColor(props.backgroundColor); // computed

    var isMenuPopup = vue.computed(function () {
      return props.mode === 'horizontal' || props.mode === 'vertical' && props.collapse;
    }); // methods

    var initializeMenu = function initializeMenu() {
      var index = activeIndex.value;
      var activeItem = items.value[index];
      if (!activeItem || props.mode === 'horizontal' || props.collapse) return;
      var indexPath = activeItem.indexPath; // 展开该菜单项的路径上所有子菜单
      // expand all submenus of the menu item

      indexPath.forEach(function (index) {
        var submenu = submenus.value[index];
        submenu && openMenu(index, submenu == null ? void 0 : submenu.indexPath);
      });
    };

    var addSubMenu = function addSubMenu(item) {
      submenus.value[item.index] = item;
    };

    var removeSubMenu = function removeSubMenu(item) {
      delete submenus.value[item.index];
    };

    var addMenuItem = function addMenuItem(item) {
      items.value[item.index] = item;
    };

    var removeMenuItem = function removeMenuItem(item) {
      delete items.value[item.index];
    };

    var openMenu = function openMenu(index, indexPath) {
      if (openedMenus.value.includes(index)) return; // 将不在该菜单路径下的其余菜单收起
      // collapse all menu that are not under current menu item

      if (props.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter(function (index) {
          return (vue.isRef(indexPath) ? indexPath.value : indexPath).indexOf(index) !== -1;
        });
      }

      openedMenus.value.push(index);
    };

    var closeMenu = function closeMenu(index) {
      var i = openedMenus.value.indexOf(index);

      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
    };

    var open = function open(index) {
      var indexPath = submenus.value[index.toString()].indexPath;
      indexPath.forEach(function (i) {
        return openMenu(i, indexPath);
      });
    };

    var close = function close(index) {
      closeMenu(index);
    };

    var handleSubmenuClick = function handleSubmenuClick(submenu) {
      var index = submenu.index,
          indexPath = submenu.indexPath;
      var isOpened = openedMenus.value.includes(index);

      if (isOpened) {
        closeMenu(index);
        ctx.emit('close', index, indexPath.value);
      } else {
        openMenu(index, indexPath);
        ctx.emit('open', index, indexPath.value);
      }
    };

    var handleItemClick = function handleItemClick(item) {
      var index = item.index,
          indexPath = item.indexPath;
      var hasIndex = item.index !== null;
      var oldActiveIndex = activeIndex.value;

      if (hasIndex) {
        activeIndex.value = item.index;
      }

      ctx.emit('select', index, indexPath.value, item);

      if (props.mode === 'horizontal' || props.collapse) {
        openedMenus.value = [];
      }

      if (props.router && router && hasIndex) {
        routeToItem(item, function (error) {
          activeIndex.value = oldActiveIndex;

          if (error) {
            // vue-router 3.1.0+ push/replace cause NavigationDuplicated error
            // https://github.com/ElemeFE/element/issues/17044
            if (error.name === 'NavigationDuplicated') return;
            console.error(error);
          }
        });
      }
    };

    var routeToItem = function routeToItem(item, onError) {
      var route = item.route || item.index;

      try {
        router == null ? void 0 : router.push(route, function () {
          return null;
        }, onError);
      } catch (e) {
        console.error(e);
      }
    };

    var updateActiveIndex = function updateActiveIndex(val) {
      var itemsInData = items.value;
      var item = itemsInData[val] || itemsInData[activeIndex.value] || itemsInData[props.defaultActive];

      if (item) {
        activeIndex.value = item.index;
        initializeMenu();
      } else {
        // Can't find item when collapsing
        // and activeIndex shouldn't be changed when 'collapse' was changed.
        // Then reset 'alteredCollapse' immediately.
        if (!alteredCollapse.value) {
          activeIndex.value = null;
        } else {
          alteredCollapse.value = false;
        }
      }
    }; // watch


    vue.watch(function () {
      return props.defaultActive;
    }, function (currentActive) {
      if (!items[currentActive]) {
        activeIndex.value = '';
      }

      updateActiveIndex(currentActive);
    });
    vue.watch(items.value, function () {
      updateActiveIndex();
    });
    vue.watch(function () {
      return props.collapse;
    }, function (value, prev) {
      if (value !== prev) {
        alteredCollapse.value = true;
      }

      if (value) openedMenus.value = [];
      rootMenuEmitter.emit('rootMenu:toggle-collapse', Boolean(props.collapse));
    }); // provide

    vue.provide('rootMenu', {
      props: props,
      openedMenus: openedMenus,
      items: items,
      submenus: submenus,
      hoverBackground: hoverBackground,
      activeIndex: activeIndex,
      isMenuPopup: isMenuPopup,
      methods: {
        addMenuItem: addMenuItem,
        removeMenuItem: removeMenuItem,
        addSubMenu: addSubMenu,
        removeSubMenu: removeSubMenu,
        openMenu: openMenu,
        closeMenu: closeMenu
      },
      rootMenuEmit: rootMenuEmitter.emit,
      rootMenuOn: rootMenuEmitter.on
    });
    vue.provide("subMenu:" + instance.uid, {
      addSubMenu: addSubMenu,
      removeSubMenu: removeSubMenu
    }); // lifecycle

    vue.onMounted(function () {
      initializeMenu();
      rootMenuEmitter.on('menuItem:item-click', handleItemClick);
      rootMenuEmitter.on('submenu:submenu-click', handleSubmenuClick);

      if (props.mode === 'horizontal') {
        new Menu(instance.vnode.el);
      }
    });
    return {
      hoverBackground: hoverBackground,
      isMenuPopup: isMenuPopup,
      props: props,
      open: open,
      close: close
    };
  }
};

function render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_menu_collapse_transition = vue.resolveComponent("b-menu-collapse-transition");

  return $setup.props.collapseTransition ? (vue.openBlock(), vue.createBlock(_component_b_menu_collapse_transition, {
    key: 0
  }, {
    default: vue.withCtx(function () {
      return [(vue.openBlock(), vue.createBlock("ul", {
        key: +$setup.props.collapse,
        role: "menubar",
        style: {
          backgroundColor: $setup.props.backgroundColor || ''
        },
        class: {
          'bin-menu': true,
          'bin-menu--horizontal': $props.mode === 'horizontal',
          'bin-menu--collapse': $setup.props.collapse
        }
      }, [vue.renderSlot(_ctx.$slots, "default")], 6
      /* CLASS, STYLE */
      ))];
    }),
    _: 3
    /* FORWARDED */

  })) : (vue.openBlock(), vue.createBlock("ul", {
    key: +$setup.props.collapse,
    role: "menubar",
    style: {
      backgroundColor: $setup.props.backgroundColor || ''
    },
    class: {
      'bin-menu': true,
      'bin-menu--horizontal': $props.mode === 'horizontal',
      'bin-menu--collapse': $setup.props.collapse
    }
  }, [vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  ));
}

script$1q.render = render$1n;
script$1q.__file = "src/components/menu/menu.vue";

script$1q.install = function (app) {
  app.component(script$1q.name, script$1q);
};

function useMenu(instance, currentIndex) {
  var rootMenu = vue.inject('rootMenu');
  var indexPath = vue.computed(function () {
    var parent = instance.parent;
    var path = [currentIndex];

    while (parent.type.name !== 'BMenu') {
      if (parent.props.index) {
        path.unshift(parent.props.index);
      }

      parent = parent.parent;
    }

    return path;
  });
  var parentMenu = vue.computed(function () {
    var parent = instance.parent;

    while (parent && ['BMenu', 'BSubmenu'].indexOf(parent.type.name) === -1) {
      parent = parent.parent;
    }

    return parent;
  });
  var paddingStyle = vue.computed(function () {
    var parent = instance.parent;
    if (rootMenu.props.mode !== 'vertical') return {};
    var padding = 20;

    if (rootMenu.props.collapse) {
      padding = 20;
    } else {
      while (parent && parent.type.name !== 'BMenu') {
        if (parent.type.name === 'BSubmenu') {
          padding += 20;
        }

        parent = parent.parent;
      }
    }

    return {
      paddingLeft: padding + 'px'
    };
  });
  return {
    parentMenu: parentMenu,
    paddingStyle: paddingStyle,
    indexPath: indexPath
  };
}

var script$1p = {
  name: 'BMenuItem',
  componentName: 'BMenuItem',
  components: {
    BTooltip: Tooltip
  },
  props: {
    index: {
      default: null,
      validator: function validator(val) {
        return typeof val === 'string' || val === null;
      }
    },
    route: [String, Object],
    disabled: Boolean
  },
  emits: ['click'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var instance = vue.getCurrentInstance();
    var rootMenu = vue.inject('rootMenu');

    var _useMenu = useMenu(instance, props.index),
        parentMenu = _useMenu.parentMenu,
        paddingStyle = _useMenu.paddingStyle,
        indexPath = _useMenu.indexPath;

    var _inject = vue.inject("subMenu:" + parentMenu.value.uid),
        addSubMenu = _inject.addSubMenu,
        removeSubMenu = _inject.removeSubMenu;

    var active = vue.computed(function () {
      return props.index === rootMenu.activeIndex.value;
    });
    var hoverBackground = vue.computed(function () {
      return rootMenu.hoverBackground.value;
    });
    var backgroundColor = vue.computed(function () {
      return rootMenu.props.backgroundColor || '';
    });
    var activeTextColor = vue.computed(function () {
      return rootMenu.props.activeTextColor || '';
    });
    var textColor = vue.computed(function () {
      return rootMenu.props.textColor || '';
    });
    var mode = vue.computed(function () {
      return rootMenu.props.mode;
    });
    var isNested = vue.computed(function () {
      return parentMenu.value.type.name !== 'ElMenu';
    });
    var itemStyle = vue.computed(function () {
      var style = {
        color: active.value ? activeTextColor.value : textColor.value,
        borderBottomColor: active.value ? activeTextColor.value : ''
      };

      if (mode.value === 'horizontal' && !isNested.value) {
        style.borderBottomColor = active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : '' : 'transparent';
      }

      return style;
    });

    var onMouseEnter = function onMouseEnter() {
      if (mode.value === 'horizontal' && !rootMenu.props.backgroundColor) return;
      instance.vnode.el.style.backgroundColor = hoverBackground.value;
    };

    var onMouseLeave = function onMouseLeave() {
      if (mode.value === 'horizontal' && !rootMenu.props.backgroundColor) return;
      instance.vnode.el.style.backgroundColor = backgroundColor.value;
    };

    var handleClick = function handleClick() {
      if (!props.disabled) {
        rootMenu.rootMenuEmit('menuItem:item-click', {
          index: props.index,
          indexPath: indexPath,
          route: props.route
        });
        emit('click', {
          index: props.index,
          indexPath: indexPath.value
        });
      }
    };

    vue.onMounted(function () {
      addSubMenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
      rootMenu.methods.addMenuItem({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
    });
    vue.onBeforeUnmount(function () {
      removeSubMenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
      rootMenu.methods.removeMenuItem({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
    });
    return {
      parentMenu: parentMenu,
      rootMenu: rootMenu,
      slots: slots,
      paddingStyle: paddingStyle,
      itemStyle: itemStyle,
      backgroundColor: backgroundColor,
      active: active,
      handleClick: handleClick,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave
    };
  }
};

var _hoisted_1$V = {
  style: {
    "position": "absolute",
    "left": "0",
    "top": "0",
    "height": "100%",
    "width": "100%",
    "display": "inline-block",
    "box-sizing": "border-box",
    "padding": "0 20px"
  }
};
function render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_tooltip = vue.resolveComponent("b-tooltip");

  return vue.openBlock(), vue.createBlock("li", {
    class: ["bin-menu-item", {
      'is-active': $setup.active,
      'is-disabled': $props.disabled,
      'is-tooltip': $setup.parentMenu.type.name === 'BMenu' && $setup.rootMenu.props.collapse && $setup.slots.title
    }],
    role: "menuitem",
    tabindex: "-1",
    style: [$setup.paddingStyle, $setup.itemStyle, {
      backgroundColor: $setup.backgroundColor
    }],
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    }),
    onMouseenter: _cache[2] || (_cache[2] = function () {
      return $setup.onMouseEnter && $setup.onMouseEnter.apply($setup, arguments);
    }),
    onFocus: _cache[3] || (_cache[3] = function () {
      return $setup.onMouseEnter && $setup.onMouseEnter.apply($setup, arguments);
    }),
    onBlur: _cache[4] || (_cache[4] = function () {
      return $setup.onMouseLeave && $setup.onMouseLeave.apply($setup, arguments);
    }),
    onMouseleave: _cache[5] || (_cache[5] = function () {
      return $setup.onMouseLeave && $setup.onMouseLeave.apply($setup, arguments);
    })
  }, [$setup.parentMenu.type.name === 'BMenu' && $setup.rootMenu.props.collapse && $setup.slots.title ? (vue.openBlock(), vue.createBlock(_component_b_tooltip, {
    key: 0,
    theme: "dark",
    placement: "right"
  }, {
    content: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "title")];
    }),
    default: vue.withCtx(function () {
      return [vue.createVNode("div", _hoisted_1$V, [vue.renderSlot(_ctx.$slots, "default")])];
    }),
    _: 3
    /* FORWARDED */

  })) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 1
  }, [vue.renderSlot(_ctx.$slots, "default"), vue.renderSlot(_ctx.$slots, "title")], 64
  /* STABLE_FRAGMENT */
  ))], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  );
}

script$1p.render = render$1m;
script$1p.__file = "src/components/menu/menu-item.vue";

script$1p.install = function (app) {
  app.component(script$1p.name, script$1p);
};

var script$1o = {
  name: 'BSubmenu',
  componentName: 'BSubmenu',
  props: {
    index: {
      type: String,
      required: true
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: undefined
    }
  },
  setup: function setup(props) {
    var data = vue.reactive({
      popperJS: null,
      timeout: null,
      items: {},
      submenus: {},
      currentPlacement: '',
      mouseInChild: false,
      opened: false
    });
    var verticalTitleRef = vue.ref(null);
    var popperVnode = vue.ref(null); // instance

    var instance = vue.getCurrentInstance();

    var _useMenu = useMenu(instance, props.index),
        paddingStyle = _useMenu.paddingStyle,
        indexPath = _useMenu.indexPath,
        parentMenu = _useMenu.parentMenu; // inject


    var _inject = vue.inject('rootMenu'),
        openedMenus = _inject.openedMenus,
        isMenuPopup = _inject.isMenuPopup,
        rootHoverBackground = _inject.hoverBackground,
        rootMethods = _inject.methods,
        rootProps = _inject.props,
        closeMenu = _inject.methods.closeMenu,
        rootMenuOn = _inject.rootMenuOn,
        rootMenuEmit = _inject.rootMenuEmit;

    var _inject2 = vue.inject("subMenu:" + parentMenu.value.uid),
        parentAddSubmenu = _inject2.addSubMenu,
        parentRemoveSubmenu = _inject2.removeSubMenu,
        parentHandleMouseleave = _inject2.handleMouseleave; // computed


    var submenuTitleIcon = vue.computed(function () {
      return mode.value === 'horizontal' && isFirstLevel.value || mode.value === 'vertical' && !rootProps.collapse ? 'b-icon-down' : 'b-icon-right';
    });
    var isFirstLevel = vue.computed(function () {
      var isFirstLevel = true;
      var parent = instance.parent;

      while (parent && parent.type.name !== 'BMenu') {
        if (['BSubmenu', 'BMenuItemGroup'].includes(parent.type.name)) {
          isFirstLevel = false;
          break;
        } else {
          parent = parent.parent;
        }
      }

      return isFirstLevel;
    });
    var appendToBody = vue.computed(function () {
      return props.popperAppendToBody === undefined ? isFirstLevel.value : Boolean(props.popperAppendToBody);
    });
    var menuTransitionName = vue.computed(function () {
      return rootProps.collapse ? 'zoom-in-left' : 'zoom-in-top';
    });
    var opened = vue.computed(function () {
      return openedMenus.value.includes(props.index);
    });
    var active = vue.computed(function () {
      var isActive = false;
      var submenus = data.submenus;
      var items = data.items;
      Object.keys(items).forEach(function (index) {
        if (items[index].active) {
          isActive = true;
        }
      });
      Object.keys(submenus).forEach(function (index) {
        if (submenus[index].active) {
          isActive = true;
        }
      });
      return isActive;
    });
    var backgroundColor = vue.computed(function () {
      return rootProps.backgroundColor || '';
    });
    var activeTextColor = vue.computed(function () {
      return rootProps.activeTextColor || '';
    });
    var textColor = vue.computed(function () {
      return rootProps.textColor || '';
    });
    var mode = vue.computed(function () {
      return rootProps.mode;
    });
    var titleStyle = vue.computed(function () {
      if (mode.value !== 'horizontal') {
        return {
          color: textColor.value
        };
      }

      return {
        borderBottomColor: active.value ? rootProps.activeTextColor ? activeTextColor.value : '' : 'transparent',
        color: active.value ? activeTextColor.value : textColor.value
      };
    }); // emitter

    var subMenuEmitter = mitt();

    var doDestroy = function doDestroy() {
      var _popperVnode$value;

      (_popperVnode$value = popperVnode.value) == null ? void 0 : _popperVnode$value.doDestroy();
    }; // methods


    var handleCollapseToggle = function handleCollapseToggle(value) {
      if (value) {
        updatePlacement();
      } else {
        doDestroy();
      }
    };

    var addItem = function addItem(item) {
      data.items[item.index] = item;
    };

    var removeItem = function removeItem(item) {
      delete data.items[item.index];
    };

    var addSubMenu = function addSubMenu(item) {
      data.submenus[item.index] = item;
    };

    var removeSubMenu = function removeSubMenu(item) {
      delete data.submenus[item.index];
    };

    var handleClick = function handleClick() {
      var disabled = props.disabled;

      if (rootProps.menuTrigger === 'hover' && rootProps.mode === 'horizontal' || rootProps.collapse && rootProps.mode === 'vertical' || disabled) {
        return;
      }

      rootMenuEmit('submenu:submenu-click', {
        index: props.index,
        indexPath: indexPath
      });
    };

    var handleMouseenter = function handleMouseenter(event, showTimeout) {
      if (showTimeout === void 0) {
        showTimeout = props.showTimeout;
      }

      if (!('ActiveXObject' in window) && event.type === 'focus' && !event.relatedTarget) {
        return;
      }

      var disabled = props.disabled;

      if (rootProps.menuTrigger === 'click' && rootProps.mode === 'horizontal' || !rootProps.collapse && rootProps.mode === 'vertical' || disabled) {
        return;
      }

      subMenuEmitter.emit('submenu:mouse-enter-child');
      clearTimeout(data.timeout);
      data.timeout = setTimeout(function () {
        rootMethods.openMenu(props.index, indexPath);
      }, showTimeout);

      if (appendToBody.value) {
        parentMenu.value.vnode.el.dispatchEvent(new MouseEvent('mouseenter'));
      }
    };

    var handleMouseleave = function handleMouseleave(deepDispatch) {
      if (deepDispatch === void 0) {
        deepDispatch = false;
      }

      if (rootProps.menuTrigger === 'click' && rootProps.mode === 'horizontal' || !rootProps.collapse && rootProps.mode === 'vertical') {
        return;
      }

      subMenuEmitter.emit('submenu:mouse-leave-child');
      clearTimeout(data.timeout);
      data.timeout = setTimeout(function () {
        !data.mouseInChild && closeMenu(props.index);
      }, props.hideTimeout);

      if (appendToBody.value && deepDispatch) {
        if (instance.parent.type.name === 'BSubmenu') {
          parentHandleMouseleave(true);
        }
      }
    };

    var handleTitleMouseenter = function handleTitleMouseenter() {
      var _popperVnode$value2;

      if (mode.value === 'horizontal' && !rootProps.backgroundColor) return;
      var title = ((_popperVnode$value2 = popperVnode.value) == null ? void 0 : _popperVnode$value2.triggerRef) || verticalTitleRef.value;
      title && (title.style.backgroundColor = rootHoverBackground.value);
    };

    var handleTitleMouseleave = function handleTitleMouseleave() {
      var _popperVnode$value3;

      if (mode.value === 'horizontal' && !rootProps.backgroundColor) return;
      var title = ((_popperVnode$value3 = popperVnode.value) == null ? void 0 : _popperVnode$value3.triggerRef) || verticalTitleRef.value;
      title && (title.style.backgroundColor = rootProps.backgroundColor || '');
    };

    var updatePlacement = function updatePlacement() {
      data.currentPlacement = mode.value === 'horizontal' && isFirstLevel.value ? 'bottom-start' : 'right-start';
    }; // provide


    vue.provide("subMenu:" + instance.uid, {
      addSubMenu: addSubMenu,
      removeSubMenu: removeSubMenu,
      handleMouseleave: handleMouseleave
    }); // lifecycle

    vue.onBeforeMount(function () {
      rootMenuOn('rootMenu:toggle-collapse', function (val) {
        handleCollapseToggle(val);
      });
      subMenuEmitter.on('submenu:mouse-enter-child', function () {
        data.mouseInChild = true;
        clearTimeout(data.timeout);
      });
      subMenuEmitter.on('submenu:mouse-leave-child', function () {
        data.mouseInChild = false;
        clearTimeout(data.timeout);
      });
    });
    vue.onMounted(function () {
      rootMethods.addSubMenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
      parentAddSubmenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
      updatePlacement();
    });
    vue.onBeforeUnmount(function () {
      parentRemoveSubmenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
      rootMethods.removeSubMenu({
        index: props.index,
        indexPath: indexPath,
        active: active
      });
    });
    return {
      data: data,
      props: props,
      mode: mode,
      active: active,
      isMenuPopup: isMenuPopup,
      opened: opened,
      paddingStyle: paddingStyle,
      titleStyle: titleStyle,
      backgroundColor: backgroundColor,
      rootProps: rootProps,
      menuTransitionName: menuTransitionName,
      submenuTitleIcon: submenuTitleIcon,
      appendToBody: appendToBody,
      handleClick: handleClick,
      handleMouseenter: handleMouseenter,
      handleMouseleave: handleMouseleave,
      handleTitleMouseenter: handleTitleMouseenter,
      handleTitleMouseleave: handleTitleMouseleave,
      addItem: addItem,
      removeItem: removeItem,
      addSubMenu: addSubMenu,
      removeSubMenu: removeSubMenu,
      popperVnode: popperVnode,
      verticalTitleRef: verticalTitleRef
    };
  },
  render: function render() {
    var _this$$slots$title,
        _this$$slots,
        _this = this;

    var titleTag = [(_this$$slots$title = (_this$$slots = this.$slots).title) == null ? void 0 : _this$$slots$title.call(_this$$slots), vue.h('i', {
      class: ['bin-submenu__icon-arrow', 'b-iconfont', this.submenuTitleIcon]
    }, null)];
    var ulStyle = {
      backgroundColor: this.rootProps.backgroundColor || ''
    };
    var child = this.isMenuPopup ? vue.h(script$1F, {
      ref: 'popperVNode',
      manualMode: true,
      visible: this.opened,
      'onUpdate:visible': function onUpdateVisible(val) {
        return _this.opened = val;
      },
      theme: 'light',
      pure: true,
      offset: 6,
      boundariesPadding: 0,
      showArrow: false,
      popperClass: 'bin-submenu-popper',
      placement: this.data.currentPlacement,
      appendToBody: this.appendToBody
    }, {
      default: function _default() {
        return vue.h(vue.Transition, {
          name: _this.menuTransitionName
        }, {
          default: function _default() {
            return vue.withDirectives(vue.h('div', {
              ref: 'menu',
              class: ["bin-menu--" + _this.mode, 'bin-submenu-popper'],
              onMouseenter: function onMouseenter($event) {
                return _this.handleMouseenter($event, 100);
              },
              onMouseleave: function onMouseleave() {
                return _this.handleMouseleave(true);
              },
              onFocus: function onFocus($event) {
                return _this.handleMouseenter($event, 100);
              }
            }, [vue.h('ul', {
              class: ['bin-menu bin-menu--popup', "bin-menu--popup-" + _this.data.currentPlacement],
              style: ulStyle
            }, [_this.$slots.default == null ? void 0 : _this.$slots.default()])]), [[vue.vShow, _this.opened]]);
          }
        });
      },
      trigger: function trigger() {
        return vue.h('div', {
          class: 'bin-submenu__title',
          style: [_this.paddingStyle, _this.titleStyle, {
            backgroundColor: _this.backgroundColor
          }],
          onClick: _this.handleClick,
          onMouseenter: _this.handleTitleMouseenter,
          onMouseleave: _this.handleTitleMouseleave
        }, titleTag);
      }
    }) : vue.h(vue.Fragment, {}, [vue.h('div', {
      class: 'bin-submenu__title',
      style: [this.paddingStyle, this.titleStyle, {
        backgroundColor: this.backgroundColor
      }],
      ref: 'verticalTitleRef',
      onClick: this.handleClick,
      onMouseenter: this.handleTitleMouseenter,
      onMouseleave: this.handleTitleMouseleave
    }, titleTag), vue.h(script$1u, {}, {
      default: function _default() {
        return vue.withDirectives(vue.h('ul', {
          role: 'menu',
          class: 'bin-menu bin-menu--inline',
          style: ulStyle
        }, [_this.$slots.default == null ? void 0 : _this.$slots.default()]), [[vue.vShow, _this.opened]]);
      }
    })]);
    return vue.h('li', {
      class: ['bin-submenu', {
        'is-active': this.active,
        'is-opened': this.opened,
        'is-disabled': this.disabled
      }],
      role: 'menuitem',
      ariaHaspopup: true,
      ariaExpanded: this.opened,
      onMouseenter: this.handleMouseenter,
      onMouseleave: function onMouseleave() {
        return _this.handleMouseleave(true);
      },
      onFocus: this.handleMouseenter
    }, [child]);
  }
};

script$1o.__file = "src/components/menu/submenu.vue";

script$1o.install = function (app) {
  app.component(script$1o.name, script$1o);
};

var script$1n = {
  name: 'BMenuItemGroup',
  componentName: 'BMenuItemGroup',
  props: {
    title: {
      type: String
    }
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots;
    // data
    var data = vue.reactive({
      paddingLeft: 20
    });
    var instance = vue.getCurrentInstance(); // computed

    var levelPadding = vue.computed(function () {
      var padding = 20;
      var parent = instance.parent;
      if (rootProps.collapse) return 20;

      while (parent && parent.type.name !== 'BMenu') {
        if (parent.type.name === 'BSubmenu') {
          padding += 20;
        }

        parent = parent.parent;
      }

      return padding;
    }); // inject

    var _inject = vue.inject('rootMenu'),
        rootProps = _inject.props;

    return {
      data: data,
      levelPadding: levelPadding,
      props: props,
      slots: slots
    };
  }
};

var _hoisted_1$U = {
  class: "bin-menu-item-group"
};
function render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("li", _hoisted_1$U, [vue.createVNode("div", {
    class: "bin-menu-item-group__title",
    style: {
      paddingLeft: $setup.levelPadding + 'px'
    }
  }, [!$setup.slots.title ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.title), 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : vue.renderSlot(_ctx.$slots, "title", {
    key: 1
  })], 4
  /* STYLE */
  ), vue.createVNode("ul", null, [vue.renderSlot(_ctx.$slots, "default")])]);
}

script$1n.render = render$1l;
script$1n.__file = "src/components/menu/menu-item-group.vue";

script$1n.install = function (app) {
  app.component(script$1n.name, script$1n);
};

var script$1m = {
  name: 'BAffix',
  props: {
    zIndex: {
      type: Number,
      default: 10
    },
    target: {
      type: String,
      default: ''
    },
    offset: {
      type: Number,
      default: 0
    },
    position: {
      type: String,
      default: 'top'
    }
  },
  emits: ['scroll', 'change'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var target = vue.ref(null);
    var root = vue.ref(null);
    var scrollContainer = vue.ref(null);
    var state = vue.reactive({
      fixed: false,
      height: 0,
      // height of root
      width: 0,
      // width of root
      scrollTop: 0,
      // scrollTop of documentElement
      clientHeight: 0,
      // clientHeight of documentElement
      transform: 0
    });
    var rootStyle = vue.computed(function () {
      return {
        height: state.fixed ? state.height + "px" : '',
        width: state.fixed ? state.width + "px" : ''
      };
    });
    var affixStyle = vue.computed(function () {
      if (!state.fixed) {
        return;
      }

      var offset = props.offset ? props.offset + "px" : 0;
      var transform = state.transform ? "translateY(" + state.transform + "px)" : '';
      return {
        height: state.height + "px",
        width: state.width + "px",
        top: props.position === 'top' ? offset : '',
        bottom: props.position === 'bottom' ? offset : '',
        transform: transform,
        zIndex: props.zIndex
      };
    });

    var updateState = function updateState() {
      var rootRect = root.value.getBoundingClientRect();
      var targetRect = target.value.getBoundingClientRect();
      state.height = rootRect.height;
      state.width = rootRect.width;
      state.scrollTop = scrollContainer.value === window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;
      state.clientHeight = document.documentElement.clientHeight;

      if (props.position === 'top') {
        if (target.value) {
          var difference = targetRect.bottom - props.offset - state.height;
          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0;
          state.transform = difference < 0 ? difference : 0;
        } else {
          state.fixed = props.offset > rootRect.top;
        }
      } else {
        if (target.value) {
          var _difference = state.clientHeight - targetRect.top - props.offset - state.height;

          state.fixed = state.clientHeight - props.offset < rootRect.bottom && state.clientHeight > targetRect.top;
          state.transform = _difference < 0 ? -_difference : 0;
        } else {
          state.fixed = state.clientHeight - props.offset < rootRect.bottom;
        }
      }
    };

    var onScroll = function onScroll() {
      updateState();
      emit('scroll', {
        scrollTop: state.scrollTop,
        fixed: state.fixed
      });
    };

    vue.watch(function () {
      return state.fixed;
    }, function () {
      emit('change', state.fixed);
    });
    vue.onMounted(function () {
      if (props.target) {
        target.value = document.querySelector(props.target);

        if (!target.value) {
          throw new Error("target is not existed: " + props.target);
        }
      } else {
        target.value = document.documentElement;
      }

      scrollContainer.value = [window, document, document.documentElement].includes(target.value) ? window : target.value;
      on$1(scrollContainer.value, 'scroll', onScroll);
      addResizeListener(root.value, updateState);
    });
    vue.onBeforeUnmount(function () {
      off$1(scrollContainer.value, 'scroll', onScroll);
      removeResizeListener(root.value, updateState);
    });
    return {
      root: root,
      state: state,
      rootStyle: rootStyle,
      affixStyle: affixStyle
    };
  }
};

function render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    ref: "root",
    class: "bin-affix",
    style: $setup.rootStyle
  }, [vue.createVNode("div", {
    class: {
      'bin-affix--fixed': $setup.state.fixed
    },
    style: $setup.affixStyle
  }, [vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  )], 4
  /* STYLE */
  );
}

script$1m.render = render$1k;
script$1m.__file = "src/components/affix/affix.vue";

script$1m.install = function (app) {
  app.component(script$1m.name, script$1m);
};

var script$1l = {
  name: 'BBreadcrumb',
  props: {
    separator: {
      type: String,
      default: '/'
    },
    separatorIcon: {
      type: String,
      default: ''
    }
  },
  setup: function setup(props) {
    var el = vue.ref(null);
    vue.provide('Breadcrumb', {
      props: props
    });
    vue.onMounted(function () {
      var items = el.value.querySelectorAll('.bin-breadcrumb__item');

      if (items.length) {
        items[items.length - 1].setAttribute('aria-current', 'page');
      }
    });
    return {
      el: el
    };
  }
};

var _hoisted_1$T = {
  class: "bin-breadcrumb",
  "aria-label": "Breadcrumb",
  role: "navigation",
  ref: "el"
};
function render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$T, [vue.renderSlot(_ctx.$slots, "default")], 512
  /* NEED_PATCH */
  );
}

script$1l.render = render$1j;
script$1l.__file = "src/components/breadcrumb/breadcrumb.vue";

script$1l.install = function (app) {
  app.component(script$1l.name, script$1l);
};

var script$1k = {
  name: 'BBreadcrumbItem',
  setup: function setup() {
    var parent = vue.inject('Breadcrumb');
    var separator = vue.ref(parent.props.separator);
    var separatorIcon = vue.ref(parent.props.separatorIcon);
    var link = vue.ref(null);
    return {
      parent: parent,
      link: link,
      separator: separator,
      separatorIcon: separatorIcon
    };
  }
};

var _hoisted_1$S = {
  class: "bin-breadcrumb__item"
};
var _hoisted_2$C = {
  class: ['bin-breadcrumb__inner'],
  ref: "link",
  role: "link"
};
var _hoisted_3$q = {
  key: 1,
  class: "bin-separator",
  role: "presentation"
};
function render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("span", _hoisted_1$S, [vue.createVNode("span", _hoisted_2$C, [vue.renderSlot(_ctx.$slots, "default")], 512
  /* NEED_PATCH */
  ), $setup.separatorIcon ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: ["bin-separator icon", ['b-iconfont', 'b-icon-' + $setup.separatorIcon]]
  }, null, 2
  /* CLASS */
  )) : (vue.openBlock(), vue.createBlock("span", _hoisted_3$q, vue.toDisplayString($setup.separator), 1
  /* TEXT */
  ))]);
}

script$1k.render = render$1i;
script$1k.__file = "src/components/breadcrumb/breadcrumb-item.vue";

script$1k.install = function (app) {
  app.component(script$1k.name, script$1k);
};

var padding = 16; // tag's padding

var script$1j = {
  name: 'ScrollPane',
  props: {
    hideArrow: Boolean
  },
  setup: function setup() {
    var scrollContainerRef = vue.ref(null);
    var scrollWrapperRef = vue.ref(null);
    var data = vue.reactive({
      left: 0,
      isScrollable: false
    });

    var calcWidth = function calcWidth() {
      var $containerWidth = scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth;
      var $wrapperWidth = scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth;
      data.isScrollable = $wrapperWidth > $containerWidth - padding;

      if (!data.isScrollable) {
        data.left = 0;
      }
    };

    var moveStep = function moveStep(step, containerWidth, wrapperWidth) {
      if (step > 0) {
        data.left = Math.min(0, data.left + step);
      } else {
        if (containerWidth - padding < wrapperWidth) {
          if (data.left < -(wrapperWidth - containerWidth + padding)) ; else {
            data.left = Math.max(data.left + step, containerWidth - wrapperWidth - padding);
          }
        } else {
          data.left = 0;
        }
      }
    };

    var handleScroll = function handleScroll(e) {
      var eventDelta = e.wheelDelta * 0.5 || -e.deltaY * 3;
      var $containerWidth = scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth;
      var $wrapperWidth = scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth;
      moveStep(eventDelta, $containerWidth, $wrapperWidth);
    };

    var handlePrev = function handlePrev() {
      var $containerWidth = scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth;
      var $wrapperWidth = scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth; // 缓存容器宽度

      var moveWidth = $containerWidth - padding * 0.5;
      moveStep(moveWidth, $containerWidth, $wrapperWidth);
    };

    var handleNext = function handleNext() {
      var $containerWidth = scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth;
      var $wrapperWidth = scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth; // 缓存容器宽度

      var moveWidth = $containerWidth - padding * 0.5;
      moveStep(-moveWidth, $containerWidth, $wrapperWidth);
    };

    var moveToTarget = function moveToTarget($target) {
      var $containerWidth = scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth;
      var $wrapperWidth = scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth;
      var $targetLeft = $target.offsetLeft;
      var $targetWidth = $target.offsetWidth;
      data.isScrollable = $wrapperWidth > $containerWidth - padding;

      if ($targetLeft < -data.left) {
        // tag in the left
        data.left = -$targetLeft + padding;
      } else if ($targetLeft + padding > -data.left && $targetLeft + $targetWidth < -data.left + $containerWidth - padding) ; else {
        // tag in the right
        data.left = $containerWidth - $wrapperWidth - padding;
      }

      if (!data.isScrollable) {
        data.left = 0;
      }
    };

    var hidePrev = vue.computed(function () {
      return data.left === 0;
    });
    var hideNext = vue.computed(function () {
      return data.left === (scrollContainerRef == null ? void 0 : scrollContainerRef.value.offsetWidth) - (scrollWrapperRef == null ? void 0 : scrollWrapperRef.value.offsetWidth) - padding;
    });
    vue.onMounted(function () {
      calcWidth();
    });
    return _extends$2({
      scrollContainerRef: scrollContainerRef,
      scrollWrapperRef: scrollWrapperRef,
      hidePrev: hidePrev,
      hideNext: hideNext
    }, vue.toRefs(data), {
      calcWidth: calcWidth,
      handleScroll: handleScroll,
      handlePrev: handlePrev,
      handleNext: handleNext,
      moveToTarget: moveToTarget
    });
  }
};

var _hoisted_1$R = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
}, null, -1
/* HOISTED */
);

var _hoisted_2$B = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

function render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ["nav-wrap", {
      'is-scrollable': _ctx.isScrollable
    }]
  }, [!$props.hideArrow && _ctx.isScrollable ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createVNode("span", {
    class: ["nav-prev", {
      'disabled': $setup.hidePrev
    }],
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handlePrev && $setup.handlePrev.apply($setup, arguments);
    })
  }, [_hoisted_1$R], 2
  /* CLASS */
  ), vue.createVNode("span", {
    class: ["nav-next", {
      'disabled': $setup.hideNext
    }],
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.handleNext && $setup.handleNext.apply($setup, arguments);
    })
  }, [_hoisted_2$B], 2
  /* CLASS */
  )], 64
  /* STABLE_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    class: "scroll-container",
    ref: "scrollContainerRef",
    onWheel: _cache[3] || (_cache[3] = vue.withModifiers(function () {
      return $setup.handleScroll && $setup.handleScroll.apply($setup, arguments);
    }, ["prevent"]))
  }, [vue.createVNode("div", {
    class: "scroll-wrapper",
    ref: "scrollWrapperRef",
    style: {
      transform: "translateX(" + _ctx.left + "px)"
    }
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  )], 544
  /* HYDRATE_EVENTS, NEED_PATCH */
  )], 2
  /* CLASS */
  );
}

script$1j.render = render$1h;
script$1j.__file = "src/components/tabs/scroll-pane.vue";

var script$1i = {
  name: 'BTabs',
  components: {
    ScrollPane: script$1j
  },
  props: {
    modelValue: String,
    data: {
      type: Array,
      required: true
    },
    type: {
      validator: function validator(value) {
        return ['default', 'card', 'tag'].includes(value);
      },
      default: 'default'
    },
    closable: Boolean,
    contextMenu: Boolean
  },
  emits: ['update:modelValue', 'change', 'tab-close', 'tab-select'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var rootRef = vue.ref(null);
    var scrollPaneRef = vue.ref(null);
    var data = vue.reactive({
      visible: false,
      // 选中面板弹出
      top: 0,
      // 选中面板top
      left: 0,
      // 选中面板left
      selectedTag: {},
      // 选中的tag
      activeBarStyle: {}
    }); // 计算导航条样式属性

    var calcBar = function calcBar() {
      if (props.data.length === 0) return;
      var style = {
        width: '',
        transform: '',
        msTransform: '',
        webkitTransform: ''
      };
      var width = 0;
      var offset = 0; // 获取选中的el的宽度

      props.data.every(function (tab) {
        var $el = rootRef == null ? void 0 : rootRef.value.querySelector("#" + tab.key);
        if (!$el) return false;
        var isActive = $el.classList.contains('active');

        if (!isActive) {
          offset += $el['clientWidth'];
          return true;
        } else {
          width = $el['clientWidth'];
          return false;
        }
      });
      var transform = "translateX(" + offset + "px)";
      style.width = width + "px";
      style.transform = transform;
      style.msTransform = transform;
      style.webkitTransform = transform;
      data.activeBarStyle = style;
    }; // 计算滚动宽度


    var calcScrollWidth = function calcScrollWidth() {
      scrollPaneRef == null ? void 0 : scrollPaneRef.value.calcWidth();
    }; // 移动到当前的tag


    var moveToCurrentTab = function moveToCurrentTab() {
      vue.nextTick(function () {
        if (props.data.length === 0) return;
        var $target = rootRef == null ? void 0 : rootRef.value.querySelector("#" + props.modelValue);
        scrollPaneRef == null ? void 0 : scrollPaneRef.value.moveToTarget($target);
      });
    }; // 更新选中active


    var emitInput = function emitInput() {
      emit('update:modelValue', data.selectedTag.key);
      emit('change', data.selectedTag);
    }; // 选择当前tab


    var handleSelectTab = function handleSelectTab(tab) {
      data.selectedTag = _extends$2({}, tab);
      emitInput();
      vue.nextTick(function () {
        // 计算bar位置
        calcBar();
      });
    }; // 移动焦点至后一个view


    var toLastView = function toLastView(visitedViews, view) {
      data.selectedTag = {
        key: ''
      };
      var currentIndex = visitedViews.findIndex(function (t) {
        return t.key === view.key;
      }); // 前后的索引缓存

      var prev = currentIndex - 1;
      var next = currentIndex + 1; // 如果下一个索引小于数组长度

      if (next < visitedViews.length) {
        data.selectedTag = _extends$2({}, visitedViews[next]);
      } else if (next === visitedViews.length) {
        // 如果当前关闭的是最后一个tag，则判断其前一个索引是否存在，如存在则跳至前一个
        if (prev >= 0) {
          data.selectedTag = _extends$2({}, visitedViews[prev]);
        }
      }

      emitInput();
    }; // 关闭当前的tab页签


    var closeSelectedTab = function closeSelectedTab(tab) {
      // 缓存tabs
      var visitedViews = deepCopy(props.data);

      if (tab.key === props.modelValue) {
        toLastView(visitedViews, tab);
      }

      emit('tab-close', tab);
    }; // 打开右键菜单选择


    var openMenu = function openMenu(tab, e) {
      if (props.contextMenu) {
        data.visible = true;
        data.selectedTag = tab;
        data.left = e.clientX;
        data.top = e.clientY;
        emit('tab-select', tab);
      }
    };

    var closeMenu = function closeMenu() {
      data.visible = false;
    };

    var calcEvent = throttle$2(calcScrollWidth, 10);
    vue.onMounted(function () {
      calcBar();
      addResizeListener(rootRef.value, calcEvent);
      on$1(window, 'resize', calcEvent);
      vue.nextTick(function () {
        calcScrollWidth();
      });
    });
    vue.onBeforeUnmount(function () {
      removeResizeListener(rootRef.value, calcEvent);
      off$1(window, 'resize', calcEvent);
    });
    vue.watch(function () {
      return props.data;
    }, function () {
      vue.nextTick(function () {
        calcScrollWidth();
      });
    });
    vue.watch(function () {
      return data.visible;
    }, function (val) {
      if (val) {
        document.body.addEventListener('click', closeMenu);
      } else {
        document.body.removeEventListener('click', closeMenu);
      }
    });
    vue.watch(function () {
      return props.modelValue;
    }, function () {
      moveToCurrentTab();
    });
    return _extends$2({
      rootRef: rootRef,
      scrollPaneRef: scrollPaneRef
    }, vue.toRefs(data), {
      handleSelectTab: handleSelectTab,
      moveToCurrentTab: moveToCurrentTab,
      calcScrollWidth: calcScrollWidth,
      openMenu: openMenu,
      closeMenu: closeMenu,
      closeSelectedTab: closeSelectedTab
    });
  }
};

var _hoisted_1$Q = {
  class: "tab-list"
};

var _hoisted_2$A = /*#__PURE__*/vue.createVNode("li", null, "自定义插入li标签", -1
/* HOISTED */
);

function render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_scroll_pane = vue.resolveComponent("scroll-pane");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-tabs-wrapper", [$props.type, {
      'closable': $props.closable
    }]],
    ref: "rootRef"
  }, [vue.createVNode(_component_scroll_pane, {
    class: "nav-wrapper",
    ref: "scrollPaneRef"
  }, {
    default: vue.withCtx(function () {
      return [vue.createVNode("div", _hoisted_1$Q, [vue.createCommentVNode("下标"), $props.type === 'default' ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: "tabs-active-bar",
        style: _ctx.activeBarStyle
      }, null, 4
      /* STYLE */
      )) : vue.createCommentVNode("v-if", true), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.data, function (tab, index) {
        return vue.openBlock(), vue.createBlock("span", {
          key: tab.key || 'tab-' + index,
          class: ["tab-item", [{
            'width-icon': tab.icon
          }, {
            'no-close': tab.noClose
          }, {
            'active': tab.key === $props.modelValue
          }]],
          id: tab.key,
          onClick: vue.withModifiers(function ($event) {
            return $setup.handleSelectTab(tab);
          }, ["stop"]),
          onContextmenu: vue.withModifiers(function ($event) {
            return $setup.openMenu(tab, $event);
          }, ["stop", "prevent"])
        }, [tab.icon ? (vue.openBlock(), vue.createBlock("i", {
          key: 0,
          class: ["custom-icon", ['b-iconfont', "b-icon-" + tab.icon]]
        }, null, 2
        /* CLASS */
        )) : vue.createCommentVNode("v-if", true), vue.createTextVNode(" " + vue.toDisplayString(tab.title) + " ", 1
        /* TEXT */
        ), $props.type !== 'default' && $props.closable && !tab.noClose ? (vue.openBlock(), vue.createBlock("i", {
          key: 1,
          class: "b-iconfont b-icon-close",
          onClick: vue.withModifiers(function ($event) {
            return $setup.closeSelectedTab(tab);
          }, ["prevent", "stop"])
        }, null, 8
        /* PROPS */
        , ["onClick"])) : vue.createCommentVNode("v-if", true)], 42
        /* CLASS, PROPS, HYDRATE_EVENTS */
        , ["id", "onClick", "onContextmenu"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))])];
    }),
    _: 1
    /* STABLE */

  }, 512
  /* NEED_PATCH */
  ), $props.contextMenu ? (vue.openBlock(), vue.createBlock(vue.Transition, {
    key: 0,
    name: "zoom-in-top"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("ul", {
        class: "contextmenu",
        style: {
          left: _ctx.left + 'px',
          top: _ctx.top + 'px'
        }
      }, [vue.renderSlot(_ctx.$slots, "menu", {}, function () {
        return [_hoisted_2$A];
      })], 4
      /* STYLE */
      ), [[vue.vShow, _ctx.visible]])];
    }),
    _: 3
    /* FORWARDED */

  })) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$1i.render = render$1g;
script$1i.__file = "src/components/tabs/tabs.vue";

script$1i.install = function (app) {
  app.component(script$1i.name, script$1i);
};

var script$1h = {
  name: 'BSteps',
  props: {
    current: {
      type: Number,
      default: 0
    },
    status: {
      validator: function validator(value) {
        return ['wait', 'process', 'finish', 'error', 'success'].includes(value);
      },
      default: 'process'
    },
    size: {
      validator: function validator(value) {
        return ['small'].includes(value);
      }
    },
    direction: {
      validator: function validator(value) {
        return ['horizontal', 'vertical'].includes(value);
      },
      default: 'horizontal'
    }
  },
  setup: function setup(props) {
    var stepsMitt = mitt();
    var stepChild = vue.ref([]); // 用于获取所有子组件示例

    var updateChildProps = function updateChildProps(isInit) {
      var total = stepChild.value.length;
      stepChild.value.forEach(function (child, index) {
        child.stepNumber = index + 1;

        if (props.direction === 'horizontal') {
          child.total = total;
        } // 如果已存在status,且在初始化时,则略过
        // todo 如果当前是error,在current改变时需要处理


        if (!(isInit && child.currentStatus)) {
          if (index === props.current) {
            if (props.status !== 'error') {
              child.currentStatus = 'process';
            }

            if (props.status === 'success') {
              child.currentStatus = 'success';
            }
          } else if (index < props.current) {
            child.currentStatus = 'finish';
          } else {
            child.currentStatus = 'wait';
          }
        }

        if (child.currentStatus !== 'error' && index !== 0) {
          stepChild.value[index - 1].nextError = false;
        }
      });
    };

    var setNextError = function setNextError() {
      stepChild.value.forEach(function (child, index) {
        if (child.currentStatus === 'error' && index !== 0) {
          stepChild.value[index - 1].nextError = true;
        }
      });
    };

    var updateCurrent = function updateCurrent(isInit) {
      // 防止溢出边界
      if (props.current < 0 || props.current >= stepChild.value.length) {
        return;
      }

      if (isInit) {
        if (!stepChild.value[props.current].currentStatus) {
          stepChild.value[props.current].currentStatus = props.status;
        }
      } else {
        stepChild.value[props.current].currentStatus = props.status;
      }
    };

    var updateSteps = function updateSteps() {
      updateChildProps(true);
      setNextError();
      updateCurrent(true);
    };

    var debouncedAppendRemove = throttle$2(updateSteps, 50, false);
    stepsMitt.on('append', debouncedAppendRemove);
    stepsMitt.on('remove', debouncedAppendRemove);
    vue.provide('Steps', {
      stepChild: stepChild,
      stepsMitt: stepsMitt
    });
    vue.onMounted(function () {
      updateSteps();
    });
    vue.onUnmounted(function () {
      stepsMitt.all.clear();
    });
    return {
      stepChild: stepChild,
      updateChildProps: updateChildProps,
      updateCurrent: updateCurrent
    };
  },
  watch: {
    current: function current() {
      this.updateChildProps();
    },
    status: function status() {
      this.updateCurrent();
    }
  }
};

function render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  var _ref;

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-steps", "bin-steps-" + $props.direction, (_ref = {}, _ref["bin-steps-" + $props.size] = !!$props.size, _ref)]
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$1h.render = render$1f;
script$1h.__file = "src/components/steps/steps.vue";

script$1h.install = function (app) {
  app.component(script$1h.name, script$1h);
};

var prefixCls$e = 'bin-steps';
var script$1g = {
  name: 'BStep',
  props: {
    status: {
      validator: function validator(value) {
        return ['wait', 'process', 'finish', 'error', 'success'].includes(value);
      }
    },
    title: {
      type: String,
      default: ''
    },
    content: String,
    icon: String
  },
  setup: function setup(props) {
    var stepsParent = vue.inject('Steps');
    var stepsMitt = stepsParent == null ? void 0 : stepsParent.stepsMitt;
    var data = vue.reactive({
      stepNumber: '',
      nextError: false,
      total: 1,
      currentStatus: props.status
    });
    stepsParent.stepChild.value = [].concat(stepsParent.stepChild.value, [data]);
    vue.onMounted(function () {
      stepsMitt == null ? void 0 : stepsMitt.emit('append');
    });
    vue.onBeforeUnmount(function () {
      stepsMitt == null ? void 0 : stepsMitt.emit('remove');
    });
    return _extends$2({}, vue.toRefs(data));
  },
  computed: {
    wrapClasses: function wrapClasses() {
      var _ref;

      return [prefixCls$e + "-item", prefixCls$e + "-status-" + this.currentStatus, (_ref = {}, _ref[prefixCls$e + "-custom"] = !!this.icon || !!this.$slots.icon, _ref[prefixCls$e + "-next-error"] = this.nextError, _ref)];
    },
    iconClasses: function iconClasses() {
      var _ref2;

      var icon = '';

      if (this.icon) {
        icon = this.icon;
      } else {
        if (this.currentStatus === 'finish') {
          icon = 'check';
        } else if (this.currentStatus === 'success') {
          icon = 'check';
        } else if (this.currentStatus === 'error') {
          icon = 'close';
        }
      }

      return [prefixCls$e + "-icon", "b-iconfont", (_ref2 = {}, _ref2["b-icon-" + icon] = icon !== '', _ref2)];
    }
  },
  watch: {
    status: function status(val) {
      this.currentStatus = val;

      if (this.currentStatus === 'error') {
        this.$parent.setNextError();
      }
    }
  }
};

var _hoisted_1$P = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-steps-tail"
}, [/*#__PURE__*/vue.createVNode("i")], -1
/* HOISTED */
);

var _hoisted_2$z = {
  class: "bin-steps-head"
};
var _hoisted_3$p = {
  class: "bin-steps-head-inner"
};
var _hoisted_4$j = {
  key: 0
};
var _hoisted_5$g = {
  key: 1,
  class: "bin-steps-icon"
};
var _hoisted_6$9 = {
  class: "bin-steps-main"
};
var _hoisted_7$8 = {
  class: "bin-steps-title"
};
var _hoisted_8$6 = {
  key: 0,
  class: "bin-steps-content"
};
function render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $options.wrapClasses
  }, [_hoisted_1$P, vue.createVNode("div", _hoisted_2$z, [vue.createVNode("div", _hoisted_3$p, [!$props.icon && !_ctx.$slots.icon && _ctx.currentStatus !== 'finish' && _ctx.currentStatus !== 'error' ? (vue.openBlock(), vue.createBlock("span", _hoisted_4$j, vue.toDisplayString(_ctx.stepNumber), 1
  /* TEXT */
  )) : _ctx.$slots.icon ? (vue.openBlock(), vue.createBlock("span", _hoisted_5$g, [vue.renderSlot(_ctx.$slots, "icon")])) : (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    class: $options.iconClasses
  }, null, 2
  /* CLASS */
  ))])]), vue.createVNode("div", _hoisted_6$9, [vue.createVNode("div", _hoisted_7$8, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.title), 1
    /* TEXT */
    )];
  })]), $props.content || _ctx.$slots.content ? (vue.openBlock(), vue.createBlock("div", _hoisted_8$6, [vue.renderSlot(_ctx.$slots, "content", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.content), 1
    /* TEXT */
    )];
  })])) : vue.createCommentVNode("v-if", true)])], 2
  /* CLASS */
  );
}

script$1g.render = render$1e;
script$1g.__file = "src/components/steps/step.vue";

script$1g.install = function (app) {
  app.component(script$1g.name, script$1g);
};

var script$1f = {
  name: 'BDropdown',
  components: {
    BPopper: script$1F
  },
  props: {
    trigger: {
      type: String,
      default: 'hover'
    },
    type: String,
    appendToBody: Boolean,
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    tabindex: {
      type: Number,
      default: 0
    },
    showTimeout: {
      type: Number,
      default: 150
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    theme: {
      type: String,
      default: 'light'
    }
  },
  emits: ['visible-change', 'command'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _instance = vue.getCurrentInstance();

    var timeout = vue.ref(null);
    var visible = vue.ref(false);
    vue.watch(function () {
      return visible.value;
    }, function (val) {
      if (val) triggerElmFocus();
      if (!val) triggerElmBlur();
      emit('visible-change', val);
    });
    var focusing = vue.ref(false);
    vue.watch(function () {
      return focusing.value;
    }, function (val) {
      var selfDefine = triggerElm.value;

      if (selfDefine) {
        if (val) {
          addClass(selfDefine, 'focusing');
        } else {
          removeClass(selfDefine, 'focusing');
        }
      }
    });
    var triggerVNode = vue.ref(null);
    var triggerElm = vue.computed(function () {
      var _triggerVNode$value$$, _triggerVNode$value, _triggerVNode$value$$2;

      return (_triggerVNode$value$$ = (_triggerVNode$value = triggerVNode.value) == null ? void 0 : (_triggerVNode$value$$2 = _triggerVNode$value.$refs.triggerRef) == null ? void 0 : _triggerVNode$value$$2.children[0]) != null ? _triggerVNode$value$$ : {};
    });

    function handleClick() {
      var _triggerElm$value;

      if ((_triggerElm$value = triggerElm.value) != null && _triggerElm$value.disabled) return;

      if (visible.value) {
        hide();
      } else {
        show();
      }
    }

    function handleRight() {
      if (props.trigger !== 'contextmenu') {
        return;
      }

      handleClick();
    }

    function show() {
      var _triggerElm$value2;

      if ((_triggerElm$value2 = triggerElm.value) != null && _triggerElm$value2.disabled) return;
      timeout.value && clearTimeout(timeout.value);
      timeout.value = window.setTimeout(function () {
        visible.value = true;
      }, props.trigger === 'click' ? 0 : props.showTimeout);
    }

    function hide() {
      var _triggerElm$value3;

      if ((_triggerElm$value3 = triggerElm.value) != null && _triggerElm$value3.disabled) return;
      removeTabindex();

      if (props.tabindex >= 0) {
        resetTabindex(triggerElm.value);
      }

      clearTimeout(timeout.value);
      timeout.value = window.setTimeout(function () {
        visible.value = false;
      }, props.trigger === 'click' ? 0 : props.hideTimeout);
    }

    function removeTabindex() {
      var _triggerElm$value4;

      (_triggerElm$value4 = triggerElm.value) == null ? void 0 : _triggerElm$value4.setAttribute('tabindex', '-1');
    }

    function resetTabindex(ele) {
      removeTabindex();
      ele == null ? void 0 : ele.setAttribute('tabindex', '0');
    }

    function triggerElmFocus() {
      var _triggerElm$value5;

      (_triggerElm$value5 = triggerElm.value) == null ? void 0 : _triggerElm$value5.focus == null ? void 0 : _triggerElm$value5.focus();
    }

    function triggerElmBlur() {
      var _triggerElm$value6;

      (_triggerElm$value6 = triggerElm.value) == null ? void 0 : _triggerElm$value6.blur == null ? void 0 : _triggerElm$value6.blur();
    }

    function commandHandler() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      emit.apply(void 0, ['command'].concat(args));
    }

    vue.provide('BDropdown', {
      instance: _instance,
      visible: visible,
      handleClick: handleClick,
      commandHandler: commandHandler,
      show: show,
      hide: hide,
      trigger: vue.computed(function () {
        return props.trigger;
      }),
      hideOnClick: vue.computed(function () {
        return props.hideOnClick;
      }),
      triggerElm: triggerElm
    });
    vue.onMounted(function () {
      if (props.trigger === 'hover') {
        on$1(triggerElm.value, 'mouseenter', show);
        on$1(triggerElm.value, 'mouseleave', hide);
      } else if (props.trigger === 'click') {
        on$1(triggerElm.value, 'click', handleClick);
      }

      Object.assign(_instance, {
        handleClick: handleClick,
        hide: hide,
        resetTabindex: resetTabindex
      });
    });
    return {
      visible: visible,
      triggerVNode: triggerVNode,
      handleRight: handleRight
    };
  }
};

function render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_popper = vue.resolveComponent("b-popper");

  return vue.openBlock(), vue.createBlock(_component_b_popper, {
    ref: "triggerVNode",
    visible: $setup.visible,
    "onUpdate:visible": _cache[2] || (_cache[2] = function ($event) {
      return $setup.visible = $event;
    }),
    placement: $props.placement,
    theme: $props.theme,
    pure: "",
    "manual-mode": true,
    trigger: [$props.trigger],
    "popper-class": "bin-dropdown__popper",
    "append-to-body": $props.appendToBody,
    transition: "zoom-in-top",
    offset: 4,
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    "show-arrow": false
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "dropdown")];
    }),
    trigger: vue.withCtx(function () {
      return [vue.createVNode("div", {
        class: "bin-dropdown",
        onContextmenu: _cache[1] || (_cache[1] = vue.withModifiers(function () {
          return $setup.handleRight && $setup.handleRight.apply($setup, arguments);
        }, ["prevent"]))
      }, [vue.renderSlot(_ctx.$slots, "default")], 32
      /* HYDRATE_EVENTS */
      )];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["visible", "placement", "theme", "trigger", "append-to-body"]);
}

script$1f.render = render$1d;
script$1f.__file = "src/components/dropdown/dropdown.vue";

script$1f.install = function (app) {
  app.component(script$1f.name, script$1f);
};

var useDropdown = function useDropdown() {
  var bDropdown = vue.inject('BDropdown', {});
  return {
    bDropdown: bDropdown
  };
};
var initDropdownDomEvent = function initDropdownDomEvent(dropdownChildren, triggerElm, _instance) {
  var menuItems = vue.ref(null);
  var menuItemsArray = vue.ref(null);
  var dropdownElm = vue.ref(null);
  var listId = vue.ref("dropdown-menu-" + generateId$1());
  dropdownElm.value = dropdownChildren == null ? void 0 : dropdownChildren.subTree.el;

  function removeTabindex() {
    var _menuItemsArray$value;

    triggerElm.setAttribute('tabindex', '-1');
    (_menuItemsArray$value = menuItemsArray.value) == null ? void 0 : _menuItemsArray$value.forEach(function (item) {
      item.setAttribute('tabindex', '-1');
    });
  }

  function resetTabindex(ele) {
    removeTabindex();
    ele == null ? void 0 : ele.setAttribute('tabindex', '0');
  }

  function handleTriggerKeyDown(ev) {
    var code = ev.code;

    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      removeTabindex();
      resetTabindex(menuItems.value[0]);
      menuItems.value[0].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code === EVENT_CODE.enter) {
      _instance.handleClick();
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code)) {
      _instance.hide();
    }
  }

  function handleItemKeyDown(ev) {
    var code = ev.code;
    var target = ev.target;
    var currentIndex = menuItemsArray.value.indexOf(target);
    var max = menuItemsArray.value.length - 1;
    var nextIndex;

    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
      } else {
        nextIndex = currentIndex < max ? currentIndex + 1 : max;
      }

      removeTabindex();
      resetTabindex(menuItems.value[nextIndex]);
      menuItems.value[nextIndex].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code === EVENT_CODE.enter) {
      triggerElmFocus();
      target.click();

      if (_instance.props.hideOnClick) {
        _instance.hide();
      }
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code)) {
      _instance.hide();

      triggerElmFocus();
    }
  }

  function initAria() {
    dropdownElm.value.setAttribute('id', listId.value);
    triggerElm.setAttribute('aria-haspopup', 'list');
    triggerElm.setAttribute('aria-controls', listId.value);
  }

  function initEvent() {
    on$1(triggerElm, 'keydown', handleTriggerKeyDown);
    on$1(dropdownElm.value, 'keydown', handleItemKeyDown);
  }

  function initDomOperation() {
    menuItems.value = dropdownElm.value.querySelectorAll('[tabindex=\'-1\']');
    menuItemsArray.value = [].slice.call(menuItems.value);
    initEvent();
    initAria();
  }

  function triggerElmFocus() {
    triggerElm.focus();
  }

  initDomOperation();
};

var script$1e = {
  name: 'BDropdownItem',
  props: {
    name: {
      type: [Object, String, Number],
      default: function _default() {
        return {};
      }
    },
    disabled: Boolean,
    divided: Boolean,
    selected: Boolean,
    icon: String
  },
  setup: function setup(props) {
    var _useDropdown = useDropdown(),
        bDropdown = _useDropdown.bDropdown;

    var _instance = vue.getCurrentInstance();

    function handleClick(e) {
      if (props.disabled) return;

      if (bDropdown.hideOnClick.value) {
        bDropdown.handleClick == null ? void 0 : bDropdown.handleClick();
      }

      bDropdown.commandHandler == null ? void 0 : bDropdown.commandHandler(props.name, _instance, e);
    }

    return {
      handleClick: handleClick
    };
  }
};

function render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("li", {
    class: ["bin-dropdown-item", {
      'bin-dropdown-item-disabled': $props.disabled,
      'bin-dropdown-item-divided': $props.divided,
      'bin-dropdown-item-selected': $props.selected
    }],
    "aria-disabled": $props.disabled,
    tabindex: $props.disabled ? null : -1,
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    })
  }, [$props.icon ? (vue.openBlock(), vue.createBlock("i", {
    key: 0,
    class: "b-iconfont b-icon-" + $props.icon
  }, null, 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default")], 10
  /* CLASS, PROPS */
  , ["aria-disabled", "tabindex"]);
}

script$1e.render = render$1c;
script$1e.__file = "src/components/dropdown/dropdown-item.vue";

script$1e.install = function (app) {
  app.component(script$1e.name, script$1e);
};

var script$1d = {
  name: 'BDropdownMenu',
  directives: {
    ClickOutside: ClickOutside
  },
  setup: function setup() {
    var _useDropdown = useDropdown(),
        bDropdown = _useDropdown.bDropdown;

    function show() {
      bDropdown.show == null ? void 0 : bDropdown.show();
    }

    function hide() {
      if (bDropdown.trigger.value === 'click') return;

      _hide();
    }

    function _hide() {
      bDropdown.hide == null ? void 0 : bDropdown.hide();
    }

    vue.onMounted(function () {
      var dropdownMenu = vue.getCurrentInstance();
      initDropdownDomEvent(dropdownMenu, bDropdown.triggerElm.value, bDropdown.instance);
    });
    return {
      show: show,
      hide: hide,
      innerHide: _hide,
      triggerElm: bDropdown.triggerElm
    };
  }
};

function render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.withDirectives((vue.openBlock(), vue.createBlock("ul", {
    class: "bin-dropdown-menu",
    onMouseenter: _cache[1] || (_cache[1] = vue.withModifiers(function () {
      return $setup.show && $setup.show.apply($setup, arguments);
    }, ["stop"])),
    onMouseleave: _cache[2] || (_cache[2] = vue.withModifiers(function () {
      return $setup.hide && $setup.hide.apply($setup, arguments);
    }, ["stop"]))
  }, [vue.renderSlot(_ctx.$slots, "default")], 544
  /* HYDRATE_EVENTS, NEED_PATCH */
  )), [[_directive_click_outside, $setup.innerHide, $setup.triggerElm]]);
}

script$1d.render = render$1b;
script$1d.__file = "src/components/dropdown/dropdown-menu.vue";

script$1d.install = function (app) {
  app.component(script$1d.name, script$1d);
};

var prefixCls$d = 'bin-timeline';
var script$1c = {
  name: 'BTimeline',
  props: {
    pending: Boolean
  },
  computed: {
    cpClasses: function cpClasses() {
      var _ref;

      return ["" + prefixCls$d, (_ref = {}, _ref[prefixCls$d + "-pending"] = this.pending, _ref)];
    }
  }
};

function render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("ul", {
    class: $options.cpClasses
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$1c.render = render$1a;
script$1c.__file = "src/components/timeline/timeline.vue";

script$1c.install = function (app) {
  app.component(script$1c.name, script$1c);
};

var prefixCls$c = 'bin-timeline';
var script$1b = {
  name: 'BTimelineItem',
  props: {
    color: {
      type: String,
      default: 'primary'
    },
    dotTop: String
  },
  setup: function setup() {
    var dotEl = vue.ref(null);
    var dot = vue.ref(false);
    vue.onMounted(function () {
      dot.value = !!dotEl.value.innerHTML.length;
    });
    return {
      dotEl: dotEl,
      dot: dot
    };
  },
  computed: {
    itemClasses: function itemClasses() {
      return prefixCls$c + "-item";
    },
    tailClasses: function tailClasses() {
      return prefixCls$c + "-item-tail";
    },
    headClasses: function headClasses() {
      var _ref;

      return [prefixCls$c + "-item-head", (_ref = {}, _ref[prefixCls$c + "-item-head-custom"] = this.dot, _ref[prefixCls$c + "-item-head-" + this.color] = this.headColorShow, _ref)];
    },
    headColorShow: function headColorShow() {
      return ['primary', 'success', 'info', 'warning', 'danger'].includes(this.color);
    },
    customStyle: function customStyle() {
      var style = {};

      if (this.color) {
        if (!this.headColorShow) {
          style = {
            'color': this.color,
            'border-color': this.color,
            top: this.dotTop
          };
        } else {
          style = {
            top: this.dotTop
          };
        }
      }

      return style;
    },
    contentClasses: function contentClasses() {
      return prefixCls$c + "-item-content";
    }
  }
};

function render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("li", {
    class: $options.itemClasses
  }, [vue.createVNode("div", {
    class: $options.tailClasses
  }, null, 2
  /* CLASS */
  ), vue.createVNode("div", {
    class: $options.headClasses,
    style: $options.customStyle,
    ref: "dotEl"
  }, [vue.renderSlot(_ctx.$slots, "dot")], 6
  /* CLASS, STYLE */
  ), vue.createVNode("div", {
    class: $options.contentClasses
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$1b.render = render$19;
script$1b.__file = "src/components/timeline/timeline-item.vue";

script$1b.install = function (app) {
  app.component(script$1b.name, script$1b);
};

var script$1a = {
  name: 'BCarousel',
  props: {
    initialIndex: {
      type: Number,
      default: 0
    },
    height: {
      type: String,
      default: ''
    },
    trigger: {
      type: String,
      default: 'hover'
    },
    autoplay: {
      type: Boolean,
      default: false
    },
    interval: {
      type: Number,
      default: 3000
    },
    indicatorPosition: {
      type: String,
      default: ''
    },
    indicator: {
      type: Boolean,
      default: true
    },
    arrow: {
      type: String,
      default: 'hover'
    },
    type: {
      type: String,
      default: ''
    },
    loop: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: 'horizontal',
      validator: function validator(val) {
        return ['horizontal', 'vertical'].includes(val);
      }
    }
  },
  emits: ['change'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    // data
    var data = vue.reactive({
      activeIndex: -1,
      containerWidth: 0,
      timer: null,
      hover: false
    }); // refs

    var root = vue.ref(null);
    var items = vue.ref([]);
    var offsetWidth = vue.ref(0);
    var offsetHeight = vue.ref(0); // computed

    var arrowDisplay = vue.computed(function () {
      return props.arrow !== 'never' && props.direction !== 'vertical';
    });
    var hasLabel = vue.computed(function () {
      return items.value.some(function (item) {
        return item.label.toString().length > 0;
      });
    });
    var carouselClasses = vue.computed(function () {
      var classes = ['bin-carousel', 'bin-carousel--' + props.direction];

      if (props.type === 'card') {
        classes.push('bin-carousel--card');
      }

      return classes;
    });
    var indicatorsClasses = vue.computed(function () {
      var classes = ['bin-carousel__indicators', 'bin-carousel__indicators--' + props.direction];

      if (hasLabel.value) {
        classes.push('bin-carousel__indicators--labels');
      }

      if (props.indicatorPosition === 'outside' || props.type === 'card') {
        classes.push('bin-carousel__indicators--outside');
      }

      return classes;
    }); // methods

    var throttledArrowClick = throttle$2(function (index) {
      setActiveItem(index);
    }, 300, true);
    var throttledIndicatorHover = throttle$2(function (index) {
      handleIndicatorHover(index);
    }, 300);

    function pauseTimer() {
      if (data.timer) {
        clearInterval(data.timer);
        data.timer = null;
      }
    }

    function startTimer() {
      if (props.interval <= 0 || !props.autoplay || data.timer) return;
      data.timer = setInterval(function () {
        return playSlides();
      }, props.interval);
    }

    var playSlides = function playSlides() {
      if (data.activeIndex < items.value.length - 1) {
        data.activeIndex = data.activeIndex + 1;
      } else if (props.loop) {
        data.activeIndex = 0;
      }
    };

    function setActiveItem(index) {
      if (typeof index === 'string') {
        var filteredItems = items.value.filter(function (item) {
          return item.name === index;
        });

        if (filteredItems.length > 0) {
          index = items.value.indexOf(filteredItems[0]);
        }
      }

      index = Number(index);

      if (isNaN(index) || index !== Math.floor(index)) {
        console.warn('[Element Warn][Carousel]index must be an integer.');
        return;
      }

      var length = items.value.length;
      var oldIndex = data.activeIndex;

      if (index < 0) {
        data.activeIndex = props.loop ? length - 1 : 0;
      } else if (index >= length) {
        data.activeIndex = props.loop ? 0 : length - 1;
      } else {
        data.activeIndex = index;
      }

      if (oldIndex === data.activeIndex) {
        resetItemPosition(oldIndex);
      }
    }

    function resetItemPosition(oldIndex) {
      items.value.forEach(function (item, index) {
        item.translateItem(index, data.activeIndex, oldIndex);
      });
    }

    function updateItems(item) {
      items.value.push(item);
    }

    function itemInStage(item, index) {
      var length = items.value.length;

      if (index === length - 1 && item.inStage && items.value[0].active || item.inStage && items.value[index + 1] && items.value[index + 1].active) {
        return 'left';
      } else if (index === 0 && item.inStage && items.value[length - 1].active || item.inStage && items.value[index - 1] && items.value[index - 1].active) {
        return 'right';
      }

      return false;
    }

    function handleMouseEnter() {
      data.hover = true;
      pauseTimer();
    }

    function handleMouseLeave() {
      data.hover = false;
      startTimer();
    }

    function handleButtonEnter(arrow) {
      if (props.direction === 'vertical') return;
      items.value.forEach(function (item, index) {
        if (arrow === itemInStage(item, index)) {
          item.hover = true;
        }
      });
    }

    function handleButtonLeave() {
      if (props.direction === 'vertical') return;
      items.value.forEach(function (item) {
        item.hover = false;
      });
    }

    function handleIndicatorClick(index) {
      data.activeIndex = index;
    }

    function handleIndicatorHover(index) {
      if (props.trigger === 'hover' && index !== data.activeIndex) {
        data.activeIndex = index;
      }
    }

    function prev() {
      setActiveItem(data.activeIndex - 1);
    }

    function next() {
      setActiveItem(data.activeIndex + 1);
    } // watch


    vue.watch(function () {
      return data.activeIndex;
    }, function (current, prev) {
      resetItemPosition(prev);

      if (prev > -1) {
        emit('change', current, prev);
      }
    });
    vue.watch(function () {
      return props.autoplay;
    }, function (current) {
      current ? startTimer() : pauseTimer();
    });
    vue.watch(function () {
      return props.loop;
    }, function () {
      setActiveItem(data.activeIndex);
    }); // lifecycle

    vue.onMounted(function () {
      vue.nextTick(function () {
        addResizeListener(root.value, resetItemPosition);

        if (root.value) {
          offsetWidth.value = root.value.offsetWidth;
          offsetHeight.value = root.value.offsetHeight;
        }

        if (props.initialIndex < items.value.length && props.initialIndex >= 0) {
          data.activeIndex = props.initialIndex;
        }

        startTimer();
      });
    });
    vue.onBeforeUnmount(function () {
      if (root.value) removeResizeListener(root.value, resetItemPosition);
      pauseTimer();
    }); // provide

    vue.provide('injectCarouselScope', {
      direction: props.direction,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      type: props.type,
      items: items,
      loop: props.loop,
      updateItems: updateItems,
      setActiveItem: setActiveItem
    });
    return {
      data: data,
      props: props,
      items: items,
      arrowDisplay: arrowDisplay,
      carouselClasses: carouselClasses,
      indicatorsClasses: indicatorsClasses,
      hasLabel: hasLabel,
      handleMouseEnter: handleMouseEnter,
      handleMouseLeave: handleMouseLeave,
      handleIndicatorClick: handleIndicatorClick,
      throttledArrowClick: throttledArrowClick,
      throttledIndicatorHover: throttledIndicatorHover,
      handleButtonEnter: handleButtonEnter,
      handleButtonLeave: handleButtonLeave,
      prev: prev,
      next: next,
      setActiveItem: setActiveItem,
      root: root
    };
  }
};

var _hoisted_1$O = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
}, null, -1
/* HOISTED */
);

var _hoisted_2$y = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

var _hoisted_3$o = {
  class: "bin-carousel__button"
};
var _hoisted_4$i = {
  key: 0
};
function render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    ref: "root",
    class: $setup.carouselClasses,
    onMouseenter: _cache[7] || (_cache[7] = vue.withModifiers(function () {
      return $setup.handleMouseEnter && $setup.handleMouseEnter.apply($setup, arguments);
    }, ["stop"])),
    onMouseleave: _cache[8] || (_cache[8] = vue.withModifiers(function () {
      return $setup.handleMouseLeave && $setup.handleMouseLeave.apply($setup, arguments);
    }, ["stop"]))
  }, [vue.createVNode("div", {
    class: "bin-carousel__container",
    style: {
      height: $props.height
    }
  }, [$setup.arrowDisplay ? (vue.openBlock(), vue.createBlock(vue.Transition, {
    key: 0,
    name: "carousel-arrow-left"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("button", {
        type: "button",
        class: "bin-carousel__arrow bin-carousel__arrow--left",
        onMouseenter: _cache[1] || (_cache[1] = function ($event) {
          return $setup.handleButtonEnter('left');
        }),
        onMouseleave: _cache[2] || (_cache[2] = function () {
          return $setup.handleButtonLeave && $setup.handleButtonLeave.apply($setup, arguments);
        }),
        onClick: _cache[3] || (_cache[3] = vue.withModifiers(function ($event) {
          return $setup.throttledArrowClick($setup.data.activeIndex - 1);
        }, ["stop"]))
      }, [_hoisted_1$O], 544
      /* HYDRATE_EVENTS, NEED_PATCH */
      ), [[vue.vShow, ($props.arrow === 'always' || $setup.data.hover) && ($setup.props.loop || $setup.data.activeIndex > 0)]])];
    }),
    _: 1
    /* STABLE */

  })) : vue.createCommentVNode("v-if", true), $setup.arrowDisplay ? (vue.openBlock(), vue.createBlock(vue.Transition, {
    key: 1,
    name: "carousel-arrow-right"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("button", {
        type: "button",
        class: "bin-carousel__arrow bin-carousel__arrow--right",
        onMouseenter: _cache[4] || (_cache[4] = function ($event) {
          return $setup.handleButtonEnter('right');
        }),
        onMouseleave: _cache[5] || (_cache[5] = function () {
          return $setup.handleButtonLeave && $setup.handleButtonLeave.apply($setup, arguments);
        }),
        onClick: _cache[6] || (_cache[6] = vue.withModifiers(function ($event) {
          return $setup.throttledArrowClick($setup.data.activeIndex + 1);
        }, ["stop"]))
      }, [_hoisted_2$y], 544
      /* HYDRATE_EVENTS, NEED_PATCH */
      ), [[vue.vShow, ($props.arrow === 'always' || $setup.data.hover) && ($setup.props.loop || $setup.data.activeIndex < $setup.items.length - 1)]])];
    }),
    _: 1
    /* STABLE */

  })) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  ), $props.indicatorPosition !== 'none' ? (vue.openBlock(), vue.createBlock("ul", {
    key: 0,
    class: $setup.indicatorsClasses
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.items, function (item, index) {
    return vue.openBlock(), vue.createBlock("li", {
      key: index,
      class: ['bin-carousel__indicator', 'bin-carousel__indicator--' + $props.direction, {
        'is-active': index === $setup.data.activeIndex
      }],
      onMouseenter: function onMouseenter($event) {
        return $setup.throttledIndicatorHover(index);
      },
      onClick: vue.withModifiers(function ($event) {
        return $setup.handleIndicatorClick(index);
      }, ["stop"])
    }, [vue.createVNode("button", _hoisted_3$o, [$setup.hasLabel ? (vue.openBlock(), vue.createBlock("span", _hoisted_4$i, vue.toDisplayString(item.label), 1
    /* TEXT */
    )) : vue.createCommentVNode("v-if", true)])], 42
    /* CLASS, PROPS, HYDRATE_EVENTS */
    , ["onMouseenter", "onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$1a.render = render$18;
script$1a.__file = "src/components/carousel/carousel.vue";

script$1a.install = function (app) {
  app.component(script$1a.name, script$1a);
};

var CARD_SCALE = 0.83;
var script$19 = {
  name: 'BCarouselItem',
  props: {
    name: {
      type: String,
      default: ''
    },
    label: {
      type: [String, Number],
      default: ''
    }
  },
  setup: function setup(props) {
    // instance
    var instance = vue.getCurrentInstance();
    instance.uid; // data

    var data = vue.reactive({
      hover: false,
      translate: 0,
      scale: 1,
      active: false,
      ready: false,
      inStage: false,
      animating: false
    }); // inject

    var injectCarouselScope = vue.inject('injectCarouselScope'); // computed

    var parentDirection = vue.computed(function () {
      return injectCarouselScope.direction;
    });
    var itemStyle = vue.computed(function () {
      var translateType = parentDirection.value === 'vertical' ? 'translateY' : 'translateX';
      var value = translateType + "(" + data.translate + "px) scale(" + data.scale + ")";
      var style = {
        transform: value
      };
      return autoprefixer(style);
    }); // methods

    function processIndex(index, activeIndex, length) {
      if (activeIndex === 0 && index === length - 1) {
        return -1;
      } else if (activeIndex === length - 1 && index === 0) {
        return length;
      } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
        return length + 1;
      } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
        return -2;
      }

      return index;
    }

    function calcCardTranslate(index, activeIndex) {
      var parentWidth = injectCarouselScope.offsetWidth.value;

      if (data.inStage) {
        return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
      } else if (index < activeIndex) {
        return -(1 + CARD_SCALE) * parentWidth / 4;
      } else {
        return (3 + CARD_SCALE) * parentWidth / 4;
      }
    }

    function calcTranslate(index, activeIndex, isVertical) {
      var distance = injectCarouselScope[isVertical ? 'offsetHeight' : 'offsetWidth'].value;
      return distance * (index - activeIndex);
    }

    var translateItem = function translateItem(index, activeIndex, oldIndex) {
      var parentType = injectCarouselScope.type;
      var length = injectCarouselScope.items.value.length;

      if (parentType !== 'card' && oldIndex !== undefined) {
        data.animating = index === activeIndex || index === oldIndex;
      }

      if (index !== activeIndex && length > 2 && injectCarouselScope.loop) {
        index = processIndex(index, activeIndex, length);
      }

      if (parentType === 'card') {
        if (parentDirection.value === 'vertical') {
          console.warn('[Element Warn][Carousel]vertical direction is not supported in card mode');
        }

        data.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
        data.active = index === activeIndex;
        data.translate = calcCardTranslate(index, activeIndex);
        data.scale = data.active ? 1 : CARD_SCALE;
      } else {
        data.active = index === activeIndex;
        var isVertical = parentDirection.value === 'vertical';
        data.translate = calcTranslate(index, activeIndex, isVertical);
      }

      data.ready = true;
    };

    function handleItemClick() {
      if (injectCarouselScope && injectCarouselScope.type === 'card') {
        var index = injectCarouselScope.items.value.map(function (d) {
          return d.uid;
        }).indexOf(instance.uid);
        injectCarouselScope.setActiveItem(index);
      }
    } // lifecycle


    vue.onMounted(function () {
      if (injectCarouselScope.updateItems) {
        injectCarouselScope.updateItems(_extends$2({
          uid: instance.uid
        }, props, vue.toRefs(data), {
          translateItem: translateItem
        }));
      }
    });
    return {
      data: data,
      itemStyle: itemStyle,
      translateItem: translateItem,
      type: injectCarouselScope.type,
      handleItemClick: handleItemClick
    };
  }
};

var _hoisted_1$N = {
  key: 0,
  class: "bin-carousel__mask"
};
function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createBlock("div", {
    class: ["bin-carousel__item", {
      'is-active': $setup.data.active,
      'bin-carousel__item--card': $setup.type === 'card',
      'is-in-stage': $setup.data.inStage,
      'is-hover': $setup.data.hover,
      'is-animating': $setup.data.animating
    }],
    style: $setup.itemStyle,
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleItemClick && $setup.handleItemClick.apply($setup, arguments);
    })
  }, [$setup.type === 'card' ? vue.withDirectives((vue.openBlock(), vue.createBlock("div", _hoisted_1$N, null, 512
  /* NEED_PATCH */
  )), [[vue.vShow, !$setup.data.active]]) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  )), [[vue.vShow, $setup.data.ready]]);
}

script$19.render = render$17;
script$19.__file = "src/components/carousel/carousel-item.vue";

script$19.install = function (app) {
  app.component(script$19.name, script$19);
};

function getNewDate(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  var day = date.getDate();
  return {
    year: year,
    month: month,
    day: day
  };
} // 根据年月日转换成日期类型


function getDate(year, month, day) {
  return new Date(year, month, day);
}

function isPrevOrNextMonth(date, time) {
  var newDate = getNewDate(getDate(time.year, time.month, 1));
  var currentYear = newDate.year;
  var currentMonth = newDate.month;

  var _getNewDate = getNewDate(date),
      year = _getNewDate.year,
      month = _getNewDate.month;

  if (currentYear === year && currentMonth === month) return null;
  if (currentMonth === 0 && month === 11) return 'prev';
  if (currentMonth === 11 && month === 0) return 'next';
  if (currentMonth > month) return 'prev';
  if (currentMonth < month) return 'next';
  return null;
}

function isCurrent(date) {
  var newDate = getNewDate(new Date());
  var currentYear = newDate.year;
  var currentMonth = newDate.month;
  var currentDay = newDate.day;

  var _getNewDate2 = getNewDate(date),
      year = _getNewDate2.year,
      month = _getNewDate2.month,
      day = _getNewDate2.day;

  return currentYear === year && currentMonth === month && currentDay === day;
}

var script$18 = {
  name: 'BCalendar',
  components: {
    BButton: script$1B,
    BButtonGroup: script$1z
  },
  props: {
    gridHeight: String,
    textAlign: String,
    mini: Boolean,
    bodyStyle: Object,
    dayStyle: Object
  },
  emits: ['prev', 'next', 'today', 'selected', 'select-day'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _getNewDate3 = getNewDate(new Date()),
        year = _getNewDate3.year,
        month = _getNewDate3.month,
        day = _getNewDate3.day;

    var time = vue.ref({
      year: year,
      month: month,
      day: day
    });
    var visibleCalendar = vue.ref([]);

    var initVisibleCalendar = function initVisibleCalendar() {
      var calendarArr = [];

      var _getNewDate4 = getNewDate(getDate(time.value.year, time.value.month, 1)),
          year = _getNewDate4.year,
          month = _getNewDate4.month;

      var newDate = getNewDate(new Date());
      var currentYear = newDate.year;
      var currentMonth = newDate.month; // 获取当月的第一天

      var currentFirstDay = getDate(year, month, 1); // 获取第一天是星期几

      var weekDay = currentFirstDay.getDay();

      if (weekDay === 0) {
        weekDay = 7;
      }

      var isCurrentMonth = currentYear === year && currentMonth === month;
      var startTime = currentFirstDay.getTime() - (weekDay - 1) * 24 * 60 * 60 * 1000;

      for (var i = 0; i < 42; i++) {
        var tempDate = new Date(startTime + i * 24 * 60 * 60 * 1000);
        var monthFlag = isPrevOrNextMonth(tempDate, time.value);
        var isCurrentDay = isCurrent(tempDate);
        var yearTemp = year;
        var monthTemp = monthFlag === 'prev' ? month : monthFlag === 'next' ? month + 2 : month + 1;

        if (monthTemp === 0) {
          monthTemp = 12;
          yearTemp -= 1;
        }

        if (monthTemp === 13) {
          monthTemp = 1;
          yearTemp += 1;
        }

        var _day = {
          date: tempDate,
          year: yearTemp,
          month: monthTemp,
          day: tempDate.getDate(),
          monthFlag: monthFlag,
          isCurrentDay: isCurrentDay,
          selected: isCurrentMonth ? isCurrentDay : i === weekDay - 1
        };
        calendarArr.push(_day);

        if (_day.selected) {
          emit('select-day', _day);
        }
      }

      visibleCalendar.value = calendarArr;
    }; // 上一个月


    var handlePrevMonth = function handlePrevMonth() {
      var prevMonth = getDate(time.value.year, time.value.month, 1);
      prevMonth.setMonth(prevMonth.getMonth() - 1);
      time.value = _extends$2({}, getNewDate(prevMonth));
      initVisibleCalendar();
      emit('prev');
    }; // 下一个月


    var handleNextMonth = function handleNextMonth() {
      var nextMonth = getDate(time.value.year, time.value.month, 1);
      nextMonth.setMonth(nextMonth.getMonth() + 1);
      time.value = _extends$2({}, getNewDate(nextMonth));
      initVisibleCalendar();
      emit('next');
    }; // 点击回到今天


    var handleToday = function handleToday() {
      time.value = getNewDate(new Date());
      initVisibleCalendar();
      emit('today');
    }; // 点击某一天


    var handleSelectDay = function handleSelectDay(item) {
      if (!item.monthFlag) {
        setSelected(item);
        return;
      }

      if (item.monthFlag === 'prev') {
        handlePrevMonth(); // 获取新数组的当前天

        var select = visibleCalendar.value.find(function (day) {
          return day.year === item.year && day.month === item.month && day.day === item.day;
        });
        select && setSelected(select);
      }

      if (item.monthFlag === 'next') {
        handleNextMonth(); // 获取新数组的当前天

        var _select = visibleCalendar.value.find(function (day) {
          return day.year === item.year && day.month === item.month && day.day === item.day;
        });

        _select && setSelected(_select);
      }
    };

    var setSelected = function setSelected(day) {
      visibleCalendar.value.map(function (x) {
        return x.selected = false;
      });
      day.selected = true;
      emit('selected', day);
    };

    initVisibleCalendar();
    return {
      time: time,
      visibleCalendar: visibleCalendar,
      handleToday: handleToday,
      handlePrevMonth: handlePrevMonth,
      handleSelectDay: handleSelectDay,
      handleNextMonth: handleNextMonth
    };
  },
  computed: {
    dateViewStyle: function dateViewStyle() {
      if (this.dayStyle) {
        return this.dayStyle;
      }

      return {
        height: this.gridHeight,
        textAlign: this.textAlign
      };
    },
    headerTitle: function headerTitle() {
      return this.time ? this.time.year + " \u5E74 " + (this.time.month + 1) + " \u6708" : '';
    }
  }
};

var _hoisted_1$M = {
  class: "bin-calendar-header"
};

var _hoisted_2$x = /*#__PURE__*/vue.createTextVNode("今天");

var _hoisted_3$n = {
  class: "bin-calendar-header-title"
};

var _hoisted_4$h = /*#__PURE__*/vue.createTextVNode("上个月");

var _hoisted_5$f = /*#__PURE__*/vue.createTextVNode("今天");

var _hoisted_6$8 = /*#__PURE__*/vue.createTextVNode("下个月");

var _hoisted_7$7 = {
  class: "bin-calendar-week"
};
function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_button = vue.resolveComponent("b-button");

  var _component_b_button_group = vue.resolveComponent("b-button-group");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-calendar", {
      'card': $props.mini
    }]
  }, [vue.createVNode("div", _hoisted_1$M, [$props.mini ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createVNode("span", null, vue.toDisplayString($options.headerTitle), 1
  /* TEXT */
  ), vue.createVNode(_component_b_button_group, null, {
    default: vue.withCtx(function () {
      return [vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handlePrevMonth,
        icon: "doubleleft"
      }, null, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handleToday
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_2$x];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handleNextMonth,
        icon: "doubleright"
      }, null, 8
      /* PROPS */
      , ["onClick"])];
    }),
    _: 1
    /* STABLE */

  })], 64
  /* STABLE_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 1
  }, [vue.createVNode("div", _hoisted_3$n, vue.toDisplayString($options.headerTitle), 1
  /* TEXT */
  ), vue.createVNode(_component_b_button_group, null, {
    default: vue.withCtx(function () {
      return [vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handlePrevMonth
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_4$h];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handleToday
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_5$f];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        size: "mini",
        onClick: $setup.handleNextMonth
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_6$8];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"])];
    }),
    _: 1
    /* STABLE */

  })], 64
  /* STABLE_FRAGMENT */
  ))]), vue.createVNode("ul", _hoisted_7$7, [(vue.openBlock(), vue.createBlock(vue.Fragment, null, vue.renderList(['一', '二', '三', '四', '五', '六', '日'], function (item, index) {
    return vue.createVNode("li", {
      key: index,
      class: "bin-calendar-week-item"
    }, vue.toDisplayString(item), 1
    /* TEXT */
    );
  }), 64
  /* STABLE_FRAGMENT */
  ))]), vue.createVNode("ul", {
    class: "bin-calendar-body",
    style: $props.bodyStyle
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.visibleCalendar, function (item, index) {
    return vue.openBlock(), vue.createBlock("li", {
      key: index,
      class: ["bin-calendar-date-view", [item.monthFlag, {
        'is-current-day': item.isCurrentDay
      }, {
        'is-selected': item.selected
      }]],
      style: $options.dateViewStyle,
      onClick: function onClick($event) {
        return $setup.handleSelectDay(item);
      }
    }, [vue.createVNode("span", null, vue.toDisplayString(item.day), 1
    /* TEXT */
    )], 14
    /* CLASS, STYLE, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 4
  /* STYLE */
  )], 2
  /* CLASS */
  );
}

script$18.render = render$16;
script$18.__file = "src/components/calendar/calendar.vue";

script$18.install = function (app) {
  app.component(script$18.name, script$18);
};

var prefixCls$b = 'bin-alert';
var TYPE_CLASSES_MAP = {
  'info': 'info-circle',
  'success': 'check-circle',
  'warning': 'warning-circle',
  'error': 'error'
};
var script$17 = {
  name: 'BAlert',
  props: {
    type: {
      type: String,
      default: 'info'
    },
    closable: Boolean,
    showIcon: Boolean,
    banner: Boolean
  },
  emits: ['close'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var closed = vue.ref(false);
    var desc = vue.ref(false);
    var iconType = vue.computed(function () {
      return TYPE_CLASSES_MAP[props.type];
    });
    var wrapClasses = vue.computed(function () {
      var _ref2;

      return ["" + prefixCls$b, prefixCls$b + "-" + props.type, (_ref2 = {}, _ref2[prefixCls$b + "-with-icon"] = props.showIcon, _ref2[prefixCls$b + "-with-desc"] = desc.value, _ref2[prefixCls$b + "-with-banner"] = props.banner, _ref2)];
    });

    var close = function close(e) {
      closed.value = true;
      emit('close', e);
    };

    vue.onMounted(function () {
      desc.value = slots.desc !== undefined;
    });
    return {
      closed: closed,
      desc: desc,
      iconType: iconType,
      wrapClasses: wrapClasses,
      close: close
    };
  }
};

var _hoisted_1$L = {
  key: 0,
  class: "bin-alert-icon"
};
var _hoisted_2$w = {
  class: "bin-alert-message"
};
var _hoisted_3$m = {
  class: "bin-alert-desc"
};
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade-in"
  }, {
    default: vue.withCtx(function () {
      return [!$setup.closed ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: $setup.wrapClasses
      }, [$props.showIcon ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$L, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_b_icon, {
          name: $setup.iconType
        }, null, 8
        /* PROPS */
        , ["name"])];
      })])) : vue.createCommentVNode("v-if", true), vue.createVNode("span", _hoisted_2$w, [vue.renderSlot(_ctx.$slots, "default")]), vue.createVNode("span", _hoisted_3$m, [vue.renderSlot(_ctx.$slots, "desc")]), $props.closable ? (vue.openBlock(), vue.createBlock("a", {
        key: 1,
        class: "bin-alert-close",
        onClick: _cache[1] || (_cache[1] = function () {
          return $setup.close && $setup.close.apply($setup, arguments);
        })
      }, [vue.renderSlot(_ctx.$slots, "close", {}, function () {
        return [vue.createVNode(_component_b_icon, {
          name: "close"
        })];
      })])) : vue.createCommentVNode("v-if", true)], 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true)];
    }),
    _: 3
    /* FORWARDED */

  });
}

script$17.render = render$15;
script$17.__file = "src/components/alert/alert.vue";

script$17.install = function (app) {
  app.component(script$17.name, script$17);
};

var prefixCls$a = 'bin-drawer';
var script$16 = {
  name: 'BDrawer',
  props: {
    modelValue: Boolean,
    title: String,
    width: {
      type: [Number, String],
      default: 300
    },
    minWidth: {
      type: [Number, String],
      default: 300
    },
    showClose: {
      type: Boolean,
      default: true
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    mask: {
      type: Boolean,
      default: true
    },
    styles: Object,
    placement: {
      validator: function validator(value) {
        return ['left', 'right'].includes(value);
      },
      default: 'right'
    },
    zIndex: {
      type: Number,
      default: 0
    },
    appendToBody: Boolean,
    className: String,
    lockScroll: {
      type: Boolean,
      default: true
    },
    inner: Boolean,
    // Whether drag and drop is allowed to adjust width
    draggable: Boolean,
    beforeClose: Function
  },
  setup: function setup(props) {
    var visible = vue.ref(props.modelValue);
    var wrapShow = vue.ref(false);
    var wrapRef = vue.ref(null);
    var canMove = vue.ref(false);
    var dragWidth = vue.ref(props.width);
    var wrapperWidth = vue.ref(props.width);
    var wrapperLeft = vue.ref(0);
    var modalIndex = vue.ref(transferIncrease());

    if (props.lockScroll) {
      useLockScreen(visible);
    }

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      visible.value = val;

      if (val) {
        modalIndex.value = transferIncrease();
        wrapShow.value = true;
      }
    });
    return {
      wrapRef: wrapRef,
      wrapShow: wrapShow,
      visible: visible,
      canMove: canMove,
      dragWidth: dragWidth,
      wrapperWidth: wrapperWidth,
      wrapperLeft: wrapperLeft,
      modalIndex: modalIndex
    };
  },
  emits: ['update:modelValue', 'close', 'resize-width'],
  computed: {
    wrapClasses: function wrapClasses() {
      var _ref;

      return [prefixCls$a + "-wrap", (_ref = {}, _ref[prefixCls$a + "-hidden"] = !this.wrapShow, _ref["" + this.className] = !!this.className, _ref[prefixCls$a + "-no-mask"] = !this.mask, _ref[prefixCls$a + "-wrap-inner"] = this.inner, _ref[prefixCls$a + "-wrap-dragging"] = this.canMove, _ref)];
    },
    wrapStyles: function wrapStyles() {
      return {
        zIndex: this.modalIndex + this.zIndex
      };
    },
    mainStyles: function mainStyles() {
      var style = {};
      var width = parseInt(this.dragWidth);
      var styleWidth = {
        width: width <= 100 ? width + "%" : width + "px"
      };
      Object.assign(style, styleWidth);
      return style;
    },
    contentClasses: function contentClasses() {
      var _ref2;

      return [prefixCls$a + "-content", (_ref2 = {}, _ref2[prefixCls$a + "-content-no-mask"] = !this.mask, _ref2)];
    },
    classes: function classes() {
      var _ref3;

      return ["" + prefixCls$a, prefixCls$a + "-" + this.placement, (_ref3 = {}, _ref3[prefixCls$a + "-no-header"] = !(this.$slots.header || this.title), _ref3[prefixCls$a + "-inner"] = this.inner, _ref3)];
    },
    maskClasses: function maskClasses() {
      var _ref4;

      return [prefixCls$a + "-mask", (_ref4 = {}, _ref4[prefixCls$a + "-mask-inner"] = this.inner, _ref4)];
    }
  },
  methods: {
    close: function close() {
      var _this = this;

      if (!this.beforeClose) {
        return this.handleClose();
      }

      var before = this.beforeClose();

      if (before && before.then) {
        before.then(function () {
          _this.handleClose();
        });
      } else {
        this.handleClose();
      }
    },
    handleClose: function handleClose() {
      this.visible = false;
      this.$emit('update:modelValue', false);
      this.$emit('close');
    },
    handleMask: function handleMask() {
      if (this.maskClosable && this.mask) {
        this.close();
      }
    },
    handleWrapClick: function handleWrapClick(event) {
      // use indexOf,do not use === ,because bin-modal-wrap can have other custom className
      var className = event.target.getAttribute('class');
      if (className && className.indexOf(prefixCls$a + "-wrap") > -1) this.handleMask();
    },
    handleMousemove: function handleMousemove(event) {
      if (!this.canMove || !this.draggable) return; // 更新容器宽度和距离左侧页面距离，如果是window则距左侧距离为0

      this.handleSetWrapperWidth();
      var left = event.pageX - this.wrapperLeft; // 如果抽屉方向为右边，宽度计算需用容器宽度减去left

      var width = this.placement === 'right' ? this.wrapperWidth - left : left; // 限定最小宽度

      width = Math.max(width, parseFloat(this.minWidth));
      event.atMin = width === parseFloat(this.minWidth); // 如果当前width不大于100，视为百分比

      if (width <= 100) width = width / this.wrapperWidth * 100;
      this.dragWidth = width;
      this.$emit('resize-width', parseInt(this.dragWidth));
    },
    handleSetWrapperWidth: function handleSetWrapperWidth() {
      var _this$wrapRef$getBoun = this.wrapRef.getBoundingClientRect(),
          width = _this$wrapRef$getBoun.width,
          left = _this$wrapRef$getBoun.left;

      this.wrapperWidth = width;
      this.wrapperLeft = left;
    },
    handleMouseup: function handleMouseup() {
      if (!this.draggable) return;
      this.canMove = false;
    },
    handleTriggerMousedown: function handleTriggerMousedown() {
      this.canMove = true; // 防止鼠标选中抽屉中文字，造成拖动trigger触发浏览器原生拖动行为

      window.getSelection().removeAllRanges();
    }
  },
  mounted: function mounted() {
    if (this.visible) this.wrapShow = true;
    on$1(document, 'mousemove', this.handleMousemove);
    on$1(document, 'mouseup', this.handleMouseup);
    this.handleSetWrapperWidth();
  },
  beforeUnmount: function beforeUnmount() {
    off$1(document, 'mousemove', this.handleMousemove);
    off$1(document, 'mouseup', this.handleMouseup);
  }
};

var _hoisted_1$K = {
  class: "bin-drawer-root"
};

var _hoisted_2$v = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-close"
}, null, -1
/* HOISTED */
);

var _hoisted_3$l = {
  key: 1,
  class: "bin-drawer-header"
};
var _hoisted_4$g = {
  class: "bin-drawer-header-inner"
};
var _hoisted_5$e = {
  key: 2,
  class: "bin-drawer-footer"
};
var _hoisted_6$7 = {
  style: {
    "text-align": "right"
  }
};

var _hoisted_7$6 = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-drawer-drag-move-trigger"
}, [/*#__PURE__*/vue.createVNode("div", {
  class: "bin-drawer-drag-move-trigger-point"
}, [/*#__PURE__*/vue.createVNode("i"), /*#__PURE__*/vue.createVNode("i"), /*#__PURE__*/vue.createVNode("i"), /*#__PURE__*/vue.createVNode("i"), /*#__PURE__*/vue.createVNode("i")])], -1
/* HOISTED */
);

function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: "body",
    disabled: !$props.appendToBody
  }, [vue.createVNode("div", _hoisted_1$K, [vue.createVNode(vue.Transition, {
    name: "fade-in"
  }, {
    default: vue.withCtx(function () {
      return [$props.mask ? vue.withDirectives((vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: $options.maskClasses,
        style: $options.wrapStyles,
        onClick: _cache[1] || (_cache[1] = function () {
          return $options.handleMask && $options.handleMask.apply($options, arguments);
        })
      }, null, 6
      /* CLASS, STYLE */
      )), [[vue.vShow, $setup.visible]]) : vue.createCommentVNode("v-if", true)];
    }),
    _: 1
    /* STABLE */

  }), vue.createVNode("div", {
    class: $options.wrapClasses,
    style: $options.wrapStyles,
    ref: "wrapRef",
    onClick: _cache[5] || (_cache[5] = function () {
      return $options.handleWrapClick && $options.handleWrapClick.apply($options, arguments);
    })
  }, [vue.createVNode(vue.Transition, {
    name: 'move-' + $props.placement,
    onAfterLeave: _cache[4] || (_cache[4] = function ($event) {
      return $setup.wrapShow = false;
    })
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", {
        class: $options.classes,
        style: $options.mainStyles
      }, [vue.createVNode("div", {
        class: $options.contentClasses,
        ref: "content"
      }, [$props.showClose ? (vue.openBlock(), vue.createBlock("a", {
        key: 0,
        class: "bin-drawer-close",
        onClick: _cache[2] || (_cache[2] = function () {
          return $options.close && $options.close.apply($options, arguments);
        })
      }, [vue.renderSlot(_ctx.$slots, "close", {}, function () {
        return [_hoisted_2$v];
      })])) : vue.createCommentVNode("v-if", true), _ctx.$slots.header || $props.title ? (vue.openBlock(), vue.createBlock("div", _hoisted_3$l, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
        return [vue.createVNode("div", _hoisted_4$g, vue.toDisplayString($props.title), 1
        /* TEXT */
        )];
      })])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
        class: "bin-drawer-body",
        style: $props.styles
      }, [vue.renderSlot(_ctx.$slots, "default")], 4
      /* STYLE */
      ), _ctx.$slots.footer ? (vue.openBlock(), vue.createBlock("div", _hoisted_5$e, [vue.createVNode("div", _hoisted_6$7, [vue.renderSlot(_ctx.$slots, "footer")])])) : vue.createCommentVNode("v-if", true)], 2
      /* CLASS */
      ), $props.draggable ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: ["bin-drawer-drag", {
          'bin-drawer-drag-left': $props.placement === 'left'
        }],
        onMousedown: _cache[3] || (_cache[3] = function () {
          return $options.handleTriggerMousedown && $options.handleTriggerMousedown.apply($options, arguments);
        })
      }, [vue.renderSlot(_ctx.$slots, "trigger", {}, function () {
        return [_hoisted_7$6];
      })], 34
      /* CLASS, HYDRATE_EVENTS */
      )) : vue.createCommentVNode("v-if", true)], 6
      /* CLASS, STYLE */
      ), [[vue.vShow, $setup.visible]])];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["name"])], 6
  /* CLASS, STYLE */
  )])], 8
  /* PROPS */
  , ["disabled"]);
}

script$16.render = render$14;
script$16.__file = "src/components/drawer/drawer.vue";

script$16.install = function (app) {
  app.component(script$16.name, script$16);
};

/* eslint-disable no-unused-vars */
var CLOSE_EVENT = 'close';
var OPEN_EVENT = 'open';
var CLOSED_EVENT = 'closed';
var OPENED_EVENT = 'opened';
function useDialog (props, ctx, targetRef) {
  var visible = vue.ref(false);
  var closed = vue.ref(false);
  var dialogRef = vue.ref(null);
  var openTimer = vue.ref(null);
  var closeTimer = vue.ref(null);
  var rendered = vue.ref(false); // when desctroyOnClose is true, we initialize it as false vise versa

  var zIndex = vue.ref(props.zIndex || transferIncrease());
  var modalRef = vue.ref(null);
  var style = vue.computed(function () {
    var style = {};

    if (!props.fullscreen) {
      style.marginTop = props.top;

      if (props.width) {
        style.width = props.width;
      }
    }

    return style;
  });

  function afterEnter() {
    ctx.emit(OPENED_EVENT);
  }

  function afterLeave() {
    ctx.emit(CLOSED_EVENT);
    ctx.emit(UPDATE_MODEL_EVENT, false);

    if (props.destroyOnClose) {
      rendered.value = false;
    }
  }

  function beforeLeave() {
    ctx.emit(CLOSE_EVENT);
  }

  function open() {
    clearTimer$1(closeTimer);
    clearTimer$1(openTimer);

    if (props.openDelay && props.openDelay > 0) {
      openTimer.value = window.setTimeout(function () {
        openTimer.value = null;
        doOpen();
      }, props.openDelay);
    } else {
      doOpen();
    }
  }

  function close() {
    // if (this.willClose && !this.willClose()) return;
    clearTimer$1(openTimer);
    clearTimer$1(closeTimer);

    if (props.closeDelay && props.closeDelay > 0) {
      closeTimer.value = window.setTimeout(function () {
        closeTimer.value = null;
        doClose();
      }, props.closeDelay);
    } else {
      doClose();
    }
  }

  function hide(shouldCancel) {
    if (shouldCancel) return;
    closed.value = true;
    visible.value = false;
  }

  function handleClose() {
    if (props.beforeClose) {
      props.beforeClose(hide);
    } else {
      close();
    }
  }

  function onModalClick() {
    if (props.maskClosable) {
      handleClose();
    }
  }

  function doOpen() {
    if (isServer) {
      return;
    } // if (props.willOpen?.()) {
    //  return
    // }


    visible.value = true;
  }

  function doClose() {
    visible.value = false;
  }

  if (props.lockScroll) {
    useLockScreen(visible);
  }

  if (props.escClosable) {
    useModal({
      handleClose: handleClose
    }, visible);
  }

  useRestoreActive(visible);
  vue.watch(function () {
    return props.modelValue;
  }, function (val) {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true; // enables lazy rendering

      ctx.emit(OPEN_EVENT);
      zIndex.value = props.zIndex ? zIndex.value++ : transferIncrease(); // this.$el.addEventListener('scroll', this.updatePopper)

      vue.nextTick(function () {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      // this.$el.removeEventListener('scroll', this.updatePopper
      if (visible.value) {
        close();
      }
    }
  });
  vue.onMounted(function () {
    if (props.modelValue) {
      visible.value = true;
      rendered.value = true; // enables lazy rendering

      open();
    }
  });
  return {
    afterEnter: afterEnter,
    afterLeave: afterLeave,
    beforeLeave: beforeLeave,
    handleClose: handleClose,
    onModalClick: onModalClick,
    closed: closed,
    dialogRef: dialogRef,
    style: style,
    rendered: rendered,
    modalRef: modalRef,
    visible: visible,
    zIndex: zIndex
  };
}

var script$15 = {
  name: 'BMask',
  props: {
    mask: {
      type: Boolean,
      default: true
    },
    maskClass: [String, Array, Object],
    zIndex: Number
  },
  emits: ['click'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var mousedownTarget = false;
    var mouseupTarget = false; // refer to this https://javascript.info/mouse-events-basics
    // events fired in the order: mousedown -> mouseup -> click
    // we need to set the mousedown handle to false after click
    // fired.

    var onMaskClick = function onMaskClick(e) {
      if (mousedownTarget && mouseupTarget) {
        emit('click', e);
      }

      mousedownTarget = mouseupTarget = false;
    };

    var onMousedown = function onMousedown(e) {
      // marking current mousedown target.
      if (props.mask) {
        mousedownTarget = e.target === e.currentTarget;
      }
    };

    var onMouseup = function onMouseup(e) {
      if (props.mask) {
        mouseupTarget = e.target === e.currentTarget;
      }
    };

    return {
      onMaskClick: onMaskClick,
      onMousedown: onMousedown,
      onMouseup: onMouseup
    };
  }
};

function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.mask ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: ['bin-mask', $props.maskClass],
    style: {
      zIndex: $props.zIndex
    },
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.onMaskClick && $setup.onMaskClick.apply($setup, arguments);
    }),
    onMousedown: _cache[2] || (_cache[2] = function () {
      return $setup.onMousedown && $setup.onMousedown.apply($setup, arguments);
    }),
    onMouseup: _cache[3] || (_cache[3] = function () {
      return $setup.onMouseup && $setup.onMouseup.apply($setup, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "default")], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  )) : (vue.openBlock(), vue.createBlock("div", {
    key: 1,
    style: {
      zIndex: $props.zIndex,
      position: 'fixed',
      top: '0px',
      right: '0px',
      bottom: '0px',
      left: '0px'
    }
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  ));
}

script$15.render = render$13;
script$15.__file = "src/components/modal/mask.vue";

var supportsPassive = false;

try {
  var opts = Object.defineProperty({}, 'passive', {
    // eslint-disable-next-line getter-return
    get: function get() {
      supportsPassive = true;
    }
  });
  window.addEventListener('testPassive', null, opts);
  window.removeEventListener('testPassive', null, opts); // eslint-disable-next-line no-empty
} catch (e) {}

function addEventListenerWrap(target, eventType, cb, option) {
  if (target.addEventListener) {
    var opt = option;

    if (opt === undefined && supportsPassive && (eventType === 'touchstart' || eventType === 'touchmove' || eventType === 'wheel')) {
      opt = {
        passive: false
      };
    }

    target.addEventListener(eventType, cb, opt);
  }

  return {
    remove: function remove() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, cb);
      }
    }
  };
}

var mousePosition = null;

var getClickPosition = function getClickPosition(e) {
  mousePosition = {
    x: e.pageX,
    y: e.pageY
  }; // 100ms 内发生过点击事件，则从点击位置动画展示
  // 否则直接 zoom 展示
  // 这样可以兼容非点击方式展开

  setTimeout(function () {
    return mousePosition = null;
  }, 100);
}; // 只有点击事件支持从鼠标位置动画展开


if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
  addEventListenerWrap(document.documentElement, 'click', getClickPosition, true);
}

function getScroll(w, top) {
  var ret = w["page" + (top ? 'Y' : 'X') + "Offset"];
  var method = "scroll" + (top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document;
    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      ret = d.body[method];
    }
  }

  return ret;
}

function setTransformOrigin(node, value) {
  var style = node.style;
  ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
    style[prefix + "TransformOrigin"] = value;
  });
  style["transformOrigin"] = value;
}

function offset(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w, false);
  pos.top += getScroll(w, true);
  return pos;
}

var script$14 = {
  name: 'BModal',
  components: {
    BMask: script$15
  },
  props: {
    appendToBody: {
      type: Boolean,
      default: false
    },
    beforeClose: {
      type: Function
    },
    destroyOnClose: {
      type: Boolean,
      default: false
    },
    customClass: {
      type: String,
      default: ''
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    escClosable: {
      type: Boolean,
      default: true
    },
    fullscreen: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    mask: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ''
    },
    openDelay: {
      type: Number,
      default: 0
    },
    closeDelay: {
      type: Number,
      default: 0
    },
    top: {
      type: String,
      default: '100px'
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    maskClass: String,
    width: {
      type: String,
      default: '520px'
    },
    draggable: Boolean,
    zIndex: {
      type: Number
    },
    transitionName: {
      type: String
    }
  },
  emits: [OPEN_EVENT, OPENED_EVENT, CLOSE_EVENT, CLOSED_EVENT, UPDATE_MODEL_EVENT],
  setup: function setup(props, ctx) {
    var modalRef = vue.ref(null);

    var _toRefs = vue.toRefs(props),
        modelValue = _toRefs.modelValue,
        draggable = _toRefs.draggable,
        destroyOnClose = _toRefs.destroyOnClose;

    useModalDrag({
      visible: modelValue,
      destroyOnClose: destroyOnClose,
      draggable: draggable
    });

    var updateCallback = function updateCallback(visible) {
      if (props.modelValue) {
        // first show
        if (!visible) {
          var dialogNode = modalRef.value;
          var cusTransition = props.transitionName && props.transitionName !== 'dialog-fade';

          if (cusTransition) {
            setTransformOrigin(dialogNode, '');
            return;
          }

          if (mousePosition) {
            var elOffset = offset(dialogNode);
            setTransformOrigin(dialogNode, mousePosition.x - elOffset.left + "px " + (mousePosition.y - elOffset.top) + "px");
          } else {
            setTransformOrigin(dialogNode, '');
          }
        }
      }
    };

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      vue.nextTick(function () {
        updateCallback(!val);
      });
    });
    vue.onMounted(function () {
      vue.nextTick(function () {
        updateCallback(false);
      });
    });
    return _extends$2({}, useDialog(props, ctx, modalRef), {
      modalRef: modalRef
    });
  }
};

var _hoisted_1$J = {
  class: "bin-modal-close"
};
var _hoisted_2$u = {
  key: 0,
  class: "bin-modal-header"
};
var _hoisted_3$k = {
  class: "bin-modal-title"
};
var _hoisted_4$f = {
  key: 1,
  class: "bin-modal-body"
};
var _hoisted_5$d = {
  key: 2,
  class: "bin-modal-footer"
};
function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_mask = vue.resolveComponent("b-mask");

  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: "body",
    disabled: !$props.appendToBody
  }, [vue.createVNode(vue.Transition, {
    name: "modal-fade",
    onAfterEnter: _ctx.afterEnter,
    onAfterLeave: _ctx.afterLeave,
    onBeforeLeave: _ctx.beforeLeave
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode(_component_b_mask, {
        mask: $props.mask,
        "overlay-class": $props.maskClass,
        "z-index": $props.zIndex,
        onClick: _ctx.onModalClick
      }, {
        default: vue.withCtx(function () {
          return [vue.createVNode(vue.Transition, {
            name: $props.transitionName || 'dialog-fade'
          }, {
            default: vue.withCtx(function () {
              return [vue.withDirectives(vue.createVNode("div", {
                ref: "modalRef",
                class: ['bin-modal', {
                  'bin-modal-wrap': $props.draggable
                }, {
                  'is-fullscreen': $props.fullscreen
                }, $props.customClass],
                "aria-modal": "true",
                role: "dialog",
                "aria-label": $props.title || 'dialog',
                style: _ctx.style,
                onClick: _cache[2] || (_cache[2] = vue.withModifiers(function () {}, ["stop"]))
              }, [vue.createVNode("div", _hoisted_1$J, [vue.renderSlot(_ctx.$slots, "ctrl"), $props.showClose ? (vue.openBlock(), vue.createBlock("i", {
                key: 0,
                class: "b-iconfont b-icon-close",
                onClick: _cache[1] || (_cache[1] = function () {
                  return _ctx.handleClose && _ctx.handleClose.apply(_ctx, arguments);
                })
              })) : vue.createCommentVNode("v-if", true)]), _ctx.$slots.title || $props.title ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$u, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
                return [vue.createVNode("span", _hoisted_3$k, vue.toDisplayString($props.title), 1
                /* TEXT */
                )];
              })])) : vue.createCommentVNode("v-if", true), _ctx.rendered ? (vue.openBlock(), vue.createBlock("div", _hoisted_4$f, [vue.renderSlot(_ctx.$slots, "default")])) : vue.createCommentVNode("v-if", true), _ctx.$slots.footer ? (vue.openBlock(), vue.createBlock("div", _hoisted_5$d, [vue.renderSlot(_ctx.$slots, "footer")])) : vue.createCommentVNode("v-if", true)], 14
              /* CLASS, STYLE, PROPS */
              , ["aria-label"]), [[vue.vShow, _ctx.visible]])];
            }),
            _: 3
            /* FORWARDED */

          }, 8
          /* PROPS */
          , ["name"])];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["mask", "overlay-class", "z-index", "onClick"]), [[vue.vShow, _ctx.visible]])];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8
  /* PROPS */
  , ["disabled"]);
}

script$14.render = render$12;
script$14.__file = "src/components/modal/modal.vue";

script$14.install = function (app) {
  app.component(script$14.name, script$14);
};

var script$13 = {
  name: 'BCard',
  props: {
    header: {},
    bodyStyle: {},
    shadow: String,
    bordered: {
      type: Boolean,
      default: true
    },
    width: String,
    radius: String,
    bgColor: String,
    divider: String,
    headTip: Boolean
  },
  computed: {
    cardStyle: function cardStyle() {
      return {
        width: this.width,
        borderRadius: this.radius,
        backgroundColor: this.bgColor
      };
    }
  }
};

function render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-card", [$props.shadow ? 'is-' + $props.shadow + '-shadow' : 'is-hover-shadow', $props.bordered ? '' : 'is-no-border']],
    style: $options.cardStyle
  }, [_ctx.$slots.header || $props.header ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: ["bin-card__header", [$props.divider ? $props.divider + '-divider' : 'has-divider', $props.headTip ? 'has-tip' : '']]
  }, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.header), 1
    /* TEXT */
    )];
  })], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    class: "bin-card__body",
    style: $props.bodyStyle
  }, [vue.renderSlot(_ctx.$slots, "default")], 4
  /* STYLE */
  )], 6
  /* CLASS, STYLE */
  );
}

script$13.render = render$11;
script$13.__file = "src/components/card/card.vue";

script$13.install = function (app) {
  app.component(script$13.name, script$13);
};

var script$12 = {
  name: 'BBadge',
  props: {
    value: [String, Number],
    max: Number,
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,
      validator: function validator(val) {
        return ['primary', 'success', 'warning', 'info', 'danger'].includes(val);
      }
    }
  },
  computed: {
    content: function content() {
      if (this.isDot) return;
      var value = this.value;
      var max = this.max;

      if (typeof value === 'number' && typeof max === 'number') {
        return max < value ? max + "+" : value;
      }

      return value;
    }
  }
};

var _hoisted_1$I = {
  class: "bin-badge"
};
function render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$I, [vue.renderSlot(_ctx.$slots, "default"), vue.createVNode(vue.Transition, {
    name: "zoom-in-center"
  }, {
    default: vue.withCtx(function () {
      var _ref;

      return [vue.withDirectives(vue.createVNode("sup", {
        textContent: vue.toDisplayString($options.content),
        class: ["bin-badge__content", [(_ref = {}, _ref['bin-badge-is-' + $props.type] = $props.type, _ref), {
          'is-fixed': _ctx.$slots.default,
          'is-dot': $props.isDot
        }]]
      }, null, 10
      /* CLASS, PROPS */
      , ["textContent"]), [[vue.vShow, !$props.hidden && ($options.content || $options.content === 0 || $props.isDot)]])];
    }),
    _: 1
    /* STABLE */

  })]);
}

script$12.render = render$10;
script$12.__file = "src/components/badge/badge.vue";

script$12.install = function (app) {
  app.component(script$12.name, script$12);
};

var script$11 = {
  name: 'BCollapse',
  props: {
    accordion: Boolean,
    modelValue: {
      type: [Array, String, Number],
      default: function _default() {
        return [];
      }
    },
    simple: Boolean
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var activeNames = vue.ref([].concat(props.modelValue));
    var collapseMitt = mitt();

    var setActiveNames = function setActiveNames(_activeNames) {
      activeNames.value = [].concat(_activeNames);
      var value = props.accordion ? activeNames.value[0] : activeNames.value;
      emit(UPDATE_MODEL_EVENT, value);
      emit(CHANGE_EVENT, value);
    };

    var handleItemClick = function handleItemClick(name) {
      if (props.accordion) {
        setActiveNames((activeNames.value[0] || activeNames.value[0] === 0) && activeNames.value[0] === name ? '' : name);
      } else {
        var _activeNames = activeNames.value.slice(0);

        var index = _activeNames.indexOf(name);

        if (index > -1) {
          _activeNames.splice(index, 1);
        } else {
          _activeNames.push(name);
        }

        setActiveNames(_activeNames);
      }
    };

    vue.watch(function () {
      return props.modelValue;
    }, function () {
      activeNames.value = [].concat(props.modelValue);
    });
    collapseMitt.on('item-click', handleItemClick);
    vue.onUnmounted(function () {
      collapseMitt.all.clear();
    });
    vue.provide('collapse', {
      activeNames: activeNames,
      collapseMitt: collapseMitt
    });
    return {
      activeNames: activeNames,
      setActiveNames: setActiveNames,
      handleItemClick: handleItemClick
    };
  }
};

function render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-collapse', {
      'bin-collapse-simple': $props.simple
    }]
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$11.render = render$$;
script$11.__file = "src/components/collapse/collapse.vue";

script$11.install = function (app) {
  app.component(script$11.name, script$11);
};

var generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};
var script$10 = {
  name: 'BCollapsePanel',
  components: {
    BCollapseTransition: script$1u,
    BIcon: script$1I
  },
  props: {
    title: String,
    name: String,
    hideArrow: Boolean,
    disabled: Boolean
  },
  setup: function setup(props) {
    var collapse = vue.inject('collapse');
    var collapseMitt = collapse == null ? void 0 : collapse.collapseMitt;
    var contentWrapStyle = vue.ref({
      height: 'auto',
      display: 'block'
    });
    var contentHeight = vue.ref(0);
    var isClick = vue.ref(false);
    var id = vue.ref(generateId());
    var isActive = vue.computed(function () {
      return (collapse == null ? void 0 : collapse.activeNames.value.indexOf(props.name)) > -1;
    });

    var handleHeaderClick = function handleHeaderClick() {
      if (props.disabled) return;
      collapseMitt == null ? void 0 : collapseMitt.emit('item-click', props.name);
      isClick.value = true;
    };

    return {
      isActive: isActive,
      contentWrapStyle: contentWrapStyle,
      contentHeight: contentHeight,
      isClick: isClick,
      id: id,
      handleHeaderClick: handleHeaderClick,
      collapse: collapse
    };
  }
};

var _hoisted_1$H = {
  class: "bin-collapse-content"
};
var _hoisted_2$t = {
  class: "bin-collapse-content-box"
};
function render$_(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  var _component_b_collapse_transition = vue.resolveComponent("b-collapse-transition");

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-collapse-item', {
      'bin-collapse-item-active': $setup.isActive
    }]
  }, [vue.createVNode("div", {
    class: "bin-collapse-header",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleHeaderClick && $setup.handleHeaderClick.apply($setup, arguments);
    })
  }, [!$props.hideArrow ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
    key: 0,
    name: "right"
  })) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "title", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.title), 1
    /* TEXT */
    )];
  })]), vue.createVNode(_component_b_collapse_transition, null, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", _hoisted_1$H, [vue.createVNode("div", _hoisted_2$t, [vue.renderSlot(_ctx.$slots, "default")])], 512
      /* NEED_PATCH */
      ), [[vue.vShow, $setup.isActive]])];
    }),
    _: 3
    /* FORWARDED */

  })], 2
  /* CLASS */
  );
}

script$10.render = render$_;
script$10.__file = "src/components/collapse/panel.vue";

script$10.install = function (app) {
  app.component(script$10.name, script$10);
};

var script$$ = {
  name: 'BCollapseWrap',
  components: {
    BCollapseTransition: script$1u,
    BIcon: script$1I
  },
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    title: String,
    collapse: Boolean,
    shadow: String,
    arrowIcon: {
      type: String,
      default: 'down'
    }
  },
  emits: ['update:modelValue'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var data = vue.reactive({
      isActive: props.modelValue,
      mounted: false
    });
    var wrapStyle = vue.computed(function () {
      return {
        boxShadow: props.shadow
      };
    });
    var headerStyle = vue.computed(function () {
      return {
        boxShadow: props.shadow,
        borderBottom: props.shadow === 'none' ? '1px solid #eee' : null
      };
    });

    var toggle = function toggle() {
      // 可以收起且没有右侧功能插入时点击一行展开收起
      if (props.collapse && !slots.right) {
        data.isActive = !data.isActive;
        emit('update:modelValue', data.isActive);
      }
    };

    var arrowToggle = function arrowToggle() {
      // 可以收起且没有右侧功能插入时点击一行展开收起
      if (props.collapse && slots.right) {
        data.isActive = !data.isActive;
        emit('update:modelValue', data.isActive);
      }
    };

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      data.isActive = val;
    });
    vue.onMounted(function () {
      data.mounted = true;
    });
    return _extends$2({}, vue.toRefs(data), {
      wrapStyle: wrapStyle,
      headerStyle: headerStyle,
      toggle: toggle,
      arrowToggle: arrowToggle
    });
  }
};

var _hoisted_1$G = {
  class: "label"
};
var _hoisted_2$s = {
  class: "content"
};
var _hoisted_3$j = {
  class: "content-box"
};
function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  var _component_b_collapse_transition = vue.resolveComponent("b-collapse-transition");

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-collapse-wrap', {
      'bin-collapse-wrap-active': _ctx.isActive
    }],
    style: $setup.wrapStyle
  }, [vue.createVNode("div", {
    class: ["header", {
      'is-collapse': $props.collapse && !_ctx.$slots.right
    }],
    style: $setup.headerStyle,
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.toggle && $setup.toggle.apply($setup, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
    return [vue.createVNode("div", _hoisted_1$G, vue.toDisplayString($props.title), 1
    /* TEXT */
    )];
  }), _ctx.$slots.right ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: ["right", {
      'can-collapse': $props.collapse
    }]
  }, [vue.renderSlot(_ctx.$slots, "right", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.title), 1
    /* TEXT */
    )];
  })], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    class: "arrow",
    style: {
      cursor: _ctx.$slots.right ? 'pointer' : null
    },
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.arrowToggle && $setup.arrowToggle.apply($setup, arguments);
    })
  }, [$props.collapse ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
    key: 0,
    name: $props.arrowIcon
  }, null, 8
  /* PROPS */
  , ["name"])) : vue.createCommentVNode("v-if", true)], 4
  /* STYLE */
  )], 6
  /* CLASS, STYLE */
  ), _ctx.mounted ? (vue.openBlock(), vue.createBlock(_component_b_collapse_transition, {
    key: 0
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", _hoisted_2$s, [vue.createVNode("div", _hoisted_3$j, [vue.renderSlot(_ctx.$slots, "default")])], 512
      /* NEED_PATCH */
      ), [[vue.vShow, _ctx.isActive]])];
    }),
    _: 3
    /* FORWARDED */

  })) : vue.createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  );
}

script$$.render = render$Z;
script$$.__file = "src/components/collapse-wrap/wrapper.vue";

script$$.install = function (app) {
  app.component(script$$.name, script$$);
};

var script$_ = {
  props: {
    split: {
      validator: function validator(value) {
        return ['vertical', 'horizontal'].includes(value);
      },
      required: true
    },
    className: String
  }
};

function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-splitter-pane-resizer', $props.split, $props.className]
  }, null, 2
  /* CLASS */
  );
}

script$_.render = render$Y;
script$_.__file = "src/components/split/resizer.vue";

var script$Z = {
  name: 'Pane',
  props: {
    className: String,
    split: String
  },
  setup: function setup(props) {
    return {
      classes: [props.split, props.className],
      percent: 50
    };
  }
};

function render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.classes
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$Z.render = render$X;
script$Z.__file = "src/components/split/pane.vue";

var script$Y = {
  name: 'BSplit',
  components: {
    Resizer: script$_,
    Pane: script$Z
  },
  props: {
    minPercent: {
      type: Number,
      default: 10
    },
    defaultPercent: {
      type: Number,
      default: 20
    },
    split: {
      validator: function validator(value) {
        return ['vertical', 'horizontal'].includes(value);
      },
      default: 'vertical'
    },
    className: String
  },
  emits: ['resize'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var data = vue.reactive({
      active: false,
      hasMoved: false,
      height: null,
      percent: props.defaultPercent,
      type: props.split === 'vertical' ? 'width' : 'height',
      resizeType: props.split === 'vertical' ? 'left' : 'top'
    });

    var onClick = function onClick() {
      if (!data.hasMoved) {
        data.percent = props.defaultPercent;
        emit('resize', data.percent);
      }
    };

    var onMouseDown = function onMouseDown() {
      data.active = true;
      data.hasMoved = false;
    };

    var onMouseUp = function onMouseUp() {
      data.active = false;
    };

    var onMouseMove = function onMouseMove(e) {
      if (e.buttons === 0 || e.which === 0) {
        data.active = false;
      }

      if (data.active) {
        var offset = 0;
        var target = e.currentTarget;

        if (props.split === 'vertical') {
          while (target) {
            offset += target.offsetLeft;
            target = target.offsetParent;
          }
        } else {
          while (target) {
            offset += target.offsetTop;
            target = target.offsetParent;
          }
        }

        var currentPage = props.split === 'vertical' ? e.pageX : e.pageY;
        var targetOffset = props.split === 'vertical' ? e.currentTarget.offsetWidth : e.currentTarget.offsetHeight;
        var percent = Math.floor((currentPage - offset) / targetOffset * 10000) / 100;

        if (percent > props.minPercent && percent < 100 - props.minPercent) {
          data.percent = percent;
        }

        emit('resize', percent);
        data.hasMoved = true;
      }
    };

    return _extends$2({}, vue.toRefs(data), {
      onClick: onClick,
      onMouseDown: onMouseDown,
      onMouseUp: onMouseUp,
      onMouseMove: onMouseMove
    });
  }
};

function render$W(_ctx, _cache, $props, $setup, $data, $options) {
  var _style, _style2, _style3;

  var _component_pane = vue.resolveComponent("pane");

  var _component_resizer = vue.resolveComponent("resizer");

  return vue.openBlock(), vue.createBlock("div", {
    style: {
      cursor: _ctx.active ? 'col-resize' : '',
      userSelect: _ctx.active ? 'none' : ''
    },
    class: "bin-splitter-container clear-fix",
    onMouseup: _cache[1] || (_cache[1] = function () {
      return $setup.onMouseUp && $setup.onMouseUp.apply($setup, arguments);
    }),
    onMousemove: _cache[2] || (_cache[2] = function () {
      return $setup.onMouseMove && $setup.onMouseMove.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_pane, {
    class: "bin-splitter-pane splitter-left",
    split: $props.split,
    style: (_style = {}, _style[_ctx.type] = _ctx.percent + '%', _style)
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "left")];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["split", "style"]), vue.createVNode(_component_resizer, {
    className: $props.className,
    style: (_style2 = {}, _style2[_ctx.resizeType] = _ctx.percent + '%', _style2),
    split: $props.split,
    onMousedown: $setup.onMouseDown,
    onClick: $setup.onClick
  }, null, 8
  /* PROPS */
  , ["className", "style", "split", "onMousedown", "onClick"]), vue.createVNode(_component_pane, {
    class: "bin-splitter-pane splitter-right",
    split: $props.split,
    style: (_style3 = {}, _style3[_ctx.type] = 100 - _ctx.percent + '%', _style3)
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "right")];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["split", "style"])], 36
  /* STYLE, HYDRATE_EVENTS */
  );
}

script$Y.render = render$W;
script$Y.__file = "src/components/split/split.vue";

script$Y.install = function (app) {
  app.component(script$Y.name, script$Y);
};

var script$X = {
  name: 'BTag',
  props: {
    name: String,
    closable: Boolean,
    type: String,
    dot: Boolean,
    noBorder: Boolean,
    color: String,
    tagStyle: {},
    fontSize: String,
    dark: Boolean,
    checkable: Boolean,
    modelValue: {
      type: Boolean,
      default: true
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'click', 'close'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var checked = vue.ref(props.modelValue);

    var handleClose = function handleClose(e) {
      e.stopPropagation();
      emit('close', e);
    };

    var handleClick = function handleClick(e) {
      e.stopPropagation();

      if (props.checkable) {
        checked.value = !checked.value;
        emit(UPDATE_MODEL_EVENT, checked.value);
        emit(CHANGE_EVENT, checked.value, props.name);
      }

      emit('click', e);
    };

    var dotColor = vue.computed(function () {
      return props.type ? typeColor(props.type) : props.color;
    });
    var tagStyleBind = vue.computed(function () {
      return props.tagStyle ? props.tagStyle : props.dot ? {
        backgroundColor: 'transparent',
        color: props.color || 'rgba(0,0,0,.65)',
        fontSize: props.fontSize
      } : {
        backgroundColor: props.color,
        color: props.color ? '#fff' : '',
        fontSize: props.fontSize
      };
    });
    vue.watch(function () {
      return props.modelValue;
    }, function () {
      checked.value = !props.modelValue;
    });
    return {
      checked: checked,
      dotColor: dotColor,
      tagStyleBind: tagStyleBind,
      handleClose: handleClose,
      handleClick: handleClick
    };
  }
};

var _hoisted_1$F = {
  key: 0,
  class: "bin-dot"
};
function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("span", {
    class: ['bin-tag', $props.type ? "is-" + $props.type : '', $props.dark ? 'is-dark' : '', $props.dot ? 'is-dot' : '', $props.checkable ? 'is-checkable' : '', $props.checkable && $setup.checked ? 'is-checked' : '', {
      'no-border': $props.noBorder
    }],
    style: $setup.tagStyleBind,
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    })
  }, [$props.dot ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$F)) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default"), $props.closable ? (vue.openBlock(), vue.createBlock("i", {
    key: 1,
    class: "b-iconfont b-icon-close",
    style: $props.dot ? {
      backgroundColor: '#fff',
      color: $props.color
    } : {},
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClose && $setup.handleClose.apply($setup, arguments);
    })
  }, null, 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  );
}

script$X.render = render$V;
script$X.__file = "src/components/tag/tag.vue";

script$X.install = function (app) {
  app.component(script$X.name, script$X);
};

var prefixCls$9 = 'bin-circle';
var script$W = {
  name: 'BCircle',
  props: {
    percent: {
      type: Number,
      default: 0
    },
    size: {
      type: Number,
      default: 120
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeColor: {
      type: String,
      default: '#1089ff'
    },
    strokeLinecap: {
      validator: function validator(value) {
        return ['square', 'round'].includes(value);
      },
      default: 'round'
    },
    trailWidth: {
      type: Number,
      default: 5
    },
    trailColor: {
      type: String,
      default: '#eaeef2'
    },
    dashboard: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    circleSize: function circleSize() {
      return {
        width: this.size + "px",
        height: this.size + "px"
      };
    },
    computedStrokeWidth: function computedStrokeWidth() {
      return this.percent === 0 && this.dashboard ? 0 : this.strokeWidth;
    },
    radius: function radius() {
      return 50 - this.strokeWidth / 2;
    },
    pathString: function pathString() {
      if (this.dashboard) {
        return "M 50,50 m 0," + this.radius + "\n                    a " + this.radius + "," + this.radius + " 0 1 1 0,-" + 2 * this.radius + "\n                    a " + this.radius + "," + this.radius + " 0 1 1 0," + 2 * this.radius;
      } else {
        return "M 50,50 m 0,-" + this.radius + "\n                    a " + this.radius + "," + this.radius + " 0 1 1 0," + 2 * this.radius + "\n                    a " + this.radius + "," + this.radius + " 0 1 1 0,-" + 2 * this.radius;
      }
    },
    len: function len() {
      return Math.PI * 2 * this.radius;
    },
    trailStyle: function trailStyle() {
      var style = {};

      if (this.dashboard) {
        style = {
          'stroke-dasharray': this.len - 75 + "px " + this.len + "px",
          'stroke-dashoffset': "-" + 75 / 2 + "px",
          'transition': 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
        };
      }

      return style;
    },
    pathStyle: function pathStyle() {
      var style = {};

      if (this.dashboard) {
        style = {
          'stroke-dasharray': this.percent / 100 * (this.len - 75) + "px " + this.len + "px",
          'stroke-dashoffset': "-" + 75 / 2 + "px",
          'transition': 'stroke-dashoffset .3s ease 0s, stroke-dasharray .6s ease 0s, stroke .6s, stroke-width .06s ease .6s'
        };
      } else {
        style = {
          'stroke-dasharray': this.len + "px " + this.len + "px",
          'stroke-dashoffset': (100 - this.percent) / 100 * this.len + "px",
          'transition': 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
        };
      }

      return style;
    },
    wrapClasses: function wrapClasses() {
      return "" + prefixCls$9;
    },
    innerClasses: function innerClasses() {
      return prefixCls$9 + "-inner";
    }
  }
};

var _hoisted_1$E = {
  viewBox: "0 0 100 100"
};
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    style: $options.circleSize,
    class: $options.wrapClasses
  }, [(vue.openBlock(), vue.createBlock("svg", _hoisted_1$E, [vue.createVNode("path", {
    d: $options.pathString,
    stroke: $props.trailColor,
    "stroke-width": $props.trailWidth,
    "fill-opacity": 0,
    style: $options.trailStyle
  }, null, 12
  /* STYLE, PROPS */
  , ["d", "stroke", "stroke-width"]), vue.createVNode("path", {
    d: $options.pathString,
    "stroke-linecap": $props.strokeLinecap,
    stroke: $props.strokeColor,
    "stroke-width": $options.computedStrokeWidth,
    "fill-opacity": "0",
    style: $options.pathStyle
  }, null, 12
  /* STYLE, PROPS */
  , ["d", "stroke-linecap", "stroke", "stroke-width"])])), vue.createVNode("div", {
    class: $options.innerClasses
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  )], 6
  /* CLASS, STYLE */
  );
}

script$W.render = render$U;
script$W.__file = "src/components/circle/circle.vue";

script$W.install = function (app) {
  app.component(script$W.name, script$W);
};

var script$V = {
  name: 'BProgress',
  components: {
    BIcon: script$1I
  },
  props: {
    percent: {
      type: Number,
      default: 0,
      required: true,
      validator: function validator(val) {
        return val >= 0 && val <= 100;
      }
    },
    status: {
      type: String,
      validator: function validator(value) {
        return ['text', 'success', 'exception'].includes(value);
      }
    },
    strokeWidth: Number,
    textInside: Boolean,
    showText: {
      type: Boolean,
      default: true
    },
    bgColor: {
      type: String,
      default: ''
    },
    color: {
      type: String,
      default: ''
    },
    radius: String,
    active: Boolean
  },
  computed: {
    barOutStyle: function barOutStyle() {
      return {
        height: this.strokeWidth + 'px',
        borderRadius: this.radius,
        backgroundColor: this.bgColor
      };
    },
    barStyle: function barStyle() {
      return {
        width: this.percent + '%',
        backgroundColor: this.color,
        borderRadius: this.radius
      };
    },
    iconClass: function iconClass() {
      return this.status === 'success' ? 'check-circle' : 'close-circle';
    },
    progressTextSize: function progressTextSize() {
      var size = 12 + this.strokeWidth * 0.4;
      return size > 16 ? 16 : size;
    }
  }
};

var _hoisted_1$D = {
  key: 0,
  class: "bin-progress-bar__innerText"
};
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_icon = vue.resolveComponent("b-icon");

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-progress', $props.status ? 'progress-' + $props.status : '', {
      'bin-progress-text': !$props.showText,
      'bin-progress-text-inside': $props.textInside
    }],
    role: "progressbar",
    "aria-valuenow": $props.percent,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [vue.createVNode("div", {
    class: ["bin-progress-bar", {
      'is-active': $props.active
    }]
  }, [vue.createVNode("div", {
    class: "bin-progress-bar__outer",
    style: $options.barOutStyle
  }, [vue.createVNode("div", {
    class: "bin-progress-bar__inner",
    style: $options.barStyle
  }, [$props.showText && $props.textInside ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$D, vue.toDisplayString($props.percent) + "%", 1
  /* TEXT */
  )) : vue.createCommentVNode("v-if", true)], 4
  /* STYLE */
  )], 4
  /* STYLE */
  )], 2
  /* CLASS */
  ), $props.showText && !$props.textInside ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: "bin-progress__text",
    style: {
      fontSize: $options.progressTextSize + 'px'
    }
  }, [!$props.status ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.percent) + "%", 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 1
  }, [$props.status === 'text' ? vue.renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : (vue.openBlock(), vue.createBlock(_component_b_icon, {
    key: 1,
    name: $options.iconClass
  }, null, 8
  /* PROPS */
  , ["name"]))], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  ))], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["aria-valuenow"]);
}

script$V.render = render$T;
script$V.__file = "src/components/progress/progress.vue";

script$V.install = function (app) {
  app.component(script$V.name, script$V);
};

script$1D.install = function (app) {
  app.component(script$1D.name, script$1D);
};

function addNum(num1, num2) {
  var sq1, sq2, m;

  try {
    sq1 = num1.toString().split('.')[1].length;
  } catch (e) {
    sq1 = 0;
  }

  try {
    sq2 = num2.toString().split('.')[1].length;
  } catch (e) {
    sq2 = 0;
  }

  m = Math.pow(10, Math.max(sq1, sq2));
  return (Math.round(num1 * m) + Math.round(num2 * m)) / m;
}

var prefixCls$8 = 'bin-input-number';
var script$U = {
  name: 'BInputNumber',
  props: {
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    step: {
      type: Number,
      default: 1
    },
    activeChange: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Number,
      default: 1
    },
    size: {
      type: String,
      validator: function validator(val) {
        return ['', 'large', 'default', 'small', 'mini'].includes(val);
      },
      default: 'default'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    editable: {
      type: Boolean,
      default: true
    },
    name: {
      type: String
    },
    precision: {
      type: Number
    },
    elementId: {
      type: String
    },
    formatter: {
      type: Function
    },
    parser: {
      type: Function
    },
    placeholder: {
      type: String,
      default: ''
    },
    always: {
      type: Boolean
    }
  },
  emits: ['update:modelValue', 'change', 'input', 'blur', 'focus'],
  setup: function setup(props, ctx) {
    var _useForm = useForm(),
        BForm = _useForm.BForm,
        BFormItem = _useForm.BFormItem,
        formEmit = _useForm.formEmit;

    var inputDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var data = vue.reactive({
      currentValue: props.modelValue,
      focused: false,
      upDisabled: false,
      downDisabled: false
    });

    var preventDefault = function preventDefault(e) {
      e.preventDefault();
    };

    var up = function up(e) {
      var targetVal = Number(e.target.value);

      if (data.upDisabled && isNaN(targetVal)) {
        return false;
      }

      changeStep('up', e);
    };

    var down = function down(e) {
      var targetVal = Number(e.target.value);

      if (data.downDisabled && isNaN(targetVal)) {
        return false;
      }

      changeStep('down', e);
    };

    var focus = function focus(e) {
      data.focused = true;
      ctx.emit('focus', e);
    };

    var blur = function blur() {
      data.focused = false;
      ctx.emit('blur');
      vue.nextTick(function () {
        formEmit('blur', data.currentValue);
      });
    };

    var keyDown = function keyDown(e) {
      if (e.keyCode === 38) {
        e.preventDefault();
        up(e);
      } else if (e.keyCode === 40) {
        e.preventDefault();
        down(e);
      }
    };

    var change = function change(e) {
      var val = e.target.value.trim(); // 需要格式化数据时

      var needFormat = e.type === 'input' && props.activeChange || e.type === 'change' && !props.activeChange;

      if (needFormat) {
        if (e.type === 'input' && !props.activeChange) return;

        if (props.parser) {
          val = props.parser(val);
        }

        var isEmptyString = val.length === 0;

        if (isEmptyString) {
          setValue(null);
          return;
        } // eslint-disable-next-line no-useless-escape


        if (e.type === 'input' && val.match(/^\-?\.?$|\.$/)) return; // prevent fire early if decimal. If no more input the change e will fire later

        val = Number(val);

        if (!isNaN(val)) {
          data.currentValue = val;
          setValue(val);
        } else {
          e.target.value = data.currentValue;
        }
      }
    };

    function changeStep(type, e) {
      if (props.disabled || props.readonly) {
        return false;
      }

      var targetVal = Number(e.target.value);
      var val = Number(data.currentValue);
      var step = Number(props.step);

      if (isNaN(val)) {
        return false;
      } // input a number, and key up or down


      if (!isNaN(targetVal)) {
        if (type === 'up') {
          if (addNum(targetVal, step) <= props.max) {
            val = targetVal;
          } else {
            return false;
          }
        } else if (type === 'down') {
          if (addNum(targetVal, -step) >= props.min) {
            val = targetVal;
          } else {
            return false;
          }
        }
      }

      if (type === 'up') {
        val = addNum(val, step);
      } else if (type === 'down') {
        val = addNum(val, -step);
      }

      setValue(val);
    }

    function setValue(val) {
      // 如果 step 是小数，且没有设置 precision，是有问题的
      if (val && !isNaN(props.precision)) val = Number(Number(val).toFixed(props.precision));

      if (val !== null) {
        if (val > props.max) {
          val = props.max;
        } else if (val < props.min) {
          val = props.min;
        }
      }

      data.currentValue = val;
      ctx.emit('update:modelValue', val);
      ctx.emit('change', val);
      vue.nextTick(function () {
        formEmit('change', val);
      });
    }

    function changeVal(val) {
      val = Number(val);

      if (!isNaN(val)) {
        var step = props.step;
        data.upDisabled = val + step > props.max;
        data.downDisabled = val - step < props.min;
      } else {
        data.upDisabled = true;
        data.downDisabled = true;
      }
    }

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      data.currentValue = val;
      changeVal(val);
    });
    vue.watch(function () {
      return props.min;
    }, function () {
      changeVal(data.currentValue);
    });
    vue.watch(function () {
      return props.max;
    }, function () {
      changeVal(data.currentValue);
    });
    return _extends$2({
      BForm: BForm,
      BFormItem: BFormItem,
      formEmit: formEmit,
      inputDisabled: inputDisabled
    }, vue.toRefs(data), {
      preventDefault: preventDefault,
      up: up,
      down: down,
      focus: focus,
      blur: blur,
      keyDown: keyDown,
      change: change
    });
  },
  computed: {
    handlerClasses: function handlerClasses() {
      return prefixCls$8 + "-handler-wrap";
    },
    upClasses: function upClasses() {
      var _ref;

      return [prefixCls$8 + "-handler", prefixCls$8 + "-handler-up", (_ref = {}, _ref[prefixCls$8 + "-handler-up-disabled"] = this.upDisabled, _ref)];
    },
    plusClasses: function plusClasses() {
      var _ref2;

      return [prefixCls$8 + "-handler-plus", (_ref2 = {}, _ref2[prefixCls$8 + "-handler-plus-disabled"] = this.upDisabled, _ref2)];
    },
    innerUpClasses: function innerUpClasses() {
      return prefixCls$8 + "-handler-up-inner b-iconfont b-icon-up";
    },
    downClasses: function downClasses() {
      var _ref3;

      return [prefixCls$8 + "-handler", prefixCls$8 + "-handler-down", (_ref3 = {}, _ref3[prefixCls$8 + "-handler-down-disabled"] = this.downDisabled, _ref3)];
    },
    minusClasses: function minusClasses() {
      var _ref4;

      return [prefixCls$8 + "-handler-minus", (_ref4 = {}, _ref4[prefixCls$8 + "-handler-plus-minus"] = this.downDisabled, _ref4)];
    },
    innerDownClasses: function innerDownClasses() {
      return prefixCls$8 + "-handler-down-inner b-iconfont b-icon-down";
    },
    inputWrapClasses: function inputWrapClasses() {
      return prefixCls$8 + "-input-wrap";
    },
    inputClasses: function inputClasses() {
      return prefixCls$8 + "-input";
    },
    precisionValue: function precisionValue() {
      // can not display 1.0
      if (!this.currentValue) return this.currentValue;
      return this.precision ? this.currentValue.toFixed(this.precision) : this.currentValue;
    },
    formatterValue: function formatterValue() {
      if (this.formatter && this.precisionValue !== null) {
        return this.formatter(this.precisionValue);
      } else {
        return this.precisionValue;
      }
    }
  }
};

var _hoisted_1$C = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-minus"
}, null, -1
/* HOISTED */
);

var _hoisted_2$r = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-plus"
}, null, -1
/* HOISTED */
);

function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  var _ref;

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-input-number', (_ref = {}, _ref["bin-input-number-" + $props.size] = !!$props.size, _ref['bin-input-number-disabled'] = $setup.inputDisabled, _ref['bin-input-number-focused'] = _ctx.focused, _ref['bin-input-number-always'] = $props.always, _ref)]
  }, [$props.always ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createVNode("a", {
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.down && $setup.down.apply($setup, arguments);
    }),
    class: $options.minusClasses
  }, [_hoisted_1$C], 2
  /* CLASS */
  ), vue.createVNode("a", {
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.up && $setup.up.apply($setup, arguments);
    }),
    class: $options.plusClasses
  }, [_hoisted_2$r], 2
  /* CLASS */
  )], 64
  /* STABLE_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock("div", {
    key: 1,
    class: $options.handlerClasses
  }, [vue.createVNode("a", {
    onClick: _cache[4] || (_cache[4] = function () {
      return $setup.up && $setup.up.apply($setup, arguments);
    }),
    class: $options.upClasses
  }, [vue.createVNode("span", {
    class: $options.innerUpClasses,
    onClick: _cache[3] || (_cache[3] = function () {
      return $setup.preventDefault && $setup.preventDefault.apply($setup, arguments);
    })
  }, null, 2
  /* CLASS */
  )], 2
  /* CLASS */
  ), vue.createVNode("a", {
    onClick: _cache[6] || (_cache[6] = function () {
      return $setup.down && $setup.down.apply($setup, arguments);
    }),
    class: $options.downClasses
  }, [vue.createVNode("span", {
    class: $options.innerDownClasses,
    onClick: _cache[5] || (_cache[5] = function () {
      return $setup.preventDefault && $setup.preventDefault.apply($setup, arguments);
    })
  }, null, 2
  /* CLASS */
  )], 2
  /* CLASS */
  )], 2
  /* CLASS */
  )), vue.createVNode("div", {
    class: $options.inputWrapClasses
  }, [vue.createVNode("input", {
    id: $props.elementId,
    class: $options.inputClasses,
    disabled: $props.disabled,
    autocomplete: "off",
    spellcheck: "false",
    autofocus: $props.autofocus,
    onFocus: _cache[7] || (_cache[7] = function () {
      return $setup.focus && $setup.focus.apply($setup, arguments);
    }),
    onBlur: _cache[8] || (_cache[8] = function () {
      return $setup.blur && $setup.blur.apply($setup, arguments);
    }),
    onKeydown: _cache[9] || (_cache[9] = vue.withModifiers(function () {
      return $setup.keyDown && $setup.keyDown.apply($setup, arguments);
    }, ["stop"])),
    onInput: _cache[10] || (_cache[10] = function () {
      return $setup.change && $setup.change.apply($setup, arguments);
    }),
    onMouseup: _cache[11] || (_cache[11] = function () {
      return $setup.preventDefault && $setup.preventDefault.apply($setup, arguments);
    }),
    onChange: _cache[12] || (_cache[12] = function () {
      return $setup.change && $setup.change.apply($setup, arguments);
    }),
    readonly: $props.readonly || !$props.editable,
    name: $props.name,
    value: $options.formatterValue,
    placeholder: $props.placeholder
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , ["id", "disabled", "autofocus", "readonly", "name", "value", "placeholder"])], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$U.render = render$S;
script$U.__file = "src/components/input-number/input-number.vue";

script$U.install = function (app) {
  app.component(script$U.name, script$U);
};

var prefixCls$7 = 'bin-switch';
var script$T = {
  name: 'BSwitch',
  components: {
    BPopover: script$1s,
    BButton: script$1B
  },
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: false
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: true
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: false
    },
    disabled: Boolean,
    size: {
      validator: function validator(value) {
        return ['large', 'small', 'default', 'mini'].includes(value);
      },
      default: 'default'
    },
    name: String,
    activeColor: String,
    inactiveColor: String,
    confirm: Boolean,
    confirmTxt: String
  },
  emits: ['update:modelValue', 'change'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var currentValue = vue.ref(props.modelValue);
    var visible = vue.ref(false);

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        formEmit = _useForm.formEmit;

    var handleToggle = function handleToggle(e) {
      e.preventDefault();

      if (props.disabled) {
        return false;
      }

      var checked = currentValue.value === props.trueValue ? props.falseValue : props.trueValue;
      currentValue.value = checked;
      emit('update:modelValue', checked);
      emit('change', checked);
      formEmit('change', checked);
    };

    var toggle = function toggle(e) {
      if (!props.confirm) handleToggle(e);
    };

    var confirmFun = function confirmFun(e) {
      visible.value = false;
      handleToggle(e);
    };

    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      if (val !== props.trueValue && val !== props.falseValue) {
        console.log('Value should be true or false.');
      }

      currentValue.value = val;
    });
    return {
      visible: visible,
      currentValue: currentValue,
      toggle: toggle,
      confirmFun: confirmFun,
      BForm: BForm,
      formEmit: formEmit
    };
  },
  computed: {
    wrapClasses: function wrapClasses() {
      var _ref2;

      return ["" + prefixCls$7, (_ref2 = {}, _ref2[prefixCls$7 + "-checked"] = this.currentValue === this.trueValue, _ref2[prefixCls$7 + "-disabled"] = this.disabled || this.BForm.disabled, _ref2[prefixCls$7 + "-" + this.size] = !!this.size, _ref2)];
    },
    wrapStyle: function wrapStyle() {
      var isChecked = this.currentValue === this.trueValue;
      return {
        backgroundColor: isChecked ? this.activeColor : this.inactiveColor,
        borderColor: isChecked ? this.activeColor : this.inactiveColor
      };
    }
  }
};

var _hoisted_1$B = {
  class: "bin-switch-inner"
};

var _hoisted_2$q = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-question-circle",
  style: {
    "color": "#f5222d"
  }
}, null, -1
/* HOISTED */
);

var _hoisted_3$i = {
  style: {
    "text-align": "right",
    "margin": "0"
  }
};

var _hoisted_4$e = /*#__PURE__*/vue.createTextVNode("取消 ");

var _hoisted_5$c = /*#__PURE__*/vue.createTextVNode("确定 ");

function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_button = vue.resolveComponent("b-button");

  var _component_b_popover = vue.resolveComponent("b-popover");

  return vue.openBlock(), vue.createBlock(_component_b_popover, {
    visible: $setup.visible,
    "onUpdate:visible": _cache[5] || (_cache[5] = function ($event) {
      return $setup.visible = $event;
    }),
    width: 200,
    disabled: !$props.confirm
  }, {
    content: vue.withCtx(function () {
      return [vue.createVNode("p", null, [_hoisted_2$q, vue.createTextVNode(" " + vue.toDisplayString($props.confirmTxt || '确定切换吗？'), 1
      /* TEXT */
      )]), vue.createVNode("div", _hoisted_3$i, [vue.createVNode(_component_b_button, {
        size: "mini",
        type: "text",
        onClick: _cache[3] || (_cache[3] = function ($event) {
          return $setup.visible = false;
        })
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_4$e];
        }),
        _: 1
        /* STABLE */

      }), vue.createVNode(_component_b_button, {
        type: "primary",
        size: "mini",
        onClick: _cache[4] || (_cache[4] = function ($event) {
          return $setup.confirmFun($event);
        })
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_5$c];
        }),
        _: 1
        /* STABLE */

      })])];
    }),
    default: vue.withCtx(function () {
      return [vue.createVNode("span", {
        tabindex: "0",
        class: $options.wrapClasses,
        style: $options.wrapStyle,
        onClick: _cache[1] || (_cache[1] = function () {
          return $setup.toggle && $setup.toggle.apply($setup, arguments);
        }),
        onKeydown: _cache[2] || (_cache[2] = vue.withKeys(function () {
          return $setup.toggle && $setup.toggle.apply($setup, arguments);
        }, ["space"]))
      }, [vue.createVNode("input", {
        type: "hidden",
        name: $props.name,
        value: $setup.currentValue
      }, null, 8
      /* PROPS */
      , ["name", "value"]), vue.createVNode("span", _hoisted_1$B, [$setup.currentValue === $props.trueValue ? vue.renderSlot(_ctx.$slots, "open", {
        key: 0
      }) : vue.createCommentVNode("v-if", true), $setup.currentValue === $props.falseValue ? vue.renderSlot(_ctx.$slots, "close", {
        key: 1
      }) : vue.createCommentVNode("v-if", true)])], 38
      /* CLASS, STYLE, HYDRATE_EVENTS */
      )];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["visible", "disabled"]);
}

script$T.render = render$R;
script$T.__file = "src/components/switch/switch.vue";

script$T.install = function (app) {
  app.component(script$T.name, script$T);
};

var useCheckboxGroup = function useCheckboxGroup() {
  var _useForm = useForm(),
      BForm = _useForm.BForm,
      BFormItem = _useForm.BFormItem,
      formEmit = _useForm.formEmit;

  var checkboxGroup = vue.inject('CheckboxGroup', {});
  var isGroup = vue.computed(function () {
    return checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === 'BCheckboxGroup';
  });
  return {
    isGroup: isGroup,
    checkboxGroup: checkboxGroup,
    BForm: BForm,
    BFormItem: BFormItem,
    formEmit: formEmit
  };
};

var useModel = function useModel(props) {
  var selfModel = false;

  var _getCurrentInstance = vue.getCurrentInstance(),
      emit = _getCurrentInstance.emit;

  var _useCheckboxGroup = useCheckboxGroup(),
      isGroup = _useCheckboxGroup.isGroup,
      checkboxGroup = _useCheckboxGroup.checkboxGroup;

  var isLimitExceeded = vue.ref(false);
  var store = vue.computed(function () {
    var _checkboxGroup$modelV;

    return checkboxGroup ? (_checkboxGroup$modelV = checkboxGroup.modelValue) == null ? void 0 : _checkboxGroup$modelV.value : props.modelValue;
  });
  var model = vue.computed({
    get: function get() {
      var _props$modelValue;

      return isGroup.value ? store.value : (_props$modelValue = props.modelValue) != null ? _props$modelValue : selfModel;
    },
    set: function set(val) {
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = checkboxGroup.min !== undefined && val.length < checkboxGroup.min.value;
        isLimitExceeded.value = checkboxGroup.max !== undefined && val.length > checkboxGroup.max.value;
        isLimitExceeded.value === false && (checkboxGroup == null ? void 0 : checkboxGroup.changeEvent == null ? void 0 : checkboxGroup.changeEvent(val));
      } else {
        emit(UPDATE_MODEL_EVENT, val);
        selfModel = val;
      }
    }
  });
  return {
    model: model,
    isLimitExceeded: isLimitExceeded
  };
};

var useCheckboxStatus = function useCheckboxStatus(props, _ref) {
  var model = _ref.model;
  var focus = vue.ref(false);
  var isChecked = vue.computed(function () {
    var value = model.value;

    if (toTypeString(value) === '[object Boolean]') {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props.label);
    } else if (value !== null && value !== undefined) {
      return value === props.trueLabel;
    }

    return value;
  });
  return {
    isChecked: isChecked,
    focus: focus
  };
};

var useDisabled = function useDisabled(props, _ref2) {
  var model = _ref2.model,
      isChecked = _ref2.isChecked;

  var _useCheckboxGroup2 = useCheckboxGroup(),
      isGroup = _useCheckboxGroup2.isGroup,
      checkboxGroup = _useCheckboxGroup2.checkboxGroup,
      BForm = _useCheckboxGroup2.BForm;

  var isLimitDisabled = vue.computed(function () {
    var _checkboxGroup$max, _checkboxGroup$min;

    var max = (_checkboxGroup$max = checkboxGroup.max) == null ? void 0 : _checkboxGroup$max.value;
    var min = (_checkboxGroup$min = checkboxGroup.min) == null ? void 0 : _checkboxGroup$min.value;
    return !!(max || min) && model.value.length >= max && !isChecked.value || model.value.length <= min && isChecked.value;
  });
  var isDisabled = vue.computed(function () {
    var _checkboxGroup$disabl;

    var disabled = props.disabled || BForm.disabled;
    return isGroup.value ? ((_checkboxGroup$disabl = checkboxGroup.disabled) == null ? void 0 : _checkboxGroup$disabl.value) || disabled || isLimitDisabled.value : props.disabled || BForm.disabled;
  });
  return {
    isDisabled: isDisabled,
    isLimitDisabled: isLimitDisabled
  };
};

var setStoreValue = function setStoreValue(props, _ref3) {
  var model = _ref3.model;

  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props.label)) {
      model.value.push(props.label);
    } else {
      model.value = props.trueLabel || true;
    }
  }

  props.checked && addToStore();
};

var useEvent = function useEvent(props, _ref4) {
  var isLimitExceeded = _ref4.isLimitExceeded;

  var _useCheckboxGroup3 = useCheckboxGroup(),
      formEmit = _useCheckboxGroup3.formEmit;

  var _getCurrentInstance2 = vue.getCurrentInstance(),
      emit = _getCurrentInstance2.emit;

  function handleChange(e) {
    var _props$trueLabel, _props$falseLabel;

    if (isLimitExceeded.value) return;
    var target = e.target;
    var value = target.checked ? (_props$trueLabel = props.trueLabel) != null ? _props$trueLabel : true : (_props$falseLabel = props.falseLabel) != null ? _props$falseLabel : false;
    emit('change', value, e);
  }

  vue.watch(function () {
    return props.modelValue;
  }, function (val) {
    formEmit('change', [val]);
  });
  return {
    handleChange: handleChange
  };
};

var useCheckbox = function useCheckbox(props) {
  var _useModel = useModel(props),
      model = _useModel.model,
      isLimitExceeded = _useModel.isLimitExceeded;

  var _useCheckboxStatus = useCheckboxStatus(props, {
    model: model
  }),
      focus = _useCheckboxStatus.focus,
      isChecked = _useCheckboxStatus.isChecked;

  var _useDisabled = useDisabled(props, {
    model: model,
    isChecked: isChecked
  }),
      isDisabled = _useDisabled.isDisabled;

  var _useEvent = useEvent(props, {
    isLimitExceeded: isLimitExceeded
  }),
      handleChange = _useEvent.handleChange;

  setStoreValue(props, {
    model: model
  });
  return {
    isChecked: isChecked,
    isDisabled: isDisabled,
    model: model,
    handleChange: handleChange,
    focus: focus
  };
};

var script$S = {
  name: 'BCheckbox',
  props: {
    modelValue: {
      type: [Boolean, Number, String],
      default: function _default() {
        return undefined;
      }
    },
    label: {
      type: [Boolean, Number, String]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: undefined
    },
    trueLabel: {
      type: [String, Number],
      default: undefined
    },
    falseLabel: {
      type: [String, Number],
      default: undefined
    },
    id: {
      type: String,
      default: undefined
    },
    controls: {
      type: String,
      default: undefined
    }
  },
  emits: [UPDATE_MODEL_EVENT, 'change'],
  setup: function setup(props) {
    return useCheckbox(props);
  }
};

var _hoisted_1$A = /*#__PURE__*/vue.createVNode("span", {
  class: "bin-checkbox__inner"
}, null, -1
/* HOISTED */
);

var _hoisted_2$p = {
  key: 0,
  class: "bin-checkbox__label"
};
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("label", {
    id: $props.id,
    class: ["bin-checkbox", [{
      'is-disabled': _ctx.isDisabled
    }, {
      'is-checked': _ctx.isChecked
    }]],
    "aria-controls": $props.indeterminate ? $props.controls : null
  }, [vue.createVNode("span", {
    class: ["bin-checkbox__input", {
      'is-disabled': _ctx.isDisabled,
      'is-checked': _ctx.isChecked,
      'is-indeterminate': $props.indeterminate,
      'is-focus': _ctx.focus
    }],
    tabindex: $props.indeterminate ? 0 : false,
    role: $props.indeterminate ? 'checkbox' : false,
    "aria-checked": $props.indeterminate ? 'mixed' : false
  }, [_hoisted_1$A, $props.trueLabel || $props.falseLabel ? vue.withDirectives((vue.openBlock(), vue.createBlock("input", {
    key: 0,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return _ctx.model = $event;
    }),
    checked: _ctx.isChecked,
    class: "bin-checkbox__original",
    type: "checkbox",
    "aria-hidden": $props.indeterminate ? 'true' : 'false',
    name: $props.name,
    disabled: _ctx.isDisabled,
    "true-value": $props.trueLabel,
    "false-value": $props.falseLabel,
    onChange: _cache[2] || (_cache[2] = function () {
      return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
    }),
    onFocus: _cache[3] || (_cache[3] = function ($event) {
      return _ctx.focus = true;
    }),
    onBlur: _cache[4] || (_cache[4] = function ($event) {
      return _ctx.focus = false;
    })
  }, null, 40
  /* PROPS, HYDRATE_EVENTS */
  , ["checked", "aria-hidden", "name", "disabled", "true-value", "false-value"])), [[vue.vModelCheckbox, _ctx.model]]) : vue.withDirectives((vue.openBlock(), vue.createBlock("input", {
    key: 1,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = function ($event) {
      return _ctx.model = $event;
    }),
    class: "bin-checkbox__original",
    type: "checkbox",
    "aria-hidden": $props.indeterminate ? 'true' : 'false',
    disabled: _ctx.isDisabled,
    value: $props.label,
    name: $props.name,
    onChange: _cache[6] || (_cache[6] = function () {
      return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
    }),
    onFocus: _cache[7] || (_cache[7] = function ($event) {
      return _ctx.focus = true;
    }),
    onBlur: _cache[8] || (_cache[8] = function ($event) {
      return _ctx.focus = false;
    })
  }, null, 40
  /* PROPS, HYDRATE_EVENTS */
  , ["aria-hidden", "disabled", "value", "name"])), [[vue.vModelCheckbox, _ctx.model]])], 10
  /* CLASS, PROPS */
  , ["tabindex", "role", "aria-checked"]), _ctx.$slots.default || $props.label ? (vue.openBlock(), vue.createBlock("span", _hoisted_2$p, [vue.renderSlot(_ctx.$slots, "default"), !_ctx.$slots.default ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.label), 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)])) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["id", "aria-controls"]);
}

script$S.render = render$Q;
script$S.__file = "src/components/checkbox/checkbox.vue";

script$S.install = function (app) {
  app.component(script$S.name, script$S);
};

var script$R = {
  name: 'BCheckboxGroup',
  props: {
    modelValue: {
      type: [Object, Boolean, Array],
      default: function _default() {
        return undefined;
      }
    },
    disabled: Boolean,
    min: {
      type: Number,
      default: undefined
    },
    max: {
      type: Number,
      default: undefined
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT],
  setup: function setup(props, ctx) {
    var _useCheckboxGroup = useCheckboxGroup(),
        formEmit = _useCheckboxGroup.formEmit;

    var changeEvent = function changeEvent(value) {
      ctx.emit(UPDATE_MODEL_EVENT, value);
      vue.nextTick(function () {
        ctx.emit(CHANGE_EVENT, value);
      });
    };

    var modelValue = vue.computed({
      get: function get() {
        return props.modelValue;
      },
      set: function set(val) {
        changeEvent(val);
      }
    });
    vue.provide('CheckboxGroup', _extends$2({
      name: 'BCheckboxGroup',
      modelValue: modelValue
    }, vue.toRefs(props), {
      changeEvent: changeEvent
    }));
    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      formEmit('change', [val]);
    });
  }
};

var _hoisted_1$z = {
  class: "bin-checkbox-group",
  role: "group",
  "aria-label": "checkbox-group"
};
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$z, [vue.renderSlot(_ctx.$slots, "default")]);
}

script$R.render = render$P;
script$R.__file = "src/components/checkbox/checkbox-group.vue";

script$R.install = function (app) {
  app.component(script$R.name, script$R);
};

var useRadio = function useRadio() {
  var _useForm = useForm(),
      BForm = _useForm.BForm,
      BFormItem = _useForm.BFormItem,
      formEmit = _useForm.formEmit;

  var radioGroup = vue.inject('RadioGroup', {});
  var focus = vue.ref(false);
  var isGroup = vue.computed(function () {
    return (radioGroup == null ? void 0 : radioGroup.name) === 'BRadioGroup';
  });
  return {
    isGroup: isGroup,
    focus: focus,
    radioGroup: radioGroup,
    BForm: BForm,
    BFormItem: BFormItem,
    formEmit: formEmit
  };
};
var useRadioAttrs = function useRadioAttrs(props, _ref) {
  var isGroup = _ref.isGroup,
      radioGroup = _ref.radioGroup,
      BForm = _ref.BForm,
      model = _ref.model;
  var isDisabled = vue.computed(function () {
    return isGroup.value ? radioGroup.disabled || props.disabled || BForm.disabled : props.disabled || BForm.disabled;
  });
  var tabIndex = vue.computed(function () {
    return isDisabled.value || isGroup.value && model.value !== props.label ? -1 : 0;
  });
  return {
    isDisabled: isDisabled,
    tabIndex: tabIndex
  };
};

var script$Q = {
  name: 'BRadio',
  componentName: 'BRadio',
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: ''
    },
    label: {
      type: [Boolean, String, Number],
      default: ''
    },
    disabled: Boolean,
    name: {
      type: String,
      default: ''
    }
  },
  emits: [UPDATE_MODEL_EVENT, 'change'],
  setup: function setup(props, ctx) {
    var _useRadio = useRadio(),
        isGroup = _useRadio.isGroup,
        radioGroup = _useRadio.radioGroup,
        BForm = _useRadio.BForm,
        focus = _useRadio.focus;

    var radioRef = vue.ref();
    var model = vue.computed({
      get: function get() {
        return isGroup.value ? radioGroup.modelValue : props.modelValue;
      },
      set: function set(val) {
        if (isGroup.value) {
          radioGroup.changeEvent(val);
        } else {
          ctx.emit(UPDATE_MODEL_EVENT, val);
        }

        radioRef.value.checked = props.modelValue === props.label;
      }
    });

    var _useRadioAttrs = useRadioAttrs(props, {
      isGroup: isGroup,
      radioGroup: radioGroup,
      BForm: BForm,
      model: model
    }),
        tabIndex = _useRadioAttrs.tabIndex,
        isDisabled = _useRadioAttrs.isDisabled;

    function handleChange() {
      vue.nextTick(function () {
        ctx.emit('change', model.value);
      });
    }

    return {
      focus: focus,
      isGroup: isGroup,
      isDisabled: isDisabled,
      model: model,
      tabIndex: tabIndex,
      handleChange: handleChange,
      radioRef: radioRef
    };
  }
};

var _hoisted_1$y = /*#__PURE__*/vue.createVNode("span", {
  class: "bin-radio__inner"
}, null, -1
/* HOISTED */
);

function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("label", {
    class: ["bin-radio", {
      'is-disabled': $setup.isDisabled,
      'is-focus': $setup.focus,
      'is-checked': $setup.model === $props.label
    }],
    role: "radio",
    "aria-checked": $setup.model === $props.label,
    "aria-disabled": $setup.isDisabled,
    tabindex: $setup.tabIndex
  }, [vue.createVNode("span", {
    class: ["bin-radio__input", {
      'is-disabled': $setup.isDisabled,
      'is-checked': $setup.model === $props.label
    }]
  }, [_hoisted_1$y, vue.withDirectives(vue.createVNode("input", {
    ref: "radioRef",
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $setup.model = $event;
    }),
    class: "bin-radio__original",
    value: $props.label,
    type: "radio",
    "aria-hidden": "true",
    name: $props.name,
    disabled: $setup.isDisabled,
    tabindex: "-1",
    onFocus: _cache[2] || (_cache[2] = function ($event) {
      return $setup.focus = true;
    }),
    onBlur: _cache[3] || (_cache[3] = function ($event) {
      return $setup.focus = false;
    }),
    onChange: _cache[4] || (_cache[4] = function () {
      return $setup.handleChange && $setup.handleChange.apply($setup, arguments);
    })
  }, null, 40
  /* PROPS, HYDRATE_EVENTS */
  , ["value", "name", "disabled"]), [[vue.vModelRadio, $setup.model]])], 2
  /* CLASS */
  ), _ctx.$slots.default || $props.label ? (vue.openBlock(), vue.createBlock("span", {
    key: 0,
    class: "bin-radio__label",
    onKeydown: _cache[5] || (_cache[5] = vue.withModifiers(function () {}, ["stop"]))
  }, [vue.renderSlot(_ctx.$slots, "default"), !_ctx.$slots.default ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.label), 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)], 32
  /* HYDRATE_EVENTS */
  )) : vue.createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["aria-checked", "aria-disabled", "tabindex"]);
}

script$Q.render = render$O;
script$Q.__file = "src/components/radio/radio.vue";

script$Q.install = function (app) {
  app.component(script$Q.name, script$Q);
};

var script$P = {
  name: 'BRadioGroup',
  componentName: 'BRadioGroup',
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: ''
    },
    disabled: Boolean
  },
  emits: [UPDATE_MODEL_EVENT, 'change'],
  setup: function setup(props, ctx) {
    var radioGroup = vue.ref(null);

    var _useForm = useForm(),
        formEmit = _useForm.formEmit; // methods


    var changeEvent = function changeEvent(value) {
      ctx.emit(UPDATE_MODEL_EVENT, value);
      vue.nextTick(function () {
        ctx.emit('change', value);
      });
    };

    vue.provide('RadioGroup', vue.reactive(_extends$2({
      name: 'BRadioGroup'
    }, vue.toRefs(props), {
      changeEvent: changeEvent
    })));
    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      formEmit('change', [val]);
    });

    var handleKeydown = function handleKeydown(e) {
      // 左右上下按键 可以在radio组内切换不同选项
      var target = e.target;
      var className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]';
      var radios = radioGroup.value.querySelectorAll(className);
      var length = radios.length;
      var index = Array.from(radios).indexOf(target);
      var roleRadios = radioGroup.value.querySelectorAll('[role=radio]');
      var nextIndex = null;

      switch (e.code) {
        case EVENT_CODE.left:
        case EVENT_CODE.up:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index === 0 ? length - 1 : index - 1;
          break;

        case EVENT_CODE.right:
        case EVENT_CODE.down:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index === length - 1 ? 0 : index + 1;
          break;
      }

      if (nextIndex === null) return;
      roleRadios[nextIndex].click();
      roleRadios[nextIndex].focus();
    };

    vue.onMounted(function () {
      var radios = radioGroup.value.querySelectorAll('[type=radio]');
      var firstLabel = radios[0];

      if (!Array.from(radios).some(function (radio) {
        return radio.checked;
      }) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    });
    return {
      handleKeydown: handleKeydown,
      radioGroup: radioGroup
    };
  }
};

function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    ref: "radioGroup",
    class: "bin-radio-group",
    role: "radiogroup",
    onKeydown: _cache[1] || (_cache[1] = function () {
      return $setup.handleKeydown && $setup.handleKeydown.apply($setup, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "default")], 544
  /* HYDRATE_EVENTS, NEED_PATCH */
  );
}

script$P.render = render$N;
script$P.__file = "src/components/radio/radio-group.vue";

script$P.install = function (app) {
  app.component(script$P.name, script$P);
};

var Render = {
  name: 'RenderCell',
  functional: true,
  props: {
    render: Function,
    data: Object,
    node: Array
  },
  render: function render(ctx) {
    var params = {
      root: ctx.node[0],
      node: ctx.node[1],
      data: ctx.data
    };
    return ctx.render(params);
  }
};

var prefixCls$6 = 'bin-tree';
var script$O = {
  name: 'TreeNode',
  components: {
    CollapseTransition: script$1u,
    Render: Render,
    BCheckbox: script$S
  },
  props: {
    data: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    multiple: Boolean,
    childrenKey: {
      type: String,
      default: 'children'
    },
    showCheckbox: Boolean
  },
  setup: function setup(props) {
    var TreeInstance = vue.inject('BTreeRoot', {});
    var isParentRender = vue.computed(function () {
      return TreeInstance && TreeInstance.render;
    });
    var parentRender = vue.computed(function () {
      return TreeInstance.render || null;
    });
    var node = vue.computed(function () {
      return [TreeInstance.flatState, TreeInstance.flatState.find(function (item) {
        return item.nodeKey === props.data.nodeKey;
      })];
    });

    var handleExpand = function handleExpand() {
      var item = props.data;
      if (item.disabled) return;
      if (item.isLeaf) return; // async loading

      if (item[props.childrenKey].length === 0) {
        var tree = TreeInstance;

        if (tree && tree.loadData) {
          props.data.loading = true;
          tree.loadData(item, function (children) {
            props.data.loading = false;

            if (children.length) {
              props.data[props.childrenKey] = children;
              tree.updateTreeState();
              vue.nextTick(function () {
                return handleExpand();
              });
            }
          });
          return;
        }
      }

      if (item[props.childrenKey] && item[props.childrenKey].length) {
        props.data.expand = !props.data.expand;
        TreeInstance.handleToggle(props.data);
      }
    };

    var handleSelect = function handleSelect() {
      if (props.data.disabled) return;

      if (TreeInstance.showCheckbox && TreeInstance.checkDirectly) {
        handleCheck();
      } else {
        TreeInstance.handleSelect(props.data.nodeKey);
      }
    };

    var handleCheck = function handleCheck() {
      if (props.data.disabled) return;
      var changes = {
        checked: !props.data.checked && !props.data.indeterminate,
        nodeKey: props.data.nodeKey
      };
      TreeInstance.handleCheck(changes);
    };

    return {
      TreeInstance: TreeInstance,
      isParentRender: isParentRender,
      parentRender: parentRender,
      node: node,
      handleExpand: handleExpand,
      handleSelect: handleSelect,
      handleCheck: handleCheck
    };
  },
  computed: {
    classes: function classes() {
      return [prefixCls$6 + "-children"];
    },
    arrowClasses: function arrowClasses() {
      var _ref;

      return [prefixCls$6 + "-arrow", (_ref = {}, _ref[prefixCls$6 + "-arrow-disabled"] = this.data.disabled, _ref[prefixCls$6 + "-arrow-noop"] = this.data.isLeaf, _ref[prefixCls$6 + "-arrow-open"] = this.data.expand, _ref)];
    },
    titleClasses: function titleClasses() {
      var _ref2;

      return [prefixCls$6 + "-title", (_ref2 = {}, _ref2['is-selected'] = this.data.selected, _ref2)];
    },
    renderClasses: function renderClasses() {
      var _ref3;

      return [prefixCls$6 + "-render-title", (_ref3 = {}, _ref3['is-selected'] = this.data.selected, _ref3)];
    },
    showArrow: function showArrow() {
      return this.data[this.childrenKey] && this.data[this.childrenKey].length || 'loading' in this.data && !this.data.loading;
    },
    showLoading: function showLoading() {
      return 'loading' in this.data && this.data.loading;
    },
    isLeaf: function isLeaf() {
      return 'isLeaf' in this.data && this.data.isLeaf;
    },
    children: function children() {
      return this.data[this.childrenKey];
    }
  }
};

var _hoisted_1$x = {
  class: "bin-tree-children"
};
var _hoisted_2$o = {
  class: "bin-tree-node"
};
var _hoisted_3$h = {
  key: 0,
  class: "b-iconfont b-icon-caret-right"
};
var _hoisted_4$d = {
  key: 1,
  class: "b-iconfont b-icon-loading bin-load-loop"
};
var _hoisted_5$b = {
  class: "bin-tree-node-children"
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_checkbox = vue.resolveComponent("b-checkbox");

  var _component_render = vue.resolveComponent("render");

  var _component_tree_node = vue.resolveComponent("tree-node");

  var _component_collapse_transition = vue.resolveComponent("collapse-transition");

  return vue.openBlock(), vue.createBlock("ul", _hoisted_1$x, [vue.withDirectives(vue.createVNode("li", null, [vue.createVNode("div", _hoisted_2$o, [vue.createVNode("span", {
    class: $options.arrowClasses,
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleExpand && $setup.handleExpand.apply($setup, arguments);
    })
  }, [!$options.isLeaf ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [$options.showArrow ? (vue.openBlock(), vue.createBlock("i", _hoisted_3$h)) : vue.createCommentVNode("v-if", true), $options.showLoading ? (vue.openBlock(), vue.createBlock("i", _hoisted_4$d)) : vue.createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  ), $props.showCheckbox ? (vue.openBlock(), vue.createBlock(_component_b_checkbox, {
    key: 0,
    "model-value": $props.data.checked,
    indeterminate: $props.data.indeterminate,
    disabled: $props.data.disabled || $props.data.disableCheckbox,
    onChange: $setup.handleCheck
  }, null, 8
  /* PROPS */
  , ["model-value", "indeterminate", "disabled", "onChange"])) : vue.createCommentVNode("v-if", true), $props.data.render ? (vue.openBlock(), vue.createBlock("span", {
    key: 1,
    class: $options.renderClasses,
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.handleSelect && $setup.handleSelect.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_render, {
    render: $props.data.render,
    data: $props.data,
    node: $setup.node
  }, null, 8
  /* PROPS */
  , ["render", "data", "node"])], 2
  /* CLASS */
  )) : $setup.isParentRender ? (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    class: $options.renderClasses,
    onClick: _cache[3] || (_cache[3] = function () {
      return $setup.handleSelect && $setup.handleSelect.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_render, {
    render: $setup.parentRender,
    data: $props.data,
    node: $setup.node
  }, null, 8
  /* PROPS */
  , ["render", "data", "node"])], 2
  /* CLASS */
  )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 3
  }, [$props.data.display ? (vue.openBlock(), vue.createBlock("span", {
    key: 0,
    class: $options.titleClasses,
    onClick: _cache[4] || (_cache[4] = function () {
      return $setup.handleSelect && $setup.handleSelect.apply($setup, arguments);
    }),
    innerHTML: $props.data.display
  }, null, 10
  /* CLASS, PROPS */
  , ["innerHTML"])) : (vue.openBlock(), vue.createBlock("span", {
    key: 1,
    class: $options.titleClasses,
    onClick: _cache[5] || (_cache[5] = function () {
      return $setup.handleSelect && $setup.handleSelect.apply($setup, arguments);
    })
  }, vue.toDisplayString($props.data.title), 3
  /* TEXT, CLASS */
  ))], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  ))]), vue.createVNode(_component_collapse_transition, null, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", _hoisted_5$b, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($options.children, function (item, i) {
        return vue.openBlock(), vue.createBlock(_component_tree_node, {
          key: i,
          data: item,
          multiple: $props.multiple,
          "show-checkbox": $props.showCheckbox,
          "children-key": $props.childrenKey
        }, null, 8
        /* PROPS */
        , ["data", "multiple", "show-checkbox", "children-key"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))], 512
      /* NEED_PATCH */
      ), [[vue.vShow, $props.data.expand]])];
    }),
    _: 1
    /* STABLE */

  })], 512
  /* NEED_PATCH */
  ), [[vue.vShow, $props.data.visible]])]);
}

script$O.render = render$M;
script$O.__file = "src/components/tree/node.vue";

var script$N = {
  name: 'BTree',
  components: {
    TreeNode: script$O,
    BEmpty: script$1H
  },
  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    multiple: Boolean,
    showCheckbox: Boolean,
    checkStrictly: Boolean,
    // 当开启 showCheckbox 时，如果开启 checkDirectly，select 将强制转为 check 事件
    checkDirectly: Boolean,
    emptyText: {
      type: String,
      default: '暂无数据'
    },
    childrenKey: {
      type: String,
      default: 'children'
    },
    loadData: Function,
    render: Function,
    lockSelect: Boolean,
    defaultExpand: Boolean,
    filterNodeMethod: Function
  },
  emits: ['select-change', 'toggle-expand', 'check-change'],
  setup: function setup(props, ctx) {
    var states = vue.reactive({
      stateTree: props.data,
      flatState: compileFlatState(),
      query: ''
    });

    function compileFlatState() {
      // 每个结点都有一个关系父结点/子结点
      var keyCounter = 0;
      var childrenKey = props.childrenKey;
      var defaultExpand = props.defaultExpand;
      var flatTree = [];

      var flattenChildren = function flattenChildren(node, parent) {
        node['nodeKey'] = keyCounter++;

        if (typeof node.expand === 'undefined') {
          node['expand'] = defaultExpand;
        }

        if (typeof node.visible === 'undefined') {
          node['visible'] = true;
        }

        flatTree[node.nodeKey] = {
          node: node,
          nodeKey: node.nodeKey
        };

        if (typeof parent !== 'undefined') {
          flatTree[node.nodeKey].parent = parent.nodeKey;
          flatTree[parent.nodeKey][childrenKey].push(node.nodeKey);
        }

        if (node[childrenKey]) {
          flatTree[node.nodeKey][childrenKey] = [];
          node[childrenKey].forEach(function (child) {
            return flattenChildren(child, node);
          });
        }
      };

      props.data.forEach(function (rootNode) {
        flattenChildren(rootNode);
      });
      return flatTree;
    }

    function updateTreeUp(nodeKey) {
      var parentKey = states.flatState[nodeKey].parent;
      if (typeof parentKey === 'undefined' || props.checkStrictly) return;
      var node = states.flatState[nodeKey].node;
      var parent = states.flatState[parentKey].node;
      if (node.checked === parent.checked && node.indeterminate === parent.indeterminate) return; // no need to update upwards

      if (node.checked === true) {
        parent['checked'] = parent[props.childrenKey].every(function (node) {
          return node.checked;
        });
        parent['indeterminate'] = !parent.checked;
      } else {
        parent['checked'] = false;
        parent['indeterminate'] = parent[props.childrenKey].some(function (node) {
          return node.checked || node.indeterminate;
        });
      }

      updateTreeUp(parentKey);
    }

    function getCheckedNodes() {
      return states.flatState.filter(function (obj) {
        return obj.node.checked;
      }).map(function (obj) {
        return obj.node;
      });
    }

    function getSelectedNodes() {
      return states.flatState.filter(function (obj) {
        return obj.node.selected;
      }).map(function (obj) {
        return obj.node;
      });
    }

    function getCheckedAndIndeterminateNodes() {
      return states.flatState.filter(function (obj) {
        return obj.node.checked || obj.node.indeterminate;
      }).map(function (obj) {
        return obj.node;
      });
    }

    function collapseAll() {
      states.flatState.forEach(function (node) {
        node.node.expand = false;
      });
    }

    function expandAll() {
      states.flatState.forEach(function (node) {
        node.node.expand = true;
      });
    }

    function getMatchesNode(query) {
      return states.flatState.filter(function (obj) {
        return props.filterNodeMethod.call(obj.node, query, obj.node);
      });
    }

    function filter(query) {
      // 如果不存在则如果不存在判定函数则跳出
      if (!props.filterNodeMethod) return; // 获取匹配的拉平节点

      var matches = getMatchesNode(query); // 隐藏全部

      states.flatState.forEach(function (item) {
        item.node.visible = false;
        replaceDisplayTitle(item.node, query);

        if (query.length > 0) {
          item.node['expand'] = false;
        }
      }); // 再遍历一次匹配数组以及父级的开关tes

      matches.forEach(function (item) {
        item.node.visible = true;

        if (query.length > 0) {
          item.node['expand'] = true;
          replaceDisplayTitle(item.node, query);
        }

        var parentKey = item.parent; // 如果是第一层则直接跳过下面逻辑

        if (typeof parentKey === 'undefined') return;
        var parentNode = states.flatState[parentKey];

        do {
          parentNode.node.visible = true;

          if (query.length > 0) {
            parentNode.node['expand'] = true;
          }

          parentNode = states.flatState[parentNode.parent];
        } while (parentNode);
      });
    } // 替换节点文字


    function replaceDisplayTitle(node, query) {
      if (query) {
        node['display'] = node.title.replace(new RegExp(query, 'g'), "<span>" + query + "</span>");
      } else {
        delete node['display'];
      }
    }

    function updateTreeDown(node, changes) {
      if (changes === void 0) {
        changes = {};
      }

      if (props.checkStrictly) return;

      for (var key in changes) {
        node[key] = changes[key];
      }

      if (node[props.childrenKey]) {
        node[props.childrenKey].forEach(function (child) {
          updateTreeDown(child, changes);
        });
      }
    }

    function handleToggle(node) {
      ctx.emit('toggle-expand', node);
    }

    function rebuildTree() {
      // only called when `data` prop changes
      var checkedNodes = getCheckedNodes();
      checkedNodes.forEach(function (node) {
        updateTreeDown(node, {
          checked: true
        }); // propagate upwards

        var parentKey = states.flatState[node.nodeKey].parent;
        if (!parentKey && parentKey !== 0) return;
        var parent = states.flatState[parentKey].node;
        var childHasCheckSetter = typeof node.checked !== 'undefined' && node.checked;

        if (childHasCheckSetter && parent.checked !== node.checked) {
          updateTreeUp(node.nodeKey); // update tree upwards
        }
      });
    }

    function handleSelect(nodeKey) {
      if (props.lockSelect) {
        // 如果锁定选择，则不触发选中事件
        return;
      }

      var node = states.flatState[nodeKey].node;

      if (!props.multiple) {
        // reset previously selected node
        var currentSelectedKey = states.flatState.findIndex(function (obj) {
          return obj.node.selected;
        });

        if (currentSelectedKey >= 0 && currentSelectedKey !== nodeKey) {
          states.flatState[currentSelectedKey].node['selected'] = false;
        }
      }

      node['selected'] = !node.selected;
      ctx.emit('select-change', getSelectedNodes(), node);
    }

    function handleCheck(_ref) {
      var checked = _ref.checked,
          nodeKey = _ref.nodeKey;
      var node = states.flatState[nodeKey].node;
      node['checked'] = checked;
      node['indeterminate'] = false;
      updateTreeUp(nodeKey); // propagate up

      updateTreeDown(node, {
        checked: checked,
        indeterminate: false
      }); // reset `indeterminate` when going down

      ctx.emit('check-change', getCheckedNodes(), node);
    }

    function updateTreeState() {
      states.stateTree = props.data;
      states.flatState = compileFlatState();
      rebuildTree();
    }

    vue.watch(function () {
      return props.data;
    }, function () {
      updateTreeState();
    }, {
      deep: true
    });
    vue.provide('BTreeRoot', {
      loadData: props.loadData,
      showCheckbox: props.showCheckbox,
      checkDirectly: props.checkDirectly,
      render: props.render,
      flatState: states.flatState,
      handleToggle: handleToggle,
      handleSelect: handleSelect,
      handleCheck: handleCheck,
      updateTreeState: updateTreeState
    });
    rebuildTree();
    return _extends$2({}, vue.toRefs(states), {
      updateTreeUp: updateTreeUp,
      getCheckedNodes: getCheckedNodes,
      getSelectedNodes: getSelectedNodes,
      getCheckedAndIndeterminateNodes: getCheckedAndIndeterminateNodes,
      collapseAll: collapseAll,
      expandAll: expandAll,
      getMatchesNode: getMatchesNode,
      filter: filter,
      handleToggle: handleToggle,
      handleSelect: handleSelect,
      handleCheck: handleCheck,
      updateTreeState: updateTreeState
    });
  },
  computed: {
    isEmpty: function isEmpty() {
      var stateTree = this.stateTree;
      return !stateTree || stateTree.length === 0 || stateTree.every(function (_ref2) {
        var visible = _ref2.visible;
        return !visible;
      });
    }
  }
};

var _hoisted_1$w = {
  class: "bin-tree"
};
var _hoisted_2$n = {
  key: 1
};
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_tree_node = vue.resolveComponent("tree-node");

  var _component_b_empty = vue.resolveComponent("b-empty");

  return vue.openBlock(), vue.createBlock("div", _hoisted_1$w, [!$options.isEmpty ? (vue.openBlock(true), vue.createBlock(vue.Fragment, {
    key: 0
  }, vue.renderList(_ctx.stateTree, function (item, i) {
    return vue.openBlock(), vue.createBlock(_component_tree_node, {
      key: i,
      data: item,
      multiple: $props.multiple,
      "show-checkbox": $props.showCheckbox,
      "children-key": $props.childrenKey
    }, null, 8
    /* PROPS */
    , ["data", "multiple", "show-checkbox", "children-key"]);
  }), 128
  /* KEYED_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock("div", _hoisted_2$n, [vue.createVNode(_component_b_empty, {
    style: {
      "margin": "16px 0"
    }
  }, {
    default: vue.withCtx(function () {
      return [vue.createTextVNode(vue.toDisplayString($props.emptyText), 1
      /* TEXT */
      )];
    }),
    _: 1
    /* STABLE */

  })]))]);
}

script$N.render = render$L;
script$N.__file = "src/components/tree/tree.vue";

script$N.install = function (app) {
  app.component(script$N.name, script$N);
};

var prefixCls$5 = 'bin-tree';
var lastTime = 0;
var script$M = {
  name: 'BBigTree',
  components: {
    BEmpty: script$1H,
    BCheckbox: script$S
  },
  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    multiple: {
      type: Boolean,
      default: false
    },
    showCheckbox: {
      type: Boolean,
      default: false
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    // 当开启 showCheckbox 时，如果开启 checkDirectly，select 将强制转为 check 事件
    checkDirectly: {
      type: Boolean,
      default: false
    },
    emptyText: {
      type: String,
      default: '暂无数据'
    },
    childrenKey: {
      type: String,
      default: 'children'
    },
    lockSelect: {
      type: Boolean,
      default: false
    },
    timeout: {
      // 刷新频率
      type: Number,
      default: 17
    },
    defaultExpand: {
      type: Boolean
    },
    itemHeight: {
      type: Number,
      default: 28
    },
    visibleCount: {
      type: Number,
      default: 15
    },
    filterNodeMethod: {
      type: Function
    }
  },
  emits: ['update', 'select-change', 'check-change'],
  setup: function setup(props, ctx) {
    var scrollerRef = vue.ref(null);
    var states = vue.reactive({
      offset: 0,
      // translateY偏移量
      contentHeight: '0px',
      visibleData: [],
      flattenTree: compileFlatState()
    });

    function compileFlatState() {
      // 每个结点都有一个关系父结点/子结点
      var keyCounter = 0;
      var childrenKey = props.childrenKey;
      var defaultExpand = props.defaultExpand;

      var flatten = function flatten(list, level, parent) {
        if (level === void 0) {
          level = 1;
        }

        if (parent === void 0) {
          parent = null;
        }

        var arr = [];
        list.forEach(function (item) {
          item.level = level;
          item.nodeKey = keyCounter++;

          if (item.expand === undefined) {
            item.expand = defaultExpand;
          }

          if (item.visible === undefined) {
            item.visible = true;
          }

          if (!parent.visible || !parent.expand) {
            item.visible = false;
          }

          item.parent = parent;
          arr.push(item);

          if (item[childrenKey]) {
            arr.push.apply(arr, flatten(item[childrenKey], level + 1, item));
          }
        });
        return arr;
      };

      return flatten(props.data, 1, {
        level: 0,
        visible: true,
        expand: true,
        children: props.data
      });
    }

    function handleScroll() {
      var currentTime = +new Date();

      if (currentTime - lastTime > props.timeout) {
        updateVisibleData(scrollerRef == null ? void 0 : scrollerRef.value.scrollTop);
        lastTime = currentTime;
      }
    }

    function updateVisibleData(scrollTop) {
      if (scrollTop === void 0) {
        scrollTop = 0;
      }

      var start = Math.floor(scrollTop / props.itemHeight) - Math.floor(props.visibleCount / 2);
      start = start < 0 ? 0 : start;
      var end = start + props.visibleCount * 2;
      var allVisibleData = (states.flattenTree || []).filter(function (item) {
        return item.visible;
      });
      states.visibleData = allVisibleData.slice(start, end);
      states.offset = start * props.itemHeight;
    }

    function getContentHeight() {
      states.contentHeight = (states.flattenTree || []).filter(function (item) {
        return item.visible;
      }).length * props.itemHeight + 'px';
    }

    function getCheckedNodes() {
      return states.flattenTree.filter(function (obj) {
        return obj.selected;
      });
    }

    function getSelectedNodes() {
      return states.flattenTree.filter(function (obj) {
        return obj.checked;
      });
    }

    function getCheckedAndIndeterminateNodes() {
      return states.flattenTree.filter(function (obj) {
        return obj.checked || obj.indeterminate;
      });
    }

    function arrowClasses(node) {
      var _ref;

      return [prefixCls$5 + "-arrow", (_ref = {}, _ref[prefixCls$5 + "-arrow-disabled"] = node.disabled, _ref[prefixCls$5 + "-arrow-open"] = node.expand, _ref)];
    }

    function titleClasses(node) {
      var _ref2;

      return [prefixCls$5 + "-title", (_ref2 = {}, _ref2[prefixCls$5 + "-title-selected"] = node.selected, _ref2)];
    }

    function updateView() {
      getContentHeight();
      ctx.emit('update', props.data);
      handleScroll();
    }

    function handleExpand(node) {
      var isExpand = node.expand;

      if (isExpand) {
        collapse(node); // 折叠
      } else {
        expand(node); // 展开
      }

      updateView();
    }
    /* public API 折叠所有 */


    function collapseAll(level) {
      if (level === void 0) {
        level = 1;
      }

      states.flattenTree.forEach(function (node) {
        node.expand = false;

        if (node.level !== level) {
          node.visible = false;
        }
      });
      updateView();
    }
    /* public API 展开所有 */


    function expandAll() {
      states.flattenTree.forEach(function (node) {
        node.expand = true;
        node.visible = true;
      });
      updateView();
    } // 展开节点


    function expand(node) {
      node.expand = true;
      recursionVisible(node.children, true);
    } // 折叠节点


    function collapse(node) {
      node.expand = false;
      recursionVisible(node.children, false);
    } // 递归节点


    function recursionVisible(children, status) {
      children.forEach(function (node) {
        node.visible = status;

        if (!node.parent.visible || !node.parent.expand) {
          node.visible = false;
        }

        if (node.children) {
          recursionVisible(node.children, status);
        }
      });
    }

    function filter(query) {
      // 如果不存在则如果不存在判定函数则跳出
      if (!props.filterNodeMethod) return; // 获取匹配的拉平节点

      var matches = states.flattenTree.filter(function (obj) {
        return props.filterNodeMethod.call(obj, query, obj);
      }); // 隐藏全部

      states.flattenTree.forEach(function (item) {
        item.visible = false;
        replaceDisplayTitle(item, query);

        if (query.length > 0) {
          item['expand'] = true;
        }
      }); // 再遍历一次匹配数组以及父级的开关

      matches.forEach(function (item) {
        item.visible = true;

        if (query.length > 0) {
          item.expand = true;
          replaceDisplayTitle(item, query);
        } // 如果是第一层则直接跳过下面逻辑


        if (item.parent === undefined || item.parent.level === 1) return;
        var parentNode = item.parent;

        do {
          parentNode.visible = true;

          if (query.length > 0) {
            parentNode.expand = true;
          }

          parentNode = parentNode.parent;
        } while (parentNode && parentNode.level !== 0);
      });
    } // 替换节点文字


    function replaceDisplayTitle(node, query) {
      if (query) {
        node['display'] = node.title.replace(new RegExp(query, 'g'), "<span>" + query + "</span>");
      } else {
        delete node['display'];
      }
    }

    function handleSelect(node) {
      if (props.lockSelect) {
        // 如果锁定选择，则不触发选中事件
        return;
      }

      if (props.showCheckbox && props.checkDirectly) {
        handleCheck(node);
        return;
      }

      if (!props.multiple) {
        // reset previously selected node
        var currentSelectedKey = states.flattenTree.findIndex(function (obj) {
          return obj.selected;
        });

        if (currentSelectedKey >= 0 && currentSelectedKey !== node.nodeKey) {
          states.flattenTree[currentSelectedKey]['selected'] = false;
        }
      }

      node['selected'] = !node.selected;
      ctx.emit('select-change', getSelectedNodes(), node);
    }

    function handleCheck(node) {
      var checked = !node.checked && !node.indeterminate;
      node['checked'] = checked;
      node['indeterminate'] = false;
      updateTreeUp(node); // propagate up

      updateTreeDown(node, {
        checked: checked,
        indeterminate: false
      }); // reset `indeterminate` when going down

      ctx.emit('check-change', getCheckedNodes(), node);
    }

    function updateTreeDown(node, changes) {
      if (changes === void 0) {
        changes = {};
      }

      if (props.checkStrictly) return;

      for (var key in changes) {
        node[key] = changes[key];
      }

      if (node[props.childrenKey]) {
        node[props.childrenKey].forEach(function (child) {
          updateTreeDown(child, changes);
        });
      }
    }

    function updateTreeUp(node) {
      if (node.parent === undefined || node.level === 0 || props.checkStrictly) return;
      var parent = node.parent;
      if (node.checked === parent.checked && node.indeterminate === parent.indeterminate) return; // no need to update upwards

      if (node.checked === true) {
        parent['checked'] = parent[props.childrenKey].every(function (node) {
          return node.checked;
        });
        parent['indeterminate'] = !parent.checked;
      } else {
        parent['checked'] = false;
        parent['indeterminate'] = parent[props.childrenKey].some(function (node) {
          return node.checked || node.indeterminate;
        });
      }

      updateTreeUp(parent);
    }

    vue.onMounted(function () {
      updateView();
    });
    vue.onBeforeUnmount(function () {
      states.flattenTree = null;
    });
    vue.watch(function () {
      return props.data;
    }, function () {
      states.flattenTree = compileFlatState();
      updateView();
    });
    return _extends$2({
      scrollerRef: scrollerRef,
      prefixCls: prefixCls$5
    }, vue.toRefs(states), {
      compileFlatState: compileFlatState,
      updateView: updateView,
      handleScroll: handleScroll,
      getCheckedNodes: getCheckedNodes,
      getSelectedNodes: getSelectedNodes,
      getCheckedAndIndeterminateNodes: getCheckedAndIndeterminateNodes,
      titleClasses: titleClasses,
      arrowClasses: arrowClasses,
      handleExpand: handleExpand,
      expandAll: expandAll,
      collapseAll: collapseAll,
      collapse: collapse,
      expand: expand,
      recursionVisible: recursionVisible,
      updateTreeUp: updateTreeUp,
      updateTreeDown: updateTreeDown,
      filter: filter,
      handleSelect: handleSelect,
      handleCheck: handleCheck
    });
  },
  computed: {
    wrapStyle: function wrapStyle() {
      return {
        position: 'relative',
        overflow: 'auto',
        height: this.visibleCount * this.itemHeight + 'px'
      };
    },
    isEmpty: function isEmpty() {
      return this.visibleData.length === 0;
    }
  }
};

var _hoisted_1$v = {
  key: 0,
  class: "b-iconfont b-icon-caret-right"
};
var _hoisted_2$m = {
  key: 1
};
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_checkbox = vue.resolveComponent("b-checkbox");

  var _component_b_empty = vue.resolveComponent("b-empty");

  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.prefixCls,
    ref: "scrollerRef",
    style: $options.wrapStyle,
    onScroll: _cache[1] || (_cache[1] = function () {
      return $setup.handleScroll && $setup.handleScroll.apply($setup, arguments);
    })
  }, [!$options.isEmpty ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createVNode("div", {
    class: $setup.prefixCls + "-phantom",
    style: {
      height: _ctx.contentHeight
    }
  }, null, 6
  /* CLASS, STYLE */
  ), vue.createVNode("div", {
    class: $setup.prefixCls + "-content",
    style: {
      transform: "translateY(" + _ctx.offset + "px)"
    }
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.visibleData, function (node, index) {
    return vue.openBlock(), vue.createBlock("div", {
      key: node.id || index,
      class: $setup.prefixCls + "-node",
      style: {
        paddingLeft: 18 * (node.level - 1) + 'px',
        height: $props.itemHeight + 'px'
      }
    }, [vue.createVNode("div", {
      class: $setup.arrowClasses(node),
      onClick: function onClick($event) {
        return $setup.handleExpand(node);
      }
    }, [node[$props.childrenKey] && node[$props.childrenKey].length ? (vue.openBlock(), vue.createBlock("i", _hoisted_1$v)) : vue.createCommentVNode("v-if", true)], 10
    /* CLASS, PROPS */
    , ["onClick"]), $props.showCheckbox ? (vue.openBlock(), vue.createBlock(_component_b_checkbox, {
      key: 0,
      value: node.checked,
      indeterminate: node.indeterminate,
      disabled: node.disabled || node.disableCheckbox,
      onClick: vue.withModifiers(function ($event) {
        return $setup.handleCheck(node);
      }, ["prevent"])
    }, null, 8
    /* PROPS */
    , ["value", "indeterminate", "disabled", "onClick"])) : vue.createCommentVNode("v-if", true), node.display ? (vue.openBlock(), vue.createBlock("span", {
      key: 1,
      class: $setup.titleClasses(node),
      onClick: function onClick($event) {
        return $setup.handleSelect(node);
      },
      innerHTML: node.display
    }, null, 10
    /* CLASS, PROPS */
    , ["onClick", "innerHTML"])) : (vue.openBlock(), vue.createBlock("span", {
      key: 2,
      class: $setup.titleClasses(node),
      onClick: function onClick($event) {
        return $setup.handleSelect(node);
      }
    }, vue.toDisplayString(node.title), 11
    /* TEXT, CLASS, PROPS */
    , ["onClick"]))], 6
    /* CLASS, STYLE */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 6
  /* CLASS, STYLE */
  )], 64
  /* STABLE_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock("div", _hoisted_2$m, [vue.createVNode(_component_b_empty, {
    style: {
      "margin": "16px 0"
    }
  }, {
    default: vue.withCtx(function () {
      return [vue.createTextVNode(vue.toDisplayString($props.emptyText), 1
      /* TEXT */
      )];
    }),
    _: 1
    /* STABLE */

  })]))], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  );
}

script$M.render = render$K;
script$M.__file = "src/components/tree/big-tree.vue";

script$M.install = function (app) {
  app.component(script$M.name, script$M);
};

var BDescCell = {
  name: 'BDescCell',
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String
    },
    type: {
      type: String
    }
  },
  setup: function setup(props) {
    var descriptions = vue.inject('BDesc', {});
    var label = vue.computed(function () {
      var _props$cell, _props$cell$children, _props$cell2, _props$cell2$props;

      return ((_props$cell = props.cell) == null ? void 0 : (_props$cell$children = _props$cell.children) == null ? void 0 : _props$cell$children.label == null ? void 0 : _props$cell$children.label()) || ((_props$cell2 = props.cell) == null ? void 0 : (_props$cell2$props = _props$cell2.props) == null ? void 0 : _props$cell2$props.label);
    });
    var content = vue.computed(function () {
      var _props$cell3, _props$cell3$children;

      return (_props$cell3 = props.cell) == null ? void 0 : (_props$cell3$children = _props$cell3.children) == null ? void 0 : _props$cell3$children.default == null ? void 0 : _props$cell3$children.default();
    });
    var span = vue.computed(function () {
      var _props$cell4, _props$cell4$props;

      return ((_props$cell4 = props.cell) == null ? void 0 : (_props$cell4$props = _props$cell4.props) == null ? void 0 : _props$cell4$props.span) || 1;
    });
    var labelWidth = vue.computed(function () {
      return descriptions.labelWidth || 50 / descriptions.column;
    });
    var contentWidth = vue.computed(function () {
      var labelWidth = descriptions.labelWidth;
      var column = descriptions.column;
      return labelWidth ? (100 - column * labelWidth) / column : 50 / column;
    });
    return {
      descriptions: descriptions,
      label: label,
      content: content,
      span: span,
      labelWidth: labelWidth,
      contentWidth: contentWidth
    };
  },
  render: function render() {
    switch (this.type) {
      case 'label':
        return vue.h(this.tag, {
          class: ['bin-desc__label', {
            'is-bordered-label': this.descriptions.border
          }],
          style: {
            width: this.labelWidth + "%"
          },
          colSpan: 1
        }, this.label);

      case 'content':
        return vue.h(this.tag, {
          class: 'bin-desc__content',
          style: {
            width: this.span * this.contentWidth + "%"
          },
          colSpan: this.span * 2 - 1
        }, this.content);

      default:
        return vue.h('td', {
          colSpan: this.span,
          style: {
            width: this.span * (100 / this.descriptions.column) + "%"
          }
        }, [vue.h('span', {
          class: 'bin-desc__label'
        }, this.label), vue.h('span', {
          class: 'bin-desc__content'
        }, this.content)]);
    }
  }
};

var script$L = {
  name: 'BDescRow',
  components: {
    BDescCell: BDescCell
  },
  props: {
    row: {
      type: Array
    }
  },
  setup: function setup() {
    var descriptions = vue.inject('BDesc', {});
    return {
      descriptions: descriptions
    };
  }
};

function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_desc_cell = vue.resolveComponent("b-desc-cell");

  return vue.openBlock(), vue.createBlock("tr", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.row, function (cell, index) {
    return vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: "tr3-" + index
    }, [$setup.descriptions.border ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: 0
    }, [vue.createVNode(_component_b_desc_cell, {
      cell: cell,
      tag: "td",
      type: "label"
    }, null, 8
    /* PROPS */
    , ["cell"]), vue.createVNode(_component_b_desc_cell, {
      cell: cell,
      tag: "td",
      type: "content"
    }, null, 8
    /* PROPS */
    , ["cell"])], 64
    /* STABLE_FRAGMENT */
    )) : (vue.openBlock(), vue.createBlock(_component_b_desc_cell, {
      key: 1,
      cell: cell,
      tag: "td",
      type: "both"
    }, null, 8
    /* PROPS */
    , ["cell"]))], 64
    /* STABLE_FRAGMENT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))]);
}

script$L.render = render$J;
script$L.__file = "src/components/desc/descriptions-row.vue";

var script$K = {
  name: 'BDescItem'
};

script$K.__file = "src/components/desc-item/item.vue";

var _components;
var script$J = {
  name: 'BDesc',
  components: (_components = {
    BDescRow: script$L
  }, _components[script$K.name] = script$K, _components),
  props: {
    border: {
      type: Boolean,
      default: false
    },
    column: {
      type: Number,
      default: 3
    },
    labelWidth: {
      type: Number
    },
    size: {
      type: String,
      validator: function validator(val) {
        return ['large', 'default', 'small', 'mini'].includes(val);
      },
      default: 'default'
    },
    title: {
      type: String,
      default: ''
    },
    extra: {
      type: String,
      default: ''
    }
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots;
    vue.provide('BDesc', props);

    var flattedChildren = function flattedChildren(children) {
      var temp = Array.isArray(children) ? children : [children];
      var res = [];
      temp.forEach(function (child) {
        if (Array.isArray(child.children)) {
          res.push.apply(res, flattedChildren(child.children));
        } else {
          res.push(child);
        }
      });
      return res;
    };

    var filledNode = function filledNode(node, span, count, isLast) {
      if (isLast === void 0) {
        isLast = false;
      }

      if (!node.props) {
        node.props = {};
      }

      if (span > count) {
        node.props.span = count;
      }

      if (isLast) {
        // set the max span, cause of the last td
        node.props.span = props.column;
      }

      return node;
    };

    var rows = vue.computed(function () {
      var children = flattedChildren(slots.default == null ? void 0 : slots.default()).filter(function (node) {
        var _node$type;

        return (node == null ? void 0 : (_node$type = node.type) == null ? void 0 : _node$type.name) === 'BDescItem';
      });
      var rows = [];
      var temp = [];
      var count = props.column;
      children.forEach(function (node, index) {
        var _node$props;

        var span = ((_node$props = node.props) == null ? void 0 : _node$props.span) || 1;

        if (index === children.length - 1) {
          temp.push(filledNode(node, span, count, true));
          rows.push(temp);
          return;
        }

        if (span < count) {
          count -= span;
          temp.push(node);
        } else {
          temp.push(filledNode(node, span, count));
          rows.push(temp);
          count = props.column;
          temp = [];
        }
      });
      return rows;
    });
    return {
      rows: rows
    };
  }
};

var _hoisted_1$u = {
  class: "bin-desc"
};
var _hoisted_2$l = {
  key: 0,
  class: "bin-desc__header"
};
var _hoisted_3$g = {
  class: "bin-desc__title"
};
var _hoisted_4$c = {
  class: "bin-desc__extra"
};
var _hoisted_5$a = {
  class: "bin-desc__body"
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_desc_row = vue.resolveComponent("b-desc-row");

  return vue.openBlock(), vue.createBlock("div", _hoisted_1$u, [$props.title || $props.extra || _ctx.$slots.title || _ctx.$slots.extra ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$l, [vue.createVNode("div", _hoisted_3$g, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.title), 1
    /* TEXT */
    )];
  })]), vue.createVNode("div", _hoisted_4$c, [vue.renderSlot(_ctx.$slots, "extra", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString($props.extra), 1
    /* TEXT */
    )];
  })])])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_5$a, [vue.createVNode("table", {
    class: [{
      'is-bordered': $props.border
    }, $props.size ? "bin-desc--" + $props.size : '']
  }, [vue.createVNode("tbody", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.rows, function (row, index) {
    return vue.openBlock(), vue.createBlock(_component_b_desc_row, {
      key: index,
      row: row
    }, null, 8
    /* PROPS */
    , ["row"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])], 2
  /* CLASS */
  )])]);
}

script$J.render = render$I;
script$J.__file = "src/components/desc/desc.vue";

script$J.install = function (app) {
  app.component(script$J.name, script$J);
};

script$K.install = function (app) {
  app.component(script$K.name, script$K);
};

var script$I = {
  name: 'BRate',
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: Array,
      default: function _default() {
        return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
      }
    },
    voidColor: {
      type: String,
      default: '#C6D1DE'
    },
    disabledVoidColor: {
      type: String,
      default: '#EFF2F7'
    },
    iconClasses: {
      type: Array,
      default: function _default() {
        return ['star-fill', 'star-fill', 'star-fill'];
      }
    },
    voidIconClass: {
      type: String,
      default: 'star'
    },
    disabledVoidIconClass: {
      type: String,
      default: 'star-fill'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: false
    },
    showScore: {
      type: Boolean,
      default: false
    },
    textColor: {
      type: String,
      default: 'rgba(0,0,0,.65)'
    },
    texts: {
      type: Array,
      default: function _default() {
        return ['极差', '失望', '一般', '满意', '惊喜'];
      }
    },
    scoreTemplate: {
      type: String,
      default: '{value}'
    }
  },
  emits: ['update:modelValue', 'change'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var currentValue = vue.ref(props.modelValue);

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        formEmit = _useForm.formEmit;

    var rateDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var text = vue.computed(function () {
      var result = '';

      if (props.showScore) {
        result = props.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? "" + props.modelValue : "" + currentValue.value);
      } else if (props.showText) {
        result = props.texts[Math.ceil(currentValue.value) - 1];
      }

      return result;
    });

    function getValueFromMap(value, map) {
      var matchedKeys = Object.keys(map).filter(function (key) {
        var val = map[key];
        var excluded = isObject$2(val) ? val.excluded : false;
        return excluded ? value < key : value <= key;
      }).sort(function (a, b) {
        return a - b;
      });
      var matchedValue = map[matchedKeys[0]];
      return isObject$2(matchedValue) ? matchedValue.value : matchedValue || '';
    }

    var valueDecimal = vue.computed(function () {
      return props.modelValue * 100 - Math.floor(props.modelValue) * 100;
    });
    var colorMap = vue.computed(function () {
      var _ref2;

      return isArray$1(props.colors) ? (_ref2 = {}, _ref2[props.lowThreshold] = props.colors[0], _ref2[props.highThreshold] = {
        value: props.colors[1],
        excluded: true
      }, _ref2[props.max] = props.colors[2], _ref2) : props.colors;
    });
    var activeColor = vue.computed(function () {
      return getValueFromMap(currentValue.value, colorMap.value);
    });
    var decimalStyle = vue.computed(function () {
      var width = '';

      if (rateDisabled.value) {
        width = valueDecimal.value + "%";
      } else if (props.allowHalf) {
        width = '50%';
      }

      return {
        color: activeColor.value,
        width: width
      };
    });
    var classMap = vue.computed(function () {
      var _ref3;

      return isArray$1(props.iconClasses) ? (_ref3 = {}, _ref3[props.lowThreshold] = props.iconClasses[0], _ref3[props.highThreshold] = {
        value: props.iconClasses[1],
        excluded: true
      }, _ref3[props.max] = props.iconClasses[2], _ref3) : props.iconClasses;
    });
    var decimalIconClass = vue.computed(function () {
      return getValueFromMap(props.modelValue, classMap.value);
    });
    var voidClass = vue.computed(function () {
      return rateDisabled.value ? props.disabledVoidIconClass : props.voidIconClass;
    });
    var activeClass = vue.computed(function () {
      return getValueFromMap(currentValue.value, classMap.value);
    });
    var classes = vue.computed(function () {
      var result = Array(props.max);
      var threshold = currentValue.value; // if (props.allowHalf && currentValue.value !== Math.floor(currentValue.value)) {
      //   threshold--
      // }

      result.fill(activeClass.value, 0, threshold);
      result.fill(voidClass.value, threshold, props.max);
      return result;
    });
    var pointerAtLeftHalf = vue.ref(true);
    vue.watch(function () {
      return props.modelValue;
    }, function (val) {
      currentValue.value = val;
      pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
    });

    function showDecimalIcon(item) {
      var showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props.modelValue && item > props.modelValue;
      /* istanbul ignore next */

      var showWhenAllowHalf = props.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
      return showWhenDisabled || showWhenAllowHalf;
    }

    function getIconStyle(item) {
      var voidColor = rateDisabled.value ? props.disabledVoidColor : props.voidColor;
      return {
        color: item <= currentValue.value ? activeColor.value : voidColor
      };
    }

    function selectValue(value) {
      if (rateDisabled.value) {
        return;
      }

      if (props.allowHalf && pointerAtLeftHalf.value) {
        emit('update:modelValue', currentValue.value);
        emit('change', this.currentValue);
      } else {
        emit('update:modelValue', value);
        emit('change', value);
      }

      formEmit('change', value);
    }

    function handleKey(e) {
      if (rateDisabled.value) {
        return;
      }

      var _currentValue = currentValue.value;
      var code = e.code;

      if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
        if (props.allowHalf) {
          _currentValue += 0.5;
        } else {
          _currentValue += 1;
        }

        e.stopPropagation();
        e.preventDefault();
      } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
        if (props.allowHalf) {
          _currentValue -= 0.5;
        } else {
          _currentValue -= 1;
        }

        e.stopPropagation();
        e.preventDefault();
      }

      _currentValue = _currentValue < 0 ? 0 : _currentValue;
      _currentValue = _currentValue > props.max ? props.max : _currentValue;
      emit('update:modelValue', _currentValue);
      emit('change', _currentValue);
      return _currentValue;
    }

    var hoverIndex = vue.ref(-1);

    function setCurrentValue(value, event) {
      if (rateDisabled.value) {
        return;
      }
      /* istanbul ignore if */


      if (props.allowHalf) {
        var target = event.target;

        if (hasClass(target, 'bin-rate__item')) {
          target = target.querySelector('.bin-rate__icon');
        }

        if (hasClass(target, 'bin-rate__decimal')) {
          target = target.parentNode;
        }

        pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
        currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
      } else {
        currentValue.value = value;
      }

      hoverIndex.value = value;
    }

    function resetCurrentValue() {
      if (rateDisabled.value) {
        return;
      }

      if (props.allowHalf) {
        pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
      }

      currentValue.value = props.modelValue;
      hoverIndex.value = -1;
    }

    if (!props.modelValue) {
      emit('update:modelValue', 0);
    }

    return {
      hoverIndex: hoverIndex,
      currentValue: currentValue,
      rateDisabled: rateDisabled,
      text: text,
      decimalStyle: decimalStyle,
      decimalIconClass: decimalIconClass,
      classes: classes,
      showDecimalIcon: showDecimalIcon,
      getIconStyle: getIconStyle,
      selectValue: selectValue,
      handleKey: handleKey,
      setCurrentValue: setCurrentValue,
      resetCurrentValue: resetCurrentValue
    };
  }
};

function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: "bin-rate",
    onKeydown: _cache[2] || (_cache[2] = function () {
      return $setup.handleKey && $setup.handleKey.apply($setup, arguments);
    }),
    role: "slider",
    "aria-valuenow": $setup.currentValue,
    "aria-valuetext": $setup.text,
    "aria-valuemin": "0",
    "aria-valuemax": $props.max,
    tabindex: "0"
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.max, function (item, key) {
    return vue.openBlock(), vue.createBlock("span", {
      class: "bin-rate__item",
      onMousemove: function onMousemove($event) {
        return $setup.setCurrentValue(item, $event);
      },
      onMouseleave: _cache[1] || (_cache[1] = function () {
        return $setup.resetCurrentValue && $setup.resetCurrentValue.apply($setup, arguments);
      }),
      onClick: function onClick($event) {
        return $setup.selectValue(item);
      },
      style: {
        cursor: $setup.rateDisabled ? 'auto' : 'pointer'
      },
      key: key
    }, [vue.createVNode("i", {
      class: ["bin-rate__icon b-iconfont", ["b-icon-" + $setup.classes[item - 1], {
        hover: $setup.hoverIndex === item
      }]],
      style: $setup.getIconStyle(item)
    }, [$setup.showDecimalIcon(item) ? (vue.openBlock(), vue.createBlock("i", {
      key: 0,
      class: ["bin-rate__decimal b-iconfont", "b-icon-" + $setup.decimalIconClass],
      style: $setup.decimalStyle
    }, null, 6
    /* CLASS, STYLE */
    )) : vue.createCommentVNode("v-if", true)], 6
    /* CLASS, STYLE */
    )], 44
    /* STYLE, PROPS, HYDRATE_EVENTS */
    , ["onMousemove", "onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  )), $props.showText || $props.showScore ? (vue.openBlock(), vue.createBlock("span", {
    key: 0,
    class: "bin-rate__text",
    style: {
      color: $props.textColor
    }
  }, vue.toDisplayString($setup.text), 5
  /* TEXT, STYLE */
  )) : vue.createCommentVNode("v-if", true)], 40
  /* PROPS, HYDRATE_EVENTS */
  , ["aria-valuenow", "aria-valuetext", "aria-valuemax"]);
}

script$I.render = render$H;
script$I.__file = "src/components/rate/rate.vue";

script$I.install = function (app) {
  app.component(script$I.name, script$I);
};

function useOption(props, states) {
  // inject
  var select = vue.inject(selectKey);
  var selectGroup = vue.inject(selectGroupKey, {
    disabled: false
  }); // computed

  var isObject = vue.computed(function () {
    return Object.prototype.toString.call(props.value).toLowerCase() === '[object object]';
  });
  var itemSelected = vue.computed(function () {
    if (!select.props.multiple) {
      return isEqual(props.value, select.props.modelValue);
    } else {
      return contains(select.props.modelValue, props.value);
    }
  });
  var limitReached = vue.computed(function () {
    if (select.props.multiple) {
      var modelValue = select.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  var currentLabel = vue.computed(function () {
    return props.label || (isObject.value ? '' : props.value);
  });
  var currentValue = vue.computed(function () {
    return props.value || props.label || '';
  });
  var isDisabled = vue.computed(function () {
    return props.disabled || states.groupDisabled || limitReached.value;
  });
  var instance = vue.getCurrentInstance();

  var contains = function contains(arr, target) {
    if (arr === void 0) {
      arr = [];
    }

    if (!isObject.value) {
      return arr && arr.indexOf(target) > -1;
    } else {
      var valueKey = select.props.valueKey;
      return arr && arr.some(function (item) {
        return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
      });
    }
  };

  var isEqual = function isEqual(a, b) {
    if (!isObject.value) {
      return a === b;
    } else {
      var valueKey = select.props.valueKey;
      return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
    }
  };

  var hoverItem = function hoverItem() {
    if (!props.disabled && !selectGroup.disabled) {
      select.hoverIndex = select.optionsArray.indexOf(instance);
    }
  };

  var queryChange = function queryChange(query) {
    var regexp = new RegExp(escapeRegexpString(query), 'i');
    states.visible = regexp.test(currentLabel.value) || props.created;

    if (!states.visible) {
      select.filteredOptionsCount--;
    }
  };

  vue.watch(function () {
    return currentLabel.value;
  }, function () {
    if (!props.created && !select.props.remote) select.setSelected();
  });
  vue.watch(function () {
    return props.value;
  }, function (val, oldVal) {
    var _select$props = select.props,
        remote = _select$props.remote,
        valueKey = _select$props.valueKey;

    if (!props.created && !remote) {
      if (valueKey && typeof val === 'object' && typeof oldVal === 'object' && val[valueKey] === oldVal[valueKey]) {
        return;
      }

      select.setSelected();
    }
  });
  vue.watch(function () {
    return selectGroup.disabled;
  }, function () {
    states.groupDisabled = selectGroup.disabled;
  }, {
    immediate: true
  }); // Emitter

  select.selectEmitter.on(selectEvents.queryChange, queryChange);
  return {
    select: select,
    currentLabel: currentLabel,
    currentValue: currentValue,
    itemSelected: itemSelected,
    isDisabled: isDisabled,
    hoverItem: hoverItem
  };
}

var script$H = {
  name: 'BOption',
  componentName: 'BOption',
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props) {
    var states = vue.reactive({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });

    var _useOption = useOption(props, states),
        currentLabel = _useOption.currentLabel,
        itemSelected = _useOption.itemSelected,
        isDisabled = _useOption.isDisabled,
        select = _useOption.select,
        hoverItem = _useOption.hoverItem;

    var _toRefs = vue.toRefs(states),
        visible = _toRefs.visible,
        hover = _toRefs.hover;

    var vm = vue.getCurrentInstance().proxy;
    select.onOptionCreate(vm);
    vue.onBeforeUnmount(function () {
      var selected = select.selected;
      var selectedOptions = select.props.multiple ? selected : [selected];
      var doesExist = select.cachedOptions.has(props.value);
      var doesSelected = selectedOptions.some(function (item) {
        return item.value === vm.value;
      }); // if option is not selected, remove it from cache

      if (doesExist && !doesSelected) {
        select.cachedOptions.delete(props.value);
      }

      select.onOptionDestroy(props.value);
    });

    function selectOptionClick() {
      if (props.disabled !== true && states.groupDisabled !== true) {
        select.handleOptionSelect(vm, true);
      }
    }

    return {
      currentLabel: currentLabel,
      itemSelected: itemSelected,
      isDisabled: isDisabled,
      select: select,
      hoverItem: hoverItem,
      visible: visible,
      hover: hover,
      selectOptionClick: selectOptionClick
    };
  }
};

function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createBlock("li", {
    class: ["bin-select-dropdown__item", {
      'selected': $setup.itemSelected,
      'is-disabled': $setup.isDisabled,
      'hover': $setup.hover
    }],
    onMouseenter: _cache[1] || (_cache[1] = function () {
      return $setup.hoverItem && $setup.hoverItem.apply($setup, arguments);
    }),
    onClick: _cache[2] || (_cache[2] = vue.withModifiers(function () {
      return $setup.selectOptionClick && $setup.selectOptionClick.apply($setup, arguments);
    }, ["stop"]))
  }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
    return [vue.createVNode("span", null, vue.toDisplayString($setup.currentLabel), 1
    /* TEXT */
    )];
  })], 34
  /* CLASS, HYDRATE_EVENTS */
  )), [[vue.vShow, $setup.visible]]);
}

script$H.render = render$G;
script$H.__file = "src/components/select/option.vue";

var script$G = {
  name: 'BSelectDropdown',
  componentName: 'BSelectDropdown',
  setup: function setup() {
    var select = vue.inject(selectKey); // computed

    var popperClass = vue.computed(function () {
      return select.props.popperClass;
    });
    var isMultiple = vue.computed(function () {
      return select.props.multiple;
    });
    var minWidth = vue.ref('');

    function updateMinWidth() {
      var _select$selectWrapper;

      minWidth.value = ((_select$selectWrapper = select.selectWrapper) == null ? void 0 : _select$selectWrapper.getBoundingClientRect().width) + 'px';
    }

    vue.onMounted(function () {
      // TODO: updatePopper
      // popper.md.value.update()
      addResizeListener(select.selectWrapper, updateMinWidth);
    });
    vue.onBeforeUnmount(function () {
      removeResizeListener(select.selectWrapper, updateMinWidth);
    });
    return {
      minWidth: minWidth,
      popperClass: popperClass,
      isMultiple: isMultiple
    };
  }
};

function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-select-dropdown", [{
      'is-multiple': $setup.isMultiple
    }, $setup.popperClass]],
    style: {
      minWidth: $setup.minWidth
    }
  }, [vue.renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  );
}

script$G.render = render$F;
script$G.__file = "src/components/select/select-dropdown.vue";

var script$F = {
  name: 'BSelect',
  componentName: 'BSelect',
  components: {
    BInput: script$1D,
    BSelectMenu: script$G,
    BOption: script$H,
    BTag: script$X,
    BScrollbar: script$1C,
    BPopper: script$1F
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    name: String,
    id: String,
    modelValue: [Array, String, Number, Boolean, Object],
    autocomplete: {
      type: String,
      default: 'off'
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: function validator(value) {
        return ['small', 'large', 'default', 'mini'].includes(value);
      },
      default: 'default'
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ''
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: 'value'
    },
    collapseTags: Boolean,
    appendToBody: {
      type: Boolean
    },
    clearIcon: {
      type: String,
      default: 'close-circle-fill'
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'remove-tag', 'clear', 'visible-change', 'focus', 'blur'],
  setup: function setup(props, ctx) {
    var states = useSelectStates(props);

    var _useSelect = useSelect(props, states, ctx),
        optionsArray = _useSelect.optionsArray,
        selectSize = _useSelect.selectSize,
        readonly = _useSelect.readonly,
        handleResize = _useSelect.handleResize,
        collapseTagSize = _useSelect.collapseTagSize,
        debouncedOnInputChange = _useSelect.debouncedOnInputChange,
        debouncedQueryChange = _useSelect.debouncedQueryChange,
        deletePrevTag = _useSelect.deletePrevTag,
        deleteTag = _useSelect.deleteTag,
        deleteSelected = _useSelect.deleteSelected,
        handleOptionSelect = _useSelect.handleOptionSelect,
        scrollToOption = _useSelect.scrollToOption,
        setSelected = _useSelect.setSelected,
        resetInputHeight = _useSelect.resetInputHeight,
        managePlaceholder = _useSelect.managePlaceholder,
        showClose = _useSelect.showClose,
        selectDisabled = _useSelect.selectDisabled,
        iconClass = _useSelect.iconClass,
        showNewOption = _useSelect.showNewOption,
        emptyText = _useSelect.emptyText,
        toggleLastOptionHitState = _useSelect.toggleLastOptionHitState,
        resetInputState = _useSelect.resetInputState,
        handleComposition = _useSelect.handleComposition,
        onOptionCreate = _useSelect.onOptionCreate,
        onOptionDestroy = _useSelect.onOptionDestroy,
        handleMenuEnter = _useSelect.handleMenuEnter,
        handleFocus = _useSelect.handleFocus,
        blur = _useSelect.blur,
        handleBlur = _useSelect.handleBlur,
        handleClearClick = _useSelect.handleClearClick,
        handleClose = _useSelect.handleClose,
        toggleMenu = _useSelect.toggleMenu,
        selectOption = _useSelect.selectOption,
        getValueKey = _useSelect.getValueKey,
        navigateOptions = _useSelect.navigateOptions,
        dropMenuVisible = _useSelect.dropMenuVisible,
        reference = _useSelect.reference,
        input = _useSelect.input,
        popper = _useSelect.popper,
        tags = _useSelect.tags,
        selectWrapper = _useSelect.selectWrapper,
        scrollbar = _useSelect.scrollbar;

    var _useFocus = useFocus(reference),
        focus = _useFocus.focus;

    var _toRefs = vue.toRefs(states),
        inputWidth = _toRefs.inputWidth,
        selected = _toRefs.selected,
        inputLength = _toRefs.inputLength,
        filteredOptionsCount = _toRefs.filteredOptionsCount,
        visible = _toRefs.visible,
        softFocus = _toRefs.softFocus,
        selectedLabel = _toRefs.selectedLabel,
        hoverIndex = _toRefs.hoverIndex,
        query = _toRefs.query,
        inputHovering = _toRefs.inputHovering,
        currentPlaceholder = _toRefs.currentPlaceholder,
        menuVisibleOnFocus = _toRefs.menuVisibleOnFocus,
        isOnComposition = _toRefs.isOnComposition,
        isSilentBlur = _toRefs.isSilentBlur,
        options = _toRefs.options,
        cachedOptions = _toRefs.cachedOptions,
        optionsCount = _toRefs.optionsCount,
        prefixWidth = _toRefs.prefixWidth,
        tagInMultiLine = _toRefs.tagInMultiLine;

    vue.provide(selectKey, vue.reactive({
      props: props,
      options: options,
      optionsArray: optionsArray,
      cachedOptions: cachedOptions,
      optionsCount: optionsCount,
      filteredOptionsCount: filteredOptionsCount,
      hoverIndex: hoverIndex,
      handleOptionSelect: handleOptionSelect,
      selectEmitter: states.selectEmitter,
      onOptionCreate: onOptionCreate,
      onOptionDestroy: onOptionDestroy,
      selectWrapper: selectWrapper,
      selected: selected,
      setSelected: setSelected
    }));
    vue.onMounted(function () {
      states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || '请选择';

      if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
        currentPlaceholder.value = '';
      }

      addResizeListener(selectWrapper.value, handleResize);

      if (reference.value && reference.value.$el) {
        var sizeMap = {
          medium: 36,
          small: 32,
          mini: 28
        };
        var _input = reference.value.inputRef;
        states.initialInputHeight = _input.getBoundingClientRect().height || sizeMap[selectSize.value];
      }

      if (props.remote && props.multiple) {
        resetInputHeight();
      }

      vue.nextTick(function () {
        if (reference.value.$el) {
          inputWidth.value = reference.value.$el.getBoundingClientRect().width;
        }

        if (ctx.slots.prefix) {
          var inputChildNodes = reference.value.$el.childNodes;
          var _input2 = [].filter.call(inputChildNodes, function (item) {
            return item.tagName === 'INPUT';
          })[0];
          var prefix = reference.value.$el.querySelector('.bin-input__prefix');
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);

          if (states.prefixWidth) {
            _input2.style.paddingLeft = Math.max(states.prefixWidth, 30) + "px";
          }
        }
      });
      setSelected();
    });
    vue.onBeforeUnmount(function () {
      removeResizeListener(selectWrapper.value, handleResize);
    });

    if (props.multiple && !Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, []);
    }

    if (!props.multiple && Array.isArray(props.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, '');
    }

    var popperPaneRef = vue.computed(function () {
      var _popper$value;

      return (_popper$value = popper.value) == null ? void 0 : _popper$value.popperRef;
    });
    return {
      tagInMultiLine: tagInMultiLine,
      prefixWidth: prefixWidth,
      selectSize: selectSize,
      readonly: readonly,
      handleResize: handleResize,
      collapseTagSize: collapseTagSize,
      debouncedOnInputChange: debouncedOnInputChange,
      debouncedQueryChange: debouncedQueryChange,
      deletePrevTag: deletePrevTag,
      deleteTag: deleteTag,
      deleteSelected: deleteSelected,
      handleOptionSelect: handleOptionSelect,
      scrollToOption: scrollToOption,
      inputWidth: inputWidth,
      selected: selected,
      inputLength: inputLength,
      filteredOptionsCount: filteredOptionsCount,
      visible: visible,
      softFocus: softFocus,
      selectedLabel: selectedLabel,
      hoverIndex: hoverIndex,
      query: query,
      inputHovering: inputHovering,
      currentPlaceholder: currentPlaceholder,
      menuVisibleOnFocus: menuVisibleOnFocus,
      isOnComposition: isOnComposition,
      isSilentBlur: isSilentBlur,
      options: options,
      resetInputHeight: resetInputHeight,
      managePlaceholder: managePlaceholder,
      showClose: showClose,
      selectDisabled: selectDisabled,
      iconClass: iconClass,
      showNewOption: showNewOption,
      emptyText: emptyText,
      toggleLastOptionHitState: toggleLastOptionHitState,
      resetInputState: resetInputState,
      handleComposition: handleComposition,
      handleMenuEnter: handleMenuEnter,
      handleFocus: handleFocus,
      blur: blur,
      handleBlur: handleBlur,
      handleClearClick: handleClearClick,
      handleClose: handleClose,
      toggleMenu: toggleMenu,
      selectOption: selectOption,
      getValueKey: getValueKey,
      navigateOptions: navigateOptions,
      dropMenuVisible: dropMenuVisible,
      focus: focus,
      reference: reference,
      input: input,
      popper: popper,
      popperPaneRef: popperPaneRef,
      tags: tags,
      selectWrapper: selectWrapper,
      scrollbar: scrollbar
    };
  }
};

var _hoisted_1$t = {
  class: "select-trigger"
};
var _hoisted_2$k = {
  key: 0
};
var _hoisted_3$f = {
  class: "bin-select__tags-text"
};
var _hoisted_4$b = {
  class: "bin-input__prefix",
  style: {
    "height": "100%",
    "display": "flex",
    "justify-content": "center",
    "align-items": "center"
  }
};
var _hoisted_5$9 = {
  key: 1,
  class: "bin-select-dropdown__empty"
};
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_tag = vue.resolveComponent("b-tag");

  var _component_b_input = vue.resolveComponent("b-input");

  var _component_b_option = vue.resolveComponent("b-option");

  var _component_b_scrollbar = vue.resolveComponent("b-scrollbar");

  var _component_b_select_menu = vue.resolveComponent("b-select-menu");

  var _component_b_popper = vue.resolveComponent("b-popper");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.withDirectives((vue.openBlock(), vue.createBlock("div", {
    ref: "selectWrapper",
    class: ["bin-select", [$setup.selectSize ? 'bin-select--' + $setup.selectSize : '']],
    onClick: _cache[26] || (_cache[26] = vue.withModifiers(function () {
      return $setup.toggleMenu && $setup.toggleMenu.apply($setup, arguments);
    }, ["stop"]))
  }, [vue.createVNode(_component_b_popper, {
    ref: "popper",
    visible: $setup.dropMenuVisible,
    "onUpdate:visible": _cache[25] || (_cache[25] = function ($event) {
      return $setup.dropMenuVisible = $event;
    }),
    placement: "bottom-start",
    "append-to-body": $props.appendToBody,
    "popper-class": "bin-select__popper " + $props.popperClass,
    "manual-mode": "",
    theme: "light",
    pure: "",
    trigger: "click",
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    "show-arrow": false,
    offset: 4,
    transition: "zoom-in-top",
    onBeforeEnter: $setup.handleMenuEnter
  }, {
    trigger: vue.withCtx(function () {
      return [vue.createVNode("div", _hoisted_1$t, [$props.multiple ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        ref: "tags",
        class: "bin-select__tags",
        style: {
          'max-width': $setup.inputWidth - 32 + 'px',
          width: '100%'
        }
      }, [$props.collapseTags && $setup.selected.length ? (vue.openBlock(), vue.createBlock("span", _hoisted_2$k, [vue.createVNode(_component_b_tag, {
        closable: !$setup.selectDisabled && !$setup.selected[0].isDisabled,
        size: $setup.collapseTagSize,
        type: "info",
        "disable-transitions": "",
        onClose: _cache[1] || (_cache[1] = function ($event) {
          return $setup.deleteTag($event, $setup.selected[0]);
        })
      }, {
        default: vue.withCtx(function () {
          return [vue.createVNode("span", {
            class: "bin-select__tags-text",
            style: {
              'max-width': $setup.inputWidth - 123 + 'px'
            }
          }, vue.toDisplayString($setup.selected[0].currentLabel), 5
          /* TEXT, STYLE */
          )];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["closable", "size"]), $setup.selected.length > 1 ? (vue.openBlock(), vue.createBlock(_component_b_tag, {
        key: 0,
        closable: false,
        size: $setup.collapseTagSize,
        type: "info"
      }, {
        default: vue.withCtx(function () {
          return [vue.createVNode("span", _hoisted_3$f, "+ " + vue.toDisplayString($setup.selected.length - 1), 1
          /* TEXT */
          )];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["size"])) : vue.createCommentVNode("v-if", true)])) : vue.createCommentVNode("v-if", true), !$props.collapseTags ? (vue.openBlock(), vue.createBlock(vue.Transition, {
        key: 1,
        onAfterLeave: $setup.resetInputHeight
      }, {
        default: vue.withCtx(function () {
          return [vue.createVNode("span", {
            style: {
              marginLeft: $setup.prefixWidth && $setup.selected.length ? $setup.prefixWidth + "px" : null
            }
          }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.selected, function (item) {
            return vue.openBlock(), vue.createBlock(_component_b_tag, {
              key: $setup.getValueKey(item),
              closable: !$setup.selectDisabled && !item.isDisabled,
              size: $setup.collapseTagSize,
              type: "info",
              onClose: function onClose($event) {
                return $setup.deleteTag($event, item);
              }
            }, {
              default: vue.withCtx(function () {
                return [vue.createVNode("span", {
                  class: "bin-select__tags-text",
                  style: {
                    'max-width': $setup.inputWidth - 75 + 'px'
                  }
                }, vue.toDisplayString(item.currentLabel), 5
                /* TEXT, STYLE */
                )];
              }),
              _: 2
              /* DYNAMIC */

            }, 1032
            /* PROPS, DYNAMIC_SLOTS */
            , ["closable", "size", "onClose"]);
          }), 128
          /* KEYED_FRAGMENT */
          ))], 4
          /* STYLE */
          )];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onAfterLeave"])) : vue.createCommentVNode("v-if", true), $props.filterable ? vue.withDirectives((vue.openBlock(), vue.createBlock("input", {
        key: 2,
        ref: "input",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) {
          return $setup.query = $event;
        }),
        type: "text",
        class: ["bin-select__input", [$setup.selectSize ? "is-" + $setup.selectSize : '']],
        disabled: $setup.selectDisabled,
        autocomplete: $props.autocomplete,
        style: {
          marginLeft: $setup.prefixWidth && !$setup.selected.length || $setup.tagInMultiLine ? $setup.prefixWidth + "px" : null,
          flexGrow: '1',
          width: $setup.inputLength / ($setup.inputWidth - 32) + "%",
          maxWidth: $setup.inputWidth - 42 + "px"
        },
        onFocus: _cache[3] || (_cache[3] = function () {
          return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
        }),
        onBlur: _cache[4] || (_cache[4] = function () {
          return $setup.handleBlur && $setup.handleBlur.apply($setup, arguments);
        }),
        onKeyup: _cache[5] || (_cache[5] = function () {
          return $setup.managePlaceholder && $setup.managePlaceholder.apply($setup, arguments);
        }),
        onKeydown: [_cache[6] || (_cache[6] = function () {
          return $setup.resetInputState && $setup.resetInputState.apply($setup, arguments);
        }), _cache[7] || (_cache[7] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.navigateOptions('next');
        }, ["prevent"]), ["down"])), _cache[8] || (_cache[8] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.navigateOptions('prev');
        }, ["prevent"]), ["up"])), _cache[9] || (_cache[9] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.visible = false;
        }, ["stop", "prevent"]), ["esc"])), _cache[10] || (_cache[10] = vue.withKeys(vue.withModifiers(function () {
          return $setup.selectOption && $setup.selectOption.apply($setup, arguments);
        }, ["stop", "prevent"]), ["enter"])), _cache[11] || (_cache[11] = vue.withKeys(function () {
          return $setup.deletePrevTag && $setup.deletePrevTag.apply($setup, arguments);
        }, ["delete"])), _cache[12] || (_cache[12] = vue.withKeys(function ($event) {
          return $setup.visible = false;
        }, ["tab"]))],
        onCompositionstart: _cache[13] || (_cache[13] = function () {
          return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
        }),
        onCompositionupdate: _cache[14] || (_cache[14] = function () {
          return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
        }),
        onCompositionend: _cache[15] || (_cache[15] = function () {
          return $setup.handleComposition && $setup.handleComposition.apply($setup, arguments);
        }),
        onInput: _cache[16] || (_cache[16] = function () {
          return $setup.debouncedQueryChange && $setup.debouncedQueryChange.apply($setup, arguments);
        })
      }, null, 46
      /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
      , ["disabled", "autocomplete"])), [[vue.vModelText, $setup.query]]) : vue.createCommentVNode("v-if", true)], 4
      /* STYLE */
      )) : vue.createCommentVNode("v-if", true), vue.createVNode(_component_b_input, {
        id: $props.id,
        ref: "reference",
        modelValue: $setup.selectedLabel,
        "onUpdate:modelValue": _cache[18] || (_cache[18] = function ($event) {
          return $setup.selectedLabel = $event;
        }),
        type: "text",
        placeholder: $setup.currentPlaceholder,
        name: $props.name,
        autocomplete: $props.autocomplete,
        size: $setup.selectSize,
        disabled: $setup.selectDisabled,
        readonly: $setup.readonly,
        "validate-event": false,
        class: {
          'is-focus': $setup.visible
        },
        tabindex: $props.multiple && $props.filterable ? '-1' : null,
        onFocus: $setup.handleFocus,
        onBlur: $setup.handleBlur,
        onInput: $setup.debouncedOnInputChange,
        onPaste: $setup.debouncedOnInputChange,
        onKeydown: [_cache[19] || (_cache[19] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.navigateOptions('next');
        }, ["stop", "prevent"]), ["down"])), _cache[20] || (_cache[20] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.navigateOptions('prev');
        }, ["stop", "prevent"]), ["up"])), vue.withKeys(vue.withModifiers($setup.selectOption, ["stop", "prevent"]), ["enter"]), _cache[21] || (_cache[21] = vue.withKeys(vue.withModifiers(function ($event) {
          return $setup.visible = false;
        }, ["stop", "prevent"]), ["esc"])), _cache[22] || (_cache[22] = vue.withKeys(function ($event) {
          return $setup.visible = false;
        }, ["tab"]))],
        onMouseenter: _cache[23] || (_cache[23] = function ($event) {
          return $setup.inputHovering = true;
        }),
        onMouseleave: _cache[24] || (_cache[24] = function ($event) {
          return $setup.inputHovering = false;
        })
      }, vue.createSlots({
        suffix: vue.withCtx(function () {
          return [vue.withDirectives(vue.createVNode("i", {
            class: ['bin-select__caret', 'b-iconfont', 'b-icon-' + $setup.iconClass]
          }, null, 2
          /* CLASS */
          ), [[vue.vShow, !$setup.showClose]]), $setup.showClose ? (vue.openBlock(), vue.createBlock("i", {
            key: 0,
            class: "bin-select__caret is-show-close b-iconfont b-icon-" + $props.clearIcon,
            onClick: _cache[17] || (_cache[17] = function () {
              return $setup.handleClearClick && $setup.handleClearClick.apply($setup, arguments);
            })
          }, null, 2
          /* CLASS */
          )) : vue.createCommentVNode("v-if", true)];
        }),
        _: 2
        /* DYNAMIC */

      }, [_ctx.$slots.prefix ? {
        name: "prefix",
        fn: vue.withCtx(function () {
          return [vue.createVNode("div", _hoisted_4$b, [vue.renderSlot(_ctx.$slots, "prefix")])];
        })
      } : undefined]), 1032
      /* PROPS, DYNAMIC_SLOTS */
      , ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onKeydown"])])];
    }),
    default: vue.withCtx(function () {
      return [vue.createVNode(_component_b_select_menu, null, {
        default: vue.withCtx(function () {
          return [vue.withDirectives(vue.createVNode(_component_b_scrollbar, {
            ref: "scrollbar",
            tag: "ul",
            "wrap-class": "bin-select-dropdown__wrap",
            "view-class": "bin-select-dropdown__list",
            class: {
              'is-empty': !$props.allowCreate && $setup.query && $setup.filteredOptionsCount === 0
            }
          }, {
            default: vue.withCtx(function () {
              return [$setup.showNewOption ? (vue.openBlock(), vue.createBlock(_component_b_option, {
                key: 0,
                value: $setup.query,
                created: true
              }, null, 8
              /* PROPS */
              , ["value"])) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default")];
            }),
            _: 3
            /* FORWARDED */

          }, 8
          /* PROPS */
          , ["class"]), [[vue.vShow, $setup.options.size > 0 && !$props.loading]]), $setup.emptyText && (!$props.allowCreate || $props.loading || $props.allowCreate && $setup.options.size === 0) ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
            key: 0
          }, [_ctx.$slots.empty ? vue.renderSlot(_ctx.$slots, "empty", {
            key: 0
          }) : (vue.openBlock(), vue.createBlock("p", _hoisted_5$9, vue.toDisplayString($setup.emptyText), 1
          /* TEXT */
          ))], 2112
          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : vue.createCommentVNode("v-if", true)];
        }),
        _: 3
        /* FORWARDED */

      })];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["visible", "append-to-body", "popper-class", "onBeforeEnter"])], 2
  /* CLASS */
  )), [[_directive_click_outside, $setup.handleClose, $setup.popperPaneRef]]);
}

script$F.render = render$E;
script$F.__file = "src/components/select/select.vue";

script$F.install = function (app) {
  app.component(script$F.name, script$F);
};

script$H.install = function (app) {
  app.component(script$H.name, script$H);
};

var script$E = {
  name: 'BOptionGroup',
  componentName: 'BOptionGroup',
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props) {
    var visible = vue.ref(true);
    vue.provide(selectGroupKey, vue.reactive(_extends$2({}, vue.toRefs(props))));
    var select = vue.inject(selectKey);

    var queryChange = function queryChange() {
      var _select$optionsArray;

      visible.value = select == null ? void 0 : (_select$optionsArray = select.optionsArray) == null ? void 0 : _select$optionsArray.some(function (option) {
        return option.visible === true;
      });
    };

    select.selectEmitter.on(selectEvents.groupQueryChange, queryChange);
    return {
      visible: visible
    };
  }
};

var _hoisted_1$s = {
  class: "bin-select-group__wrap"
};
var _hoisted_2$j = {
  class: "bin-select-group__title"
};
var _hoisted_3$e = {
  class: "bin-select-group"
};
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createBlock("ul", _hoisted_1$s, [vue.createVNode("li", _hoisted_2$j, vue.toDisplayString($props.label), 1
  /* TEXT */
  ), vue.createVNode("li", null, [vue.createVNode("ul", _hoisted_3$e, [vue.renderSlot(_ctx.$slots, "default")])])], 512
  /* NEED_PATCH */
  )), [[vue.vShow, $setup.visible]]);
}

script$E.render = render$D;
script$E.__file = "src/components/select/option-group.vue";

script$E.install = function (app) {
  app.component(script$E.name, script$E);
};

function isValueNumber(value) {
  return /^[1-9][0-9]*$/.test(value + '');
}

var script$D = {
  name: 'PageOption',
  components: {
    BSelect: script$F,
    BOption: script$H
  },
  props: {
    pageSizeOpts: Array,
    showSizer: Boolean,
    showElevator: Boolean,
    current: Number,
    currentTo: Number,
    pageSize: Number,
    allPages: Number,
    isSmall: Boolean,
    placement: String,
    appendToBody: Boolean
  },
  emits: ['page', 'size'],
  setup: function setup(props, ctx) {
    var currentPageSize = vue.ref(props.pageSize);

    var changeSize = function changeSize() {
      ctx.emit('size', currentPageSize.value);
    };

    var changePage = function changePage(e) {
      var val = e.target.value.trim();
      var page = 0;

      if (isValueNumber(val)) {
        val = Number(val);

        if (val !== props.current) {
          var allPages = props.allPages;

          if (val > allPages) {
            page = allPages;
          } else {
            page = val;
          }
        }
      } else {
        page = 1;
      }

      if (page) {
        ctx.emit('page', page);
        e.target.value = page;
      }
    };

    vue.watch(function () {
      return props.pageSize;
    }, function (val) {
      currentPageSize.value = val;
    });
    return {
      currentPageSize: currentPageSize,
      changeSize: changeSize,
      changePage: changePage
    };
  }
};

var _hoisted_1$r = {
  key: 0,
  class: "bin-page-options"
};
var _hoisted_2$i = {
  key: 0,
  class: "bin-page-options-sizer"
};
var _hoisted_3$d = {
  key: 1,
  class: "bin-page-options-elevator"
};

var _hoisted_4$a = /*#__PURE__*/vue.createTextVNode(" 跳至 ");

var _hoisted_5$8 = /*#__PURE__*/vue.createTextVNode(" 页 ");

function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_option = vue.resolveComponent("b-option");

  var _component_b_select = vue.resolveComponent("b-select");

  return $props.showSizer || $props.showElevator ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$r, [$props.showSizer ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$i, [vue.createVNode(_component_b_select, {
    modelValue: $setup.currentPageSize,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $setup.currentPageSize = $event;
    }),
    size: $props.isSmall ? 'mini' : 'default',
    placement: $props.placement,
    "append-to-body": $props.appendToBody,
    onChange: $setup.changeSize
  }, {
    default: vue.withCtx(function () {
      return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.pageSizeOpts, function (item) {
        return vue.openBlock(), vue.createBlock(_component_b_option, {
          key: item,
          value: item,
          label: item + " \u6761/\u9875",
          style: {
            "text-align": "center"
          }
        }, null, 8
        /* PROPS */
        , ["value", "label"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["modelValue", "size", "placement", "append-to-body", "onChange"])])) : vue.createCommentVNode("v-if", true), $props.showElevator ? (vue.openBlock(), vue.createBlock("div", _hoisted_3$d, [_hoisted_4$a, vue.createVNode("label", null, [vue.createVNode("input", {
    type: "text",
    value: $props.currentTo,
    autocomplete: "off",
    spellcheck: "false",
    onKeyup: _cache[2] || (_cache[2] = vue.withKeys(function () {
      return $setup.changePage && $setup.changePage.apply($setup, arguments);
    }, ["enter"]))
  }, null, 40
  /* PROPS, HYDRATE_EVENTS */
  , ["value"])]), _hoisted_5$8])) : vue.createCommentVNode("v-if", true)])) : vue.createCommentVNode("v-if", true);
}

script$D.render = render$C;
script$D.__file = "src/components/page/options.vue";

var prefixCls$4 = 'bin-page';
var script$C = {
  name: 'BPage',
  components: {
    Options: script$D
  },
  props: {
    current: {
      type: Number,
      default: 1
    },
    total: {
      type: Number,
      default: 0
    },
    pageSize: {
      type: Number,
      default: 10
    },
    pageSizeOpts: {
      type: Array,
      default: function _default() {
        return [10, 20, 30, 40];
      }
    },
    placement: {
      validator: function validator(value) {
        return ['top', 'bottom'].includes(value);
      },
      default: 'bottom'
    },
    appendToBody: Boolean,
    size: {
      validator: function validator(value) {
        return ['', 'small'].includes(value);
      }
    },
    simple: Boolean,
    showTotal: Boolean,
    showElevator: Boolean,
    showSizer: Boolean,
    className: String,
    styles: Object,
    prevText: {
      type: String,
      default: ''
    },
    nextText: {
      type: String,
      default: ''
    }
  },
  emits: ['update:current', 'change', 'size-change'],
  setup: function setup(props, ctx) {
    var states = vue.reactive({
      prefixCls: prefixCls$4,
      currentPage: props.current,
      currentPageSize: props.pageSize
    });
    var allPages = vue.computed(function () {
      var allPage = Math.ceil(props.total / states.currentPageSize);
      return allPage === 0 ? 1 : allPage;
    });

    var changePage = function changePage(page) {
      if (states.currentPage !== page) {
        states.currentPage = page;
        ctx.emit('update:current', page);
        ctx.emit('change', page);
      }
    };

    var prev = function prev() {
      var current = states.currentPage;

      if (current <= 1) {
        return false;
      }

      changePage(current - 1);
    };

    var next = function next() {
      var current = states.currentPage;

      if (current >= allPages.value) {
        return false;
      }

      changePage(current + 1);
    };

    var fastPrev = function fastPrev() {
      var page = states.currentPage - 5;

      if (page > 0) {
        changePage(page);
      } else {
        changePage(1);
      }
    };

    var fastNext = function fastNext() {
      var page = states.currentPage + 5;

      if (page > allPages.value) {
        changePage(allPages.value);
      } else {
        changePage(page);
      }
    };

    var onSize = function onSize(pageSize) {
      states.currentPageSize = pageSize;
      ctx.emit('size-change', pageSize);
      changePage(1);
    };

    var onPage = function onPage(page) {
      changePage(page);
    };

    var keyDown = function keyDown(e) {
      var key = e.keyCode;
      var condition = key >= 48 && key <= 57 || key >= 96 && key <= 105 || key === 8 || key === 37 || key === 39;

      if (!condition) {
        e.preventDefault();
      }
    };

    var keyUp = function keyUp(e) {
      var key = e.keyCode;
      var val = parseInt(e.target.value);

      if (key === 38) {
        prev();
      } else if (key === 40) {
        next();
      } else if (key === 13) {
        var page = 1;

        if (val > allPages.value) {
          page = allPages.value;
        } else if (val <= 0 || !val) {
          page = 1;
        } else {
          page = val;
        }

        e.target.value = page;
        changePage(page);
      }
    };

    return _extends$2({}, vue.toRefs(states), {
      allPages: allPages,
      changePage: changePage,
      prev: prev,
      next: next,
      fastPrev: fastPrev,
      fastNext: fastNext,
      onSize: onSize,
      onPage: onPage,
      keyDown: keyDown,
      keyUp: keyUp
    });
  },
  computed: {
    isSmall: function isSmall() {
      return !!this.size;
    },
    simpleWrapClasses: function simpleWrapClasses() {
      var _ref;

      return ["" + prefixCls$4, prefixCls$4 + "-simple", (_ref = {}, _ref["" + this.className] = !!this.className, _ref)];
    },
    simplePagerClasses: function simplePagerClasses() {
      return prefixCls$4 + "-simple-pager";
    },
    wrapClasses: function wrapClasses() {
      var _ref2;

      return ["" + prefixCls$4, (_ref2 = {}, _ref2["" + this.className] = !!this.className, _ref2['mini'] = !!this.size, _ref2)];
    },
    prevClasses: function prevClasses() {
      var _ref3;

      return [prefixCls$4 + "-prev", (_ref3 = {}, _ref3[prefixCls$4 + "-disabled"] = this.currentPage === 1, _ref3[prefixCls$4 + "-custom-text"] = this.prevText !== '', _ref3)];
    },
    nextClasses: function nextClasses() {
      var _ref4;

      return [prefixCls$4 + "-next", (_ref4 = {}, _ref4[prefixCls$4 + "-disabled"] = this.currentPage === this.allPages, _ref4[prefixCls$4 + "-custom-text"] = this.nextText !== '', _ref4)];
    },
    firstPageClasses: function firstPageClasses() {
      var _ref5;

      return [prefixCls$4 + "-item", (_ref5 = {}, _ref5[prefixCls$4 + "-item-active"] = this.currentPage === 1, _ref5)];
    },
    lastPageClasses: function lastPageClasses() {
      var _ref6;

      return [prefixCls$4 + "-item", (_ref6 = {}, _ref6[prefixCls$4 + "-item-active"] = this.currentPage === this.allPages, _ref6)];
    }
  },
  watch: {
    total: function total(val) {
      var maxPage = Math.ceil(val / this.currentPageSize);

      if (maxPage < this.currentPage) {
        this.currentPage = maxPage === 0 ? 1 : maxPage;
      }
    },
    current: function current(val) {
      this.currentPage = val;
    },
    pageSize: function pageSize(val) {
      this.currentPageSize = val;
    }
  }
};

var _hoisted_1$q = /*#__PURE__*/vue.createVNode("a", null, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
})], -1
/* HOISTED */
);

var _hoisted_2$h = /*#__PURE__*/vue.createVNode("span", null, "/", -1
/* HOISTED */
);

var _hoisted_3$c = /*#__PURE__*/vue.createVNode("a", null, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
})], -1
/* HOISTED */
);

var _hoisted_4$9 = {
  key: 1,
  class: "b-iconfont b-icon-left"
};

var _hoisted_5$7 = /*#__PURE__*/vue.createVNode("a", null, "1", -1
/* HOISTED */
);

var _hoisted_6$6 = /*#__PURE__*/vue.createVNode("a", null, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
})], -1
/* HOISTED */
);

var _hoisted_7$5 = /*#__PURE__*/vue.createVNode("a", null, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
})], -1
/* HOISTED */
);

var _hoisted_8$5 = {
  key: 1,
  class: "b-iconfont b-icon-right"
};
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_options = vue.resolveComponent("options");

  return $props.simple ? (vue.openBlock(), vue.createBlock("ul", {
    key: 0,
    class: $options.simpleWrapClasses,
    style: $props.styles
  }, [vue.createVNode("li", {
    title: "上一页",
    class: $options.prevClasses,
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.prev && $setup.prev.apply($setup, arguments);
    })
  }, [_hoisted_1$q], 2
  /* CLASS */
  ), vue.createVNode("li", {
    class: $options.simplePagerClasses,
    title: _ctx.currentPage + '/' + $setup.allPages
  }, [vue.createVNode("label", null, [vue.createVNode("input", {
    type: "text",
    value: _ctx.currentPage,
    autocomplete: "off",
    spellcheck: "false",
    onKeydown: _cache[2] || (_cache[2] = function () {
      return $setup.keyDown && $setup.keyDown.apply($setup, arguments);
    }),
    onKeyup: _cache[3] || (_cache[3] = function () {
      return $setup.keyUp && $setup.keyUp.apply($setup, arguments);
    }),
    onChange: _cache[4] || (_cache[4] = function () {
      return $setup.keyUp && $setup.keyUp.apply($setup, arguments);
    })
  }, null, 40
  /* PROPS, HYDRATE_EVENTS */
  , ["value"])]), _hoisted_2$h, vue.createTextVNode(" " + vue.toDisplayString($setup.allPages), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"]), vue.createVNode("li", {
    title: "下一页",
    class: $options.nextClasses,
    onClick: _cache[5] || (_cache[5] = function () {
      return $setup.next && $setup.next.apply($setup, arguments);
    })
  }, [_hoisted_3$c], 2
  /* CLASS */
  )], 6
  /* CLASS, STYLE */
  )) : (vue.openBlock(), vue.createBlock("ul", {
    key: 1,
    class: $options.wrapClasses,
    style: $props.styles
  }, [$props.showTotal ? (vue.openBlock(), vue.createBlock("li", {
    key: 0,
    class: [_ctx.prefixCls + '-total']
  }, [vue.createVNode("span", null, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
    return [vue.createTextVNode("共 " + vue.toDisplayString($props.total) + " 条", 1
    /* TEXT */
    )];
  })])], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("li", {
    title: "上一页",
    class: $options.prevClasses,
    onClick: _cache[6] || (_cache[6] = function () {
      return $setup.prev && $setup.prev.apply($setup, arguments);
    })
  }, [vue.createVNode("a", null, [$props.prevText !== '' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.prevText), 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock("i", _hoisted_4$9))])], 2
  /* CLASS */
  ), vue.createVNode("li", {
    title: "1",
    class: $options.firstPageClasses,
    onClick: _cache[7] || (_cache[7] = function ($event) {
      return $setup.changePage(1);
    })
  }, [_hoisted_5$7], 2
  /* CLASS */
  ), _ctx.currentPage > 5 ? (vue.openBlock(), vue.createBlock("li", {
    key: 1,
    title: "向前5页",
    class: [_ctx.prefixCls + '-item-jump-prev'],
    onClick: _cache[8] || (_cache[8] = function () {
      return $setup.fastPrev && $setup.fastPrev.apply($setup, arguments);
    })
  }, [_hoisted_6$6], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), _ctx.currentPage === 5 ? (vue.openBlock(), vue.createBlock("li", {
    key: 2,
    title: _ctx.currentPage - 3,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[9] || (_cache[9] = function ($event) {
      return $setup.changePage(_ctx.currentPage - 3);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage - 3), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), _ctx.currentPage - 2 > 1 ? (vue.openBlock(), vue.createBlock("li", {
    key: 3,
    title: _ctx.currentPage - 2,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[10] || (_cache[10] = function ($event) {
      return $setup.changePage(_ctx.currentPage - 2);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage - 2), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), _ctx.currentPage - 1 > 1 ? (vue.openBlock(), vue.createBlock("li", {
    key: 4,
    title: _ctx.currentPage - 1,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[11] || (_cache[11] = function ($event) {
      return $setup.changePage(_ctx.currentPage - 1);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage - 1), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), _ctx.currentPage !== 1 && _ctx.currentPage !== $setup.allPages ? (vue.openBlock(), vue.createBlock("li", {
    key: 5,
    title: _ctx.currentPage,
    class: [_ctx.prefixCls + '-item', _ctx.prefixCls + '-item-active']
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), _ctx.currentPage + 1 < $setup.allPages ? (vue.openBlock(), vue.createBlock("li", {
    key: 6,
    title: _ctx.currentPage + 1,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[12] || (_cache[12] = function ($event) {
      return $setup.changePage(_ctx.currentPage + 1);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage + 1), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), _ctx.currentPage + 2 < $setup.allPages ? (vue.openBlock(), vue.createBlock("li", {
    key: 7,
    title: _ctx.currentPage + 2,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[13] || (_cache[13] = function ($event) {
      return $setup.changePage(_ctx.currentPage + 2);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage + 2), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), $setup.allPages - _ctx.currentPage === 4 ? (vue.openBlock(), vue.createBlock("li", {
    key: 8,
    title: _ctx.currentPage + 3,
    class: [_ctx.prefixCls + '-item'],
    onClick: _cache[14] || (_cache[14] = function ($event) {
      return $setup.changePage(_ctx.currentPage + 3);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString(_ctx.currentPage + 3), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), $setup.allPages - _ctx.currentPage >= 5 ? (vue.openBlock(), vue.createBlock("li", {
    key: 9,
    title: "向后5页",
    class: [_ctx.prefixCls + '-item-jump-next'],
    onClick: _cache[15] || (_cache[15] = function () {
      return $setup.fastNext && $setup.fastNext.apply($setup, arguments);
    })
  }, [_hoisted_7$5], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), $setup.allPages > 1 ? (vue.openBlock(), vue.createBlock("li", {
    key: 10,
    title: $setup.allPages,
    class: $options.lastPageClasses,
    onClick: _cache[16] || (_cache[16] = function ($event) {
      return $setup.changePage($setup.allPages);
    })
  }, [vue.createVNode("a", null, vue.toDisplayString($setup.allPages), 1
  /* TEXT */
  )], 10
  /* CLASS, PROPS */
  , ["title"])) : vue.createCommentVNode("v-if", true), vue.createVNode("li", {
    title: "下一页",
    class: $options.nextClasses,
    onClick: _cache[17] || (_cache[17] = function () {
      return $setup.next && $setup.next.apply($setup, arguments);
    })
  }, [vue.createVNode("a", null, [$props.nextText !== '' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 0
  }, [vue.createTextVNode(vue.toDisplayString($props.nextText), 1
  /* TEXT */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : (vue.openBlock(), vue.createBlock("i", _hoisted_8$5))])], 2
  /* CLASS */
  ), vue.createVNode(_component_options, {
    "show-sizer": $props.showSizer,
    "page-size": _ctx.currentPageSize,
    "page-size-opts": $props.pageSizeOpts,
    placement: $props.placement,
    "append-to-body": $props.appendToBody,
    "show-elevator": $props.showElevator,
    current: _ctx.currentPage,
    "all-pages": $setup.allPages,
    "is-small": $options.isSmall,
    onSize: $setup.onSize,
    onPage: $setup.onPage
  }, null, 8
  /* PROPS */
  , ["show-sizer", "page-size", "page-size-opts", "placement", "append-to-body", "show-elevator", "current", "all-pages", "is-small", "onSize", "onPage"])], 6
  /* CLASS, STYLE */
  ));
}

script$C.render = render$B;
script$C.__file = "src/components/page/page.vue";

script$C.install = function (app) {
  app.component(script$C.name, script$C);
};

var isLeaf = function isLeaf(el) {
  return !el.getAttribute('aria-owns');
};
var getSibling = function getSibling(el, distance) {
  var parentNode = el.parentNode;
  if (!parentNode) return null;
  var siblings = parentNode.querySelectorAll('.bin-cascader-node[tabindex="-1"]');
  var index = Array.prototype.indexOf.call(siblings, el);
  return siblings[index + distance] || null;
};
var getMenuIndex = function getMenuIndex(el) {
  if (!el) return 0;
  var pieces = el.id.split('-');
  return Number(pieces[pieces.length - 2]);
};
var focusNode = function focusNode(el) {
  if (!el) return;
  el.focus();
  !isLeaf(el) && el.click();
};
var checkNode = function checkNode(el) {
  if (!el) return;
  var input = el.querySelector('input');

  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
var sortByOriginalOrder = function sortByOriginalOrder(oldNodes, newNodes) {
  var newNodesCopy = newNodes.slice(0);
  var newIds = newNodesCopy.map(function (node) {
    return node.uid;
  });
  var res = oldNodes.reduce(function (acc, item) {
    var index = newIds.indexOf(item.uid);

    if (index > -1) {
      acc.push(item);
      newNodesCopy.splice(index, 1);
      newIds.splice(index, 1);
    }

    return acc;
  }, []);
  res.push.apply(res, newNodesCopy);
  return res;
};
var PANEL_INJECTION_KEY = Symbol();

var script$B = {
  name: 'BCascaderNode',
  components: {
    BCheckbox: script$S,
    BRadio: script$Q,
    NodeContent: {
      render: function render() {
        var _this$$parent = this.$parent,
            node = _this$$parent.node,
            panel = _this$$parent.panel;
        var data = node.data,
            label = node.label;
        var renderLabelFn = panel.renderLabelFn;
        return vue.h('span', {
          class: 'bin-cascader-node__label'
        }, renderLabelFn ? renderLabelFn({
          node: node,
          data: data
        }) : label);
      }
    }
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ['expand'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var panel = vue.inject(PANEL_INJECTION_KEY);
    var isHoverMenu = vue.computed(function () {
      return panel.isHoverMenu;
    });
    var multiple = vue.computed(function () {
      return panel.config.multiple;
    });
    var checkStrictly = vue.computed(function () {
      return panel.config.checkStrictly;
    });
    var checkedNodeId = vue.computed(function () {
      var _panel$checkedNodes$;

      return (_panel$checkedNodes$ = panel.checkedNodes[0]) == null ? void 0 : _panel$checkedNodes$.uid;
    });
    var isDisabled = vue.computed(function () {
      return props.node.isDisabled;
    });
    var isLeaf = vue.computed(function () {
      return props.node.isLeaf;
    });
    var expandable = vue.computed(function () {
      return checkStrictly.value && !isLeaf.value || !isDisabled.value;
    });
    var inExpandingPath = vue.computed(function () {
      return isInPath(panel.expandingNode);
    }); // only useful in check-strictly mode

    var inCheckedPath = vue.computed(function () {
      return checkStrictly.value && panel.checkedNodes.some(isInPath);
    });

    var isInPath = function isInPath(node) {
      var _node$pathNodes;

      var _props$node = props.node,
          level = _props$node.level,
          uid = _props$node.uid;
      return (node == null ? void 0 : (_node$pathNodes = node.pathNodes[level - 1]) == null ? void 0 : _node$pathNodes.uid) === uid;
    };

    var doExpand = function doExpand() {
      if (inExpandingPath.value) return;
      panel.expandNode(props.node);
    };

    var doCheck = function doCheck(checked) {
      var node = props.node;
      if (checked === node.checked) return;
      panel.handleCheckChange(node, checked);
    };

    var doLoad = function doLoad() {
      panel.lazyLoad(props.node, function () {
        if (!isLeaf.value) doExpand();
      });
    };

    var handleHoverExpand = function handleHoverExpand(e) {
      if (!isHoverMenu.value) return;
      handleExpand();
      !isLeaf.value && emit('expand', e);
    };

    var handleExpand = function handleExpand() {
      var node = props.node; // do not exclude leaf node because the menus expanded might have to reset

      if (!expandable.value || node.loading) return;
      node.loaded ? doExpand() : doLoad();
    };

    var handleClick = function handleClick() {
      if (isHoverMenu.value && !isLeaf.value) return;

      if (isLeaf.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
        handleCheck(true);
      } else {
        handleExpand();
      }
    };

    var handleCheck = function handleCheck(checked) {
      if (!props.node.loaded) {
        doLoad();
      } else {
        doCheck(checked);
        !checkStrictly.value && doExpand();
      }
    };

    return {
      panel: panel,
      isHoverMenu: isHoverMenu,
      multiple: multiple,
      checkStrictly: checkStrictly,
      checkedNodeId: checkedNodeId,
      isDisabled: isDisabled,
      isLeaf: isLeaf,
      expandable: expandable,
      inExpandingPath: inExpandingPath,
      inCheckedPath: inCheckedPath,
      handleHoverExpand: handleHoverExpand,
      handleExpand: handleExpand,
      handleClick: handleClick,
      handleCheck: handleCheck
    };
  }
};

var _hoisted_1$p = /*#__PURE__*/vue.createVNode("span", null, null, -1
/* HOISTED */
);

var _hoisted_2$g = {
  key: 2,
  class: "b-iconfont b-icon-check bin-cascader-node__prefix"
};
var _hoisted_3$b = {
  key: 0,
  class: "b-iconfont b-icon-loading icon-is-rotating bin-cascader-node__postfix"
};
var _hoisted_4$8 = {
  key: 1,
  class: "b-iconfont b-icon-right bin-cascader-node__postfix"
};
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_checkbox = vue.resolveComponent("b-checkbox");

  var _component_b_radio = vue.resolveComponent("b-radio");

  var _component_node_content = vue.resolveComponent("node-content");

  return vue.openBlock(), vue.createBlock("li", {
    id: $props.menuId + "-" + $props.node.uid,
    role: "menuitem",
    "aria-haspopup": !$setup.isLeaf,
    "aria-owns": $setup.isLeaf ? null : $props.menuId,
    "aria-expanded": $setup.inExpandingPath,
    tabindex: $setup.expandable ? -1 : null,
    class: ['bin-cascader-node', $setup.checkStrictly && 'is-selectable', $setup.inExpandingPath && 'in-active-path', $setup.inCheckedPath && 'in-checked-path', $props.node.checked && 'is-active', !$setup.expandable && 'is-disabled'],
    onMouseenter: _cache[3] || (_cache[3] = function () {
      return $setup.handleHoverExpand && $setup.handleHoverExpand.apply($setup, arguments);
    }),
    onFocus: _cache[4] || (_cache[4] = function () {
      return $setup.handleHoverExpand && $setup.handleHoverExpand.apply($setup, arguments);
    }),
    onClick: _cache[5] || (_cache[5] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    })
  }, [vue.createCommentVNode(" prefix "), $setup.multiple ? (vue.openBlock(), vue.createBlock(_component_b_checkbox, {
    key: 0,
    "model-value": $props.node.checked,
    indeterminate: $props.node.indeterminate,
    disabled: $setup.isDisabled,
    onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["stop"])),
    "onUpdate:modelValue": $setup.handleCheck
  }, null, 8
  /* PROPS */
  , ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : $setup.checkStrictly ? (vue.openBlock(), vue.createBlock(_component_b_radio, {
    key: 1,
    "model-value": $setup.checkedNodeId,
    label: $props.node.uid,
    disabled: $setup.isDisabled,
    "onUpdate:modelValue": $setup.handleCheck,
    onClick: _cache[2] || (_cache[2] = vue.withModifiers(function () {}, ["stop"]))
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_1$p];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["model-value", "label", "disabled", "onUpdate:modelValue"])) : $setup.isLeaf && $props.node.checked ? (vue.openBlock(), vue.createBlock("i", _hoisted_2$g)) : vue.createCommentVNode("v-if", true), vue.createCommentVNode(" content "), vue.createVNode(_component_node_content), vue.createCommentVNode(" postfix "), !$setup.isLeaf ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 3
  }, [$props.node.loading ? (vue.openBlock(), vue.createBlock("i", _hoisted_3$b)) : (vue.openBlock(), vue.createBlock("i", _hoisted_4$8))], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)], 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"]);
}

script$B.render = render$A;
script$B.__file = "src/components/cascader-panel/src/node.vue";

var script$A = {
  name: 'BCascaderMenu',
  components: {
    BScrollbar: script$1C,
    BCascaderNode: script$B
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup: function setup(props) {
    var instance = vue.getCurrentInstance();
    var id = generateId$1();
    var activeNode = null;
    var hoverTimer = null;
    var panel = vue.inject(PANEL_INJECTION_KEY);
    var hoverZone = vue.ref(null);
    var isEmpty = vue.computed(function () {
      return !props.nodes.length;
    });
    var menuId = vue.computed(function () {
      return "cascader-menu-" + id + "-" + props.index;
    });

    var handleExpand = function handleExpand(e) {
      activeNode = e.target;
    };

    var handleMouseMove = function handleMouseMove(e) {
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value) return;

      if (activeNode.contains(e.target)) {
        clearHoverTimer();
        var el = instance.vnode.el;

        var _el$getBoundingClient = el.getBoundingClientRect(),
            left = _el$getBoundingClient.left;

        var offsetWidth = el.offsetWidth,
            offsetHeight = el.offsetHeight;
        var startX = e.clientX - left;
        var top = activeNode.offsetTop;
        var bottom = top + activeNode.offsetHeight;
        hoverZone.value.innerHTML = "\n          <path style=\"pointer-events: auto;\" fill=\"transparent\" d=\"M" + startX + " " + top + " L" + offsetWidth + " 0 V" + top + " Z\" />\n          <path style=\"pointer-events: auto;\" fill=\"transparent\" d=\"M" + startX + " " + bottom + " L" + offsetWidth + " " + offsetHeight + " V" + bottom + " Z\" />\n        ";
      } else if (!hoverTimer) {
        hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };

    var clearHoverTimer = function clearHoverTimer() {
      if (!hoverTimer) return;
      clearTimeout(hoverTimer);
      hoverTimer = null;
    };

    var clearHoverZone = function clearHoverZone() {
      if (!hoverZone.value) return;
      hoverZone.value.innerHTML = '';
      clearHoverTimer();
    };

    return {
      panel: panel,
      hoverZone: hoverZone,
      isEmpty: isEmpty,
      menuId: menuId,
      handleExpand: handleExpand,
      handleMouseMove: handleMouseMove,
      clearHoverZone: clearHoverZone
    };
  }
};

var _hoisted_1$o = {
  key: 0,
  class: "bin-cascader-menu__empty-text"
};
var _hoisted_2$f = {
  key: 1,
  ref: "hoverZone",
  class: "bin-cascader-menu__hover-zone"
};
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_cascader_node = vue.resolveComponent("b-cascader-node");

  var _component_b_scrollbar = vue.resolveComponent("b-scrollbar");

  return vue.openBlock(), vue.createBlock(_component_b_scrollbar, {
    id: $setup.menuId,
    tag: "ul",
    role: "menu",
    class: "bin-cascader-menu",
    "wrap-class": "bin-cascader-menu__wrap",
    "view-class": ['bin-cascader-menu__list', $setup.isEmpty && 'is-empty'],
    onMousemove: $setup.handleMouseMove,
    onMouseleave: $setup.clearHoverZone
  }, {
    default: vue.withCtx(function () {
      return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.nodes, function (node) {
        return vue.openBlock(), vue.createBlock(_component_b_cascader_node, {
          key: node.uid,
          node: node,
          "menu-id": $setup.menuId,
          onExpand: $setup.handleExpand
        }, null, 8
        /* PROPS */
        , ["node", "menu-id", "onExpand"]);
      }), 128
      /* KEYED_FRAGMENT */
      )), $setup.isEmpty ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$o, " 暂无数据 ")) : $setup.panel.isHoverMenu ? (vue.openBlock(), vue.createBlock("svg", _hoisted_2$f, null, 512
      /* NEED_PATCH */
      )) : vue.createCommentVNode("v-if", true)];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["id", "view-class", "onMousemove", "onMouseleave"]);
}

script$A.render = render$z;
script$A.__file = "src/components/cascader-panel/src/menu.vue";

var uid = 0;

var calculatePathNodes = function calculatePathNodes(node) {
  var nodes = [node];
  var parent = node.parent;

  while (parent) {
    nodes.unshift(parent);
    parent = parent.parent;
  }

  return nodes;
};

var Node = /*#__PURE__*/function () {
  function Node(data, config, parent, root) {
    var _this = this;

    if (root === void 0) {
      root = false;
    }

    this.uid = uid++;
    this.data = data;
    this.config = config;
    this.parent = parent;
    this.root = root;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    this.text = '';
    var valueKey = config.value,
        labelKey = config.label,
        childrenKey = config.children;
    var childrenData = data[childrenKey];
    var pathNodes = calculatePathNodes(this);
    this.level = root ? 0 : parent ? parent.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map(function (node) {
      return node.value;
    });
    this.pathLabels = pathNodes.map(function (node) {
      return node.label;
    });
    this.childrenData = childrenData;
    this.children = (childrenData || []).map(function (child) {
      return new Node(child, config, _this);
    });
    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
  }

  var _proto = Node.prototype;

  _proto.appendChild = function appendChild(childData) {
    var childrenData = this.childrenData,
        children = this.children;
    var node = new Node(childData, this.config, this);

    if (Array.isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }

    children.push(node);
    return node;
  };

  _proto.calcText = function calcText(allLevels, separator) {
    var text = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text;
    return text;
  };

  _proto.broadcast = function broadcast(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var handlerName = "onParent" + capitalize(event);
    this.children.forEach(function (child) {
      if (child) {
        // bottom up
        child.broadcast.apply(child, [event].concat(args));
        child[handlerName] && child[handlerName].apply(child, args);
      }
    });
  };

  _proto.emit = function emit(event) {
    var parent = this.parent;
    var handlerName = "onChild" + capitalize(event);

    if (parent) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      parent[handlerName] && parent[handlerName].apply(parent, args);
      parent.emit.apply(parent, [event].concat(args));
    }
  };

  _proto.onParentCheck = function onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  };

  _proto.onChildCheck = function onChildCheck() {
    var children = this.children;
    var validChildren = children.filter(function (child) {
      return !child.isDisabled;
    });
    var checked = validChildren.length ? validChildren.every(function (child) {
      return child.checked;
    }) : false;
    this.setCheckState(checked);
  };

  _proto.setCheckState = function setCheckState(checked) {
    var totalNum = this.children.length;
    var checkedNum = this.children.reduce(function (c, p) {
      var num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
      return c + num;
    }, 0);
    this.checked = this.loaded && this.children.every(function (child) {
      return child.loaded && child.checked;
    }) && checked;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  };

  _proto.doCheck = function doCheck(checked) {
    if (this.checked === checked) return;
    var _this$config = this.config,
        checkStrictly = _this$config.checkStrictly,
        multiple = _this$config.multiple;

    if (checkStrictly || !multiple) {
      this.checked = checked;
    } else {
      // bottom up to unify the calculation of the indeterminate state
      this.broadcast('check', checked);
      this.setCheckState(checked);
      this.emit('check');
    }
  };

  _createClass(Node, [{
    key: "isDisabled",
    get: function get() {
      var data = this.data,
          parent = this.parent,
          config = this.config;
      var disabled = config.disabled,
          checkStrictly = config.checkStrictly;
      var isDisabled = isFunction$2(disabled) ? disabled(data, this) : !!data[disabled];
      return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
    }
  }, {
    key: "isLeaf",
    get: function get() {
      var data = this.data,
          config = this.config,
          childrenData = this.childrenData,
          loaded = this.loaded;
      var lazy = config.lazy,
          leaf = config.leaf;
      var isLeaf = isFunction$2(leaf) ? leaf(data, this) : data[leaf];
      return isUndefined(isLeaf) ? lazy && !loaded ? false : !Array.isArray(childrenData) : !!isLeaf;
    }
  }, {
    key: "valueByOption",
    get: function get() {
      return this.config.emitPath ? this.pathValues : this.value;
    }
  }]);

  return Node;
}();

var flatNodes = function flatNodes(nodes, leafOnly) {
  return nodes.reduce(function (res, node) {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }

    return res;
  }, []);
};

var Store = /*#__PURE__*/function () {
  function Store(data, config) {
    var _this = this;

    this.config = config;
    var nodes = (data || []).map(function (nodeData) {
      return new Node(nodeData, _this.config);
    });
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }

  var _proto = Store.prototype;

  _proto.getNodes = function getNodes() {
    return this.nodes;
  };

  _proto.getFlattedNodes = function getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  };

  _proto.appendNode = function appendNode(nodeData, parentNode) {
    var node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);
    if (!parentNode) this.nodes.push(node);
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
  };

  _proto.appendNodes = function appendNodes(nodeDataList, parentNode) {
    var _this2 = this;

    nodeDataList.forEach(function (nodeData) {
      return _this2.appendNode(nodeData, parentNode);
    });
  } // when checkStrictly, leaf node first
  ;

  _proto.getNodeByValue = function getNodeByValue(value, leafOnly) {
    if (leafOnly === void 0) {
      leafOnly = false;
    }

    if (!value && value !== 0) return null;
    var nodes = this.getFlattedNodes(leafOnly).filter(function (node) {
      return isEqual$1(node.value, value) || isEqual$1(node.pathValues, value);
    });
    return nodes[0] || null;
  };

  _proto.getSameNode = function getSameNode(node) {
    if (!node) return null;
    var nodes = this.getFlattedNodes(false).filter(function (_ref) {
      var value = _ref.value,
          level = _ref.level;
      return isEqual$1(node.value, value) && node.level === level;
    });
    return nodes[0] || null;
  };

  return Store;
}();

var DefaultProps = {
  expandTrigger: 'click',
  multiple: false,
  checkStrictly: false,
  // whether all nodes can be selected
  emitPath: true,
  // wether to emit an array of all levels value in which node is located
  lazy: false,
  lazyLoad: NOOP,
  value: 'value',
  label: 'label',
  children: 'children',
  leaf: 'leaf',
  disabled: 'disabled',
  hoverThreshold: 500
};
var useCascaderConfig = function useCascaderConfig(props) {
  return vue.computed(function () {
    return _extends$2({}, DefaultProps, props.props);
  });
};

var script$z = {
  name: 'BCascaderPanel',
  components: {
    BCascaderMenu: script$A
  },
  props: {
    modelValue: [Number, String, Array],
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    props: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var initialLoaded = true; // for interrupt sync check status in lazy mode

    var manualChecked = false;
    var config = useCascaderConfig(props);
    var store = vue.ref(null);
    var menuList = vue.ref([]);
    var checkedValue = vue.ref(null);
    var menus = vue.ref([]);
    var expandingNode = vue.ref(null);
    var checkedNodes = vue.ref([]);
    var isHoverMenu = vue.computed(function () {
      return config.value.expandTrigger === 'hover';
    });
    var renderLabelFn = vue.computed(function () {
      return props.renderLabel || slots.default;
    });

    var initStore = function initStore() {
      var options = props.options;
      var cfg = config.value;
      manualChecked = false;
      store.value = new Store(options, cfg);
      menus.value = [store.value.getNodes()];

      if (cfg.lazy && isEmpty(props.options)) {
        initialLoaded = false;
        lazyLoad(null, function () {
          initialLoaded = true;
          syncCheckedValue(false, true);
        });
      } else {
        syncCheckedValue(false, true);
      }
    };

    var lazyLoad = function lazyLoad(node, cb) {
      var cfg = config.value;
      node = node || new Node({}, cfg, null, true);
      node.loading = true;

      var resolve = function resolve(dataList) {
        var parent = node.root ? null : node;
        dataList && store.value.appendNodes(dataList, parent);
        node.loading = false;
        node.loaded = true;
        cb && cb(dataList);
      };

      cfg.lazyLoad(node, resolve);
    };

    var expandNode = function expandNode(node, silent) {
      var _expandingNode$value, _newExpandingNode;

      var level = node.level;
      var newMenus = menus.value.slice(0, level);
      var newExpandingNode;

      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }

      if (((_expandingNode$value = expandingNode.value) == null ? void 0 : _expandingNode$value.uid) !== ((_newExpandingNode = newExpandingNode) == null ? void 0 : _newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit('expand-change', (node == null ? void 0 : node.pathValues) || []);
      }
    };

    var handleCheckChange = function handleCheckChange(node, checked, emitClose) {
      if (emitClose === void 0) {
        emitClose = true;
      }

      var _config$value = config.value,
          checkStrictly = _config$value.checkStrictly,
          multiple = _config$value.multiple;
      var oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked);
      calculateCheckedValue();
      emitClose && !multiple && !checkStrictly && emit('close');
    };

    var getFlattedNodes = function getFlattedNodes(leafOnly) {
      return store.value.getFlattedNodes(leafOnly);
    };

    var getCheckedNodes = function getCheckedNodes(leafOnly) {
      return getFlattedNodes(leafOnly).filter(function (node) {
        return node.checked !== false;
      });
    };

    var clearCheckedNodes = function clearCheckedNodes() {
      checkedNodes.value.forEach(function (node) {
        return node.doCheck(false);
      });
      calculateCheckedValue();
    };

    var calculateCheckedValue = function calculateCheckedValue() {
      var _values$;

      var _config$value2 = config.value,
          checkStrictly = _config$value2.checkStrictly,
          multiple = _config$value2.multiple;
      var oldNodes = checkedNodes.value;
      var newNodes = getCheckedNodes(!checkStrictly); // ensure the original order

      var nodes = sortByOriginalOrder(oldNodes, newNodes);
      var values = nodes.map(function (node) {
        return node.valueByOption;
      });
      checkedNodes.value = nodes;
      checkedValue.value = multiple ? values : (_values$ = values[0]) != null ? _values$ : null;
    };

    var syncCheckedValue = function syncCheckedValue(loaded, forced) {
      if (loaded === void 0) {
        loaded = false;
      }

      if (forced === void 0) {
        forced = false;
      }

      var modelValue = props.modelValue;
      var _config$value3 = config.value,
          lazy = _config$value3.lazy,
          multiple = _config$value3.multiple,
          checkStrictly = _config$value3.checkStrictly;
      var leafOnly = !checkStrictly;
      if (!initialLoaded || manualChecked || !forced && isEqual$1(modelValue, checkedValue.value)) return;

      if (lazy && !loaded) {
        var values = deduplicate(arrayFlat(coerceTruthyValueToArray(modelValue)));
        var nodes = values.map(function (val) {
          return store.value.getNodeByValue(val);
        }).filter(function (node) {
          return !!node && !node.loaded && !node.loading;
        });

        if (nodes.length) {
          nodes.forEach(function (node) {
            lazyLoad(node, function () {
              return syncCheckedValue(false, forced);
            });
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        var _values = multiple ? coerceTruthyValueToArray(modelValue) : [modelValue];

        var _nodes = deduplicate(_values.map(function (val) {
          return store.value.getNodeByValue(val, leafOnly);
        }));

        syncMenuState(_nodes, false);
        checkedValue.value = modelValue;
      }
    };

    var syncMenuState = function syncMenuState(newCheckedNodes, reserveExpandingState) {
      if (reserveExpandingState === void 0) {
        reserveExpandingState = true;
      }

      var checkStrictly = config.value.checkStrictly;
      var oldNodes = checkedNodes.value;
      var newNodes = newCheckedNodes.filter(function (node) {
        return !!node && (checkStrictly || node.isLeaf);
      });
      var oldExpandingNode = store.value.getSameNode(expandingNode.value);
      var newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];

      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach(function (node) {
          return expandNode(node, true);
        });
      } else {
        expandingNode.value = null;
      }

      oldNodes.forEach(function (node) {
        return node.doCheck(false);
      });
      newNodes.forEach(function (node) {
        return node.doCheck(true);
      });
      checkedNodes.value = newNodes;
      vue.nextTick(scrollToExpandingNode);
    };

    var scrollToExpandingNode = function scrollToExpandingNode() {
      if (isServer) return;
      menuList.value.forEach(function (menu) {
        var menuElement = menu == null ? void 0 : menu.$el;

        if (menuElement) {
          var container = menuElement.querySelector('.bin-scrollbar__wrap');
          var activeNode = menuElement.querySelector('.bin-cascader-node.is-active') || menuElement.querySelector('.bin-cascader-node.in-active-path');
          scrollIntoView(container, activeNode);
        }
      });
    };

    var handleKeyDown = function handleKeyDown(e) {
      var target = e.target;
      var code = e.code;

      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down:
          // eslint-disable-next-line no-case-declarations
          var distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance));
          break;

        case EVENT_CODE.left:
          // eslint-disable-next-line no-case-declarations
          var preMenu = menuList.value[getMenuIndex(target) - 1]; // eslint-disable-next-line no-case-declarations

          var expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.bin-cascader-node[aria-expanded="true"]');
          focusNode(expandedNode);
          break;

        case EVENT_CODE.right:
          // eslint-disable-next-line no-case-declarations
          var nextMenu = menuList.value[getMenuIndex(target) + 1]; // eslint-disable-next-line no-case-declarations

          var firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.bin-cascader-node[tabindex="-1"]');
          focusNode(firstNode);
          break;

        case EVENT_CODE.enter:
          checkNode(target);
          break;

        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          emit('close');
          break;
      }
    };

    vue.provide(PANEL_INJECTION_KEY, vue.reactive({
      config: config,
      expandingNode: expandingNode,
      checkedNodes: checkedNodes,
      isHoverMenu: isHoverMenu,
      renderLabelFn: renderLabelFn,
      lazyLoad: lazyLoad,
      expandNode: expandNode,
      handleCheckChange: handleCheckChange
    }));
    vue.watch([config, function () {
      return props.options;
    }], function (_ref2, _ref3) {
      _ref2[0];
          var newOptions = _ref2[1];
      _ref3[0];
          var oldOptions = _ref3[1];
      if (isEqual$1(newOptions, oldOptions)) return;
      initStore();
    }, {
      deep: true,
      immediate: true
    });
    vue.watch(function () {
      return props.modelValue;
    }, function () {
      manualChecked = false;
      syncCheckedValue();
    });
    vue.watch(checkedValue, function (val) {
      if (!isEqual$1(val, props.modelValue)) {
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
      }
    });
    vue.onBeforeUpdate(function () {
      return menuList.value = [];
    });
    vue.onMounted(function () {
      return !isEmpty(props.modelValue) && syncCheckedValue();
    });
    return {
      menuList: menuList,
      menus: menus,
      checkedNodes: checkedNodes,
      expandingNode: expandingNode,
      handleKeyDown: handleKeyDown,
      handleCheckChange: handleCheckChange,
      getFlattedNodes: getFlattedNodes,
      getCheckedNodes: getCheckedNodes,
      clearCheckedNodes: clearCheckedNodes,
      calculateCheckedValue: calculateCheckedValue,
      scrollToExpandingNode: scrollToExpandingNode
    };
  }
};

function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_cascader_menu = vue.resolveComponent("b-cascader-menu");

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-cascader-panel', $props.border && 'is-bordered'],
    onKeydown: _cache[1] || (_cache[1] = function () {
      return $setup.handleKeyDown && $setup.handleKeyDown.apply($setup, arguments);
    })
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.menus, function (menu, index) {
    return vue.openBlock(), vue.createBlock(_component_b_cascader_menu, {
      key: index,
      ref: function ref(item) {
        return $setup.menuList[index] = item;
      },
      index: index,
      nodes: menu
    }, null, 8
    /* PROPS */
    , ["index", "nodes"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$z.render = render$y;
script$z.__file = "src/components/cascader-panel/src/index.vue";

script$z.install = function (app) {
  app.component(script$z.name, script$z);
};

var DEFAULT_INPUT_HEIGHT = 32;
var INPUT_HEIGHT_MAP = {
  large: 40,
  small: 24,
  mini: 22
};
var popperOptions = {
  modifiers: [{
    name: 'arrowPosition',
    enabled: true,
    phase: 'main',
    fn: function fn(_ref) {
      var state = _ref.state;
      var modifiersData = state.modifiersData,
          elements = state.elements;
      var reference = elements.reference,
          arrow = elements.arrow;
      modifiersData.arrow.x = modifiersData.arrow.x - (reference.clientWidth - arrow.clientWidth) / 2 + 35;
    },
    requires: ['arrow']
  }]
};
var script$y = {
  name: 'BCascader',
  components: {
    BCascaderPanel: script$z,
    BInput: script$1D,
    BPopper: script$1F,
    BScrollbar: script$1C,
    BTag: script$X
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    modelValue: [Number, String, Array],
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    props: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    size: {
      type: String,
      validator: validSize
    },
    placeholder: {
      type: String,
      default: '请选择'
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: Function,
      default: function _default(node, keyword) {
        return node.text.includes(keyword);
      }
    },
    separator: {
      type: String,
      default: ' / '
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    collapseTags: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: function _default() {
        return true;
      }
    },
    popperClass: {
      type: String,
      default: ''
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'focus', 'blur', 'visible-change', 'expand-change', 'remove-tag'],
  setup: function setup(props, _ref2) {
    var emit = _ref2.emit;
    var inputInitialHeight = 0;
    var pressDeleteCount = 0;

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        BFormItem = _useForm.BFormItem,
        formEmit = _useForm.formEmit;

    var popper = vue.ref(null);
    var input = vue.ref(null);
    var tagWrapper = vue.ref(null);
    var panel = vue.ref(null);
    var suggestionPanel = vue.ref(null);
    var popperVisible = vue.ref(false);
    var inputHover = vue.ref(false);
    var filtering = vue.ref(false);
    var inputValue = vue.ref('');
    var searchInputValue = vue.ref('');
    var presentTags = vue.ref([]);
    var suggestions = vue.ref([]);
    var isDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var realSize = vue.computed(function () {
      return props.size || BFormItem.size;
    });
    var tagSize = vue.computed(function () {
      return ['small', 'mini'].includes(realSize.value) ? 'mini' : 'small';
    });
    var multiple = vue.computed(function () {
      return !!props.props.multiple;
    });
    var readonly = vue.computed(function () {
      return !props.filterable || multiple.value;
    });
    var searchKeyword = vue.computed(function () {
      return multiple.value ? searchInputValue.value : inputValue.value;
    });
    var checkedNodes = vue.computed(function () {
      var _panel$value;

      return ((_panel$value = panel.value) == null ? void 0 : _panel$value.checkedNodes) || [];
    });
    var clearBtnVisible = vue.computed(function () {
      if (!props.clearable || isDisabled.value || filtering.value || !inputHover.value) return false;
      return !!checkedNodes.value.length;
    });
    var presentText = vue.computed(function () {
      var showAllLevels = props.showAllLevels,
          separator = props.separator;
      var nodes = checkedNodes.value;
      return nodes.length ? multiple.value ? ' ' : nodes[0].calcText(showAllLevels, separator) : '';
    });
    var checkedValue = vue.computed({
      get: function get() {
        return props.modelValue;
      },
      set: function set(val) {
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
        formEmit('change', [val]);
      }
    });
    var popperPaneRef = vue.computed(function () {
      var _popper$value;

      return (_popper$value = popper.value) == null ? void 0 : _popper$value.popperRef;
    });

    var togglePopperVisible = function togglePopperVisible(visible) {
      var _visible;

      if (isDisabled.value) return;
      visible = (_visible = visible) != null ? _visible : !popperVisible.value;

      if (visible !== popperVisible.value) {
        popperVisible.value = visible;
        input.value.inputRef.setAttribute('aria-expanded', visible);

        if (visible) {
          updatePopperPosition();
          vue.nextTick(panel.value.scrollToExpandingNode);
        } else if (props.filterable) {
          var value = presentText.value;
          inputValue.value = value;
          searchInputValue.value = value;
        }

        emit('visible-change', visible);
      }
    };

    var updatePopperPosition = function updatePopperPosition() {
      vue.nextTick(popper.value.update);
    };

    var hideSuggestionPanel = function hideSuggestionPanel() {
      filtering.value = false;
    };

    var genTag = function genTag(node) {
      var showAllLevels = props.showAllLevels,
          separator = props.separator;
      return {
        node: node,
        key: node.uid,
        text: node.calcText(showAllLevels, separator),
        hitState: false,
        closable: !isDisabled.value && !node.isDisabled
      };
    };

    var deleteTag = function deleteTag(tag) {
      var node = tag.node;
      node.doCheck(false);
      panel.value.calculateCheckedValue();
      emit('remove-tag', node.valueByOption);
    };

    var calculatePresentTags = function calculatePresentTags() {
      if (!multiple.value) return;
      var nodes = checkedNodes.value;
      var tags = [];

      if (nodes.length) {
        var first = nodes[0],
            rest = nodes.slice(1);
        var restCount = rest.length;
        tags.push(genTag(first));

        if (restCount) {
          if (props.collapseTags) {
            tags.push({
              key: -1,
              text: "+ " + restCount,
              closable: false
            });
          } else {
            rest.forEach(function (node) {
              return tags.push(genTag(node));
            });
          }
        }
      }

      presentTags.value = tags;
    };

    var calculateSuggestions = function calculateSuggestions() {
      var filterMethod = props.filterMethod,
          showAllLevels = props.showAllLevels,
          separator = props.separator;
      var res = panel.value.getFlattedNodes(!props.props.checkStrictly).filter(function (node) {
        if (node.isDisabled) return false;
        node.calcText(showAllLevels, separator);
        return filterMethod(node, searchKeyword.value);
      });

      if (multiple.value) {
        presentTags.value.forEach(function (tag) {
          tag.hitState = false;
        });
      }

      filtering.value = true;
      suggestions.value = res;
      updatePopperPosition();
    };

    var focusFirstNode = function focusFirstNode() {
      var firstNode = null;

      if (filtering.value && suggestionPanel.value) {
        firstNode = suggestionPanel.value.$el.querySelector('.bin-cascader__suggestion-item');
      } else {
        var _panel$value2;

        firstNode = (_panel$value2 = panel.value) == null ? void 0 : _panel$value2.$el.querySelector('.bin-cascader-node[tabindex="-1"]');
      }

      if (firstNode) {
        firstNode.focus();
        !filtering.value && firstNode.click();
      }
    };

    var updateStyle = function updateStyle() {
      var _suggestionPanel$valu;

      var inputInner = input.value.inputRef;
      var tagWrapperEl = tagWrapper.value;
      var suggestionPanelEl = (_suggestionPanel$valu = suggestionPanel.value) == null ? void 0 : _suggestionPanel$valu.$el;
      if (isServer || !inputInner) return;

      if (suggestionPanelEl) {
        var suggestionList = suggestionPanelEl.querySelector('.bin-cascader__suggestion-list');
        suggestionList.style.minWidth = inputInner.offsetWidth + 'px';
      }

      if (tagWrapperEl) {
        var offsetHeight = tagWrapperEl.offsetHeight;
        inputInner.style.height = Math.max(offsetHeight + 6, inputInitialHeight) + 'px';
        updatePopperPosition();
      }
    };

    var getCheckedNodes = function getCheckedNodes(leafOnly) {
      return panel.value.getCheckedNodes(leafOnly);
    };

    var handleExpandChange = function handleExpandChange(value) {
      updatePopperPosition();
      emit('expand-change', value);
    };

    var handleKeyDown = function handleKeyDown(e) {
      switch (e.code) {
        case EVENT_CODE.enter:
          togglePopperVisible();
          break;

        case EVENT_CODE.down:
          togglePopperVisible(true);
          vue.nextTick(focusFirstNode);
          e.preventDefault();
          break;

        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };

    var handleClear = function handleClear() {
      panel.value.clearCheckedNodes();
      togglePopperVisible(false);
    };

    var handleSuggestionClick = function handleSuggestionClick(node) {
      var checked = node.checked;

      if (multiple.value) {
        panel.value.handleCheckChange(node, !checked, false);
      } else {
        !checked && panel.value.handleCheckChange(node, true, false);
        togglePopperVisible(false);
      }
    };

    var handleDelete = function handleDelete() {
      var tags = presentTags.value;
      var lastTag = tags[tags.length - 1];
      pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
      if (!lastTag || !pressDeleteCount) return;

      if (lastTag.hitState) {
        deleteTag(lastTag);
      } else {
        lastTag.hitState = true;
      }
    };

    var handleFilter = debounce(function () {
      var value = searchKeyword.value;
      if (!value) return;
      var passed = props.beforeFilter(value);

      if (isPromise(passed)) {
        passed.then(calculateSuggestions).catch(function () {
          /* prevent log error */
        });
      } else if (passed !== false) {
        calculateSuggestions();
      } else {
        hideSuggestionPanel();
      }
    }, props.debounce);

    var handleInput = function handleInput(val, e) {
      !popperVisible.value && togglePopperVisible(true);
      if (e != null && e.isComposing) return;
      val ? handleFilter() : hideSuggestionPanel();
    };

    vue.watch(filtering, updatePopperPosition);
    vue.watch([checkedNodes, isDisabled], calculatePresentTags);
    vue.watch(presentTags, function () {
      return vue.nextTick(updateStyle);
    });
    vue.watch(presentText, function (val) {
      return inputValue.value = val;
    }, {
      immediate: true
    });
    vue.onMounted(function () {
      var inputEl = input.value.$el;
      inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
      addResizeListener(inputEl, updateStyle);
    });
    vue.onBeforeUnmount(function () {
      removeResizeListener(input.value.$el, updateStyle);
    });
    return {
      popperOptions: popperOptions,
      popper: popper,
      popperPaneRef: popperPaneRef,
      input: input,
      tagWrapper: tagWrapper,
      panel: panel,
      suggestionPanel: suggestionPanel,
      popperVisible: popperVisible,
      inputHover: inputHover,
      filtering: filtering,
      presentText: presentText,
      checkedValue: checkedValue,
      inputValue: inputValue,
      searchInputValue: searchInputValue,
      presentTags: presentTags,
      suggestions: suggestions,
      isDisabled: isDisabled,
      realSize: realSize,
      tagSize: tagSize,
      multiple: multiple,
      readonly: readonly,
      clearBtnVisible: clearBtnVisible,
      BForm: BForm,
      BFormItem: BFormItem,
      formEmit: formEmit,
      togglePopperVisible: togglePopperVisible,
      hideSuggestionPanel: hideSuggestionPanel,
      deleteTag: deleteTag,
      focusFirstNode: focusFirstNode,
      getCheckedNodes: getCheckedNodes,
      handleExpandChange: handleExpandChange,
      handleKeyDown: handleKeyDown,
      handleClear: handleClear,
      handleSuggestionClick: handleSuggestionClick,
      handleDelete: handleDelete,
      handleInput: handleInput
    };
  }
};

var _hoisted_1$n = {
  key: 0,
  ref: "tagWrapper",
  class: "bin-cascader__tags"
};
var _hoisted_2$e = {
  key: 0,
  class: "b-iconfont b-icon-check"
};

var _hoisted_3$a = /*#__PURE__*/vue.createVNode("li", {
  class: "bin-cascader__empty-text"
}, "暂无数据", -1
/* HOISTED */
);

function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_input = vue.resolveComponent("b-input");

  var _component_b_tag = vue.resolveComponent("b-tag");

  var _component_b_cascader_panel = vue.resolveComponent("b-cascader-panel");

  var _component_b_scrollbar = vue.resolveComponent("b-scrollbar");

  var _component_b_popper = vue.resolveComponent("b-popper");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.openBlock(), vue.createBlock(_component_b_popper, {
    ref: "popper",
    visible: $setup.popperVisible,
    "onUpdate:visible": _cache[16] || (_cache[16] = function ($event) {
      return $setup.popperVisible = $event;
    }),
    "manual-mode": "",
    placement: "bottom-start",
    "popper-class": "bin-cascader__dropdown " + $props.popperClass,
    "stop-popper-mouse-event": false,
    transition: "zoom-in-top",
    "gpu-acceleration": false,
    theme: "light",
    pure: "",
    "show-arrow": false,
    offset: 4,
    onAfterLeave: $setup.hideSuggestionPanel
  }, {
    trigger: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", {
        class: ['bin-cascader', $setup.realSize && "bin-cascader--" + $setup.realSize, {
          'is-disabled': $setup.isDisabled
        }],
        onClick: _cache[10] || (_cache[10] = function () {
          return $setup.togglePopperVisible($setup.readonly ? undefined : true);
        }),
        onKeydown: _cache[11] || (_cache[11] = function () {
          return $setup.handleKeyDown && $setup.handleKeyDown.apply($setup, arguments);
        }),
        onMouseenter: _cache[12] || (_cache[12] = function ($event) {
          return $setup.inputHover = true;
        }),
        onMouseleave: _cache[13] || (_cache[13] = function ($event) {
          return $setup.inputHover = false;
        })
      }, [vue.createVNode(_component_b_input, {
        ref: "input",
        modelValue: $setup.inputValue,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = function ($event) {
          return $setup.inputValue = $event;
        }),
        modelModifiers: {
          trim: true
        },
        placeholder: $props.placeholder,
        readonly: $setup.readonly,
        disabled: $setup.isDisabled,
        "validate-event": false,
        size: $setup.realSize,
        class: {
          'is-focus': $setup.popperVisible
        },
        onFocus: _cache[4] || (_cache[4] = function (e) {
          return _ctx.$emit('focus', e);
        }),
        onBlur: _cache[5] || (_cache[5] = function (e) {
          return _ctx.$emit('blur', e);
        }),
        onInput: $setup.handleInput
      }, {
        suffix: vue.withCtx(function () {
          return [$setup.clearBtnVisible ? (vue.openBlock(), vue.createBlock("i", {
            key: "clear",
            class: "b-iconfont b-icon-close-circle-fill",
            onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
              return $setup.handleClear && $setup.handleClear.apply($setup, arguments);
            }, ["stop"]))
          })) : (vue.openBlock(), vue.createBlock("i", {
            key: "arrow-down",
            class: ['b-iconfont', 'b-icon-down', $setup.popperVisible && 'is-reverse'],
            onClick: _cache[2] || (_cache[2] = vue.withModifiers(function ($event) {
              return $setup.togglePopperVisible();
            }, ["stop"]))
          }, null, 2
          /* CLASS */
          ))];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onInput"]), $setup.multiple ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$n, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.presentTags, function (tag) {
        return vue.openBlock(), vue.createBlock(_component_b_tag, {
          key: tag.key,
          type: "info",
          size: $setup.tagSize,
          hit: tag.hitState,
          closable: tag.closable,
          "disable-transitions": "",
          onClose: function onClose($event) {
            return $setup.deleteTag(tag);
          }
        }, {
          default: vue.withCtx(function () {
            return [vue.createVNode("span", null, vue.toDisplayString(tag.text), 1
            /* TEXT */
            )];
          }),
          _: 2
          /* DYNAMIC */

        }, 1032
        /* PROPS, DYNAMIC_SLOTS */
        , ["size", "hit", "closable", "onClose"]);
      }), 128
      /* KEYED_FRAGMENT */
      )), $props.filterable && !$setup.isDisabled ? vue.withDirectives((vue.openBlock(), vue.createBlock("input", {
        key: 0,
        "onUpdate:modelValue": _cache[6] || (_cache[6] = function ($event) {
          return $setup.searchInputValue = $event;
        }),
        type: "text",
        class: "bin-cascader__search-input",
        placeholder: $setup.presentText ? '' : $props.placeholder,
        onInput: _cache[7] || (_cache[7] = function (e) {
          return $setup.handleInput($setup.searchInputValue, e);
        }),
        onClick: _cache[8] || (_cache[8] = vue.withModifiers(function ($event) {
          return $setup.togglePopperVisible(true);
        }, ["stop"])),
        onKeydown: _cache[9] || (_cache[9] = vue.withKeys(function () {
          return $setup.handleDelete && $setup.handleDelete.apply($setup, arguments);
        }, ["delete"]))
      }, null, 40
      /* PROPS, HYDRATE_EVENTS */
      , ["placeholder"])), [[vue.vModelText, $setup.searchInputValue, void 0, {
        trim: true
      }]]) : vue.createCommentVNode("v-if", true)], 512
      /* NEED_PATCH */
      )) : vue.createCommentVNode("v-if", true)], 34
      /* CLASS, HYDRATE_EVENTS */
      ), [[_directive_click_outside, function () {
        return $setup.togglePopperVisible(false);
      }, $setup.popperPaneRef]])];
    }),
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode(_component_b_cascader_panel, {
        ref: "panel",
        modelValue: $setup.checkedValue,
        "onUpdate:modelValue": _cache[14] || (_cache[14] = function ($event) {
          return $setup.checkedValue = $event;
        }),
        options: $props.options,
        props: $props.props,
        border: false,
        "render-label": _ctx.$slots.default,
        onExpandChange: $setup.handleExpandChange,
        onClose: _cache[15] || (_cache[15] = function ($event) {
          return $setup.togglePopperVisible(false);
        })
      }, null, 8
      /* PROPS */
      , ["modelValue", "options", "props", "render-label", "onExpandChange"]), [[vue.vShow, !$setup.filtering]]), $props.filterable ? vue.withDirectives((vue.openBlock(), vue.createBlock(_component_b_scrollbar, {
        key: 0,
        ref: "suggestionPanel",
        tag: "ul",
        class: "bin-cascader__suggestion-panel",
        "view-class": "bin-cascader__suggestion-list"
      }, {
        default: vue.withCtx(function () {
          return [$setup.suggestions.length ? (vue.openBlock(true), vue.createBlock(vue.Fragment, {
            key: 0
          }, vue.renderList($setup.suggestions, function (item) {
            return vue.openBlock(), vue.createBlock("li", {
              key: item.uid,
              class: ['bin-cascader__suggestion-item', item.checked && 'is-checked'],
              tabindex: -1,
              onClick: function onClick($event) {
                return $setup.handleSuggestionClick(item);
              }
            }, [vue.createVNode("span", null, vue.toDisplayString(item.text), 1
            /* TEXT */
            ), item.checked ? (vue.openBlock(), vue.createBlock("i", _hoisted_2$e)) : vue.createCommentVNode("v-if", true)], 10
            /* CLASS, PROPS */
            , ["onClick"]);
          }), 128
          /* KEYED_FRAGMENT */
          )) : vue.renderSlot(_ctx.$slots, "empty", {
            key: 1
          }, function () {
            return [_hoisted_3$a];
          })];
        }),
        _: 3
        /* FORWARDED */

      }, 512
      /* NEED_PATCH */
      )), [[vue.vShow, $setup.filtering]]) : vue.createCommentVNode("v-if", true)];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["visible", "popper-class", "onAfterLeave"]);
}

script$y.render = render$x;
script$y.__file = "src/components/cascader/cascader.vue";

script$y.install = function (app) {
  app.component(script$y.name, script$y);
};

var hsv2hsl = function hsv2hsl(hue, sat, val) {
  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
}; // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>


var isOnePointZero = function isOnePointZero(n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
};

var isPercentage = function isPercentage(n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
}; // Take input from [0, n] and return it as [0, 1]


var bound01 = function bound01(value, max) {
  if (isOnePointZero(value)) value = '100%';
  var processPercent = isPercentage(value);
  value = Math.min(max, Math.max(0, parseFloat(value + ''))); // Automatically convert percentage into number

  if (processPercent) {
    value = parseInt(value * max + '', 10) / 100;
  } // Handle floating point rounding errors


  if (Math.abs(value - max) < 0.000001) {
    return 1;
  } // Convert into [0, 1] range if it isn't already


  return value % max / parseFloat(max);
};

var INT_HEX_MAP = {
  10: 'A',
  11: 'B',
  12: 'C',
  13: 'D',
  14: 'E',
  15: 'F'
};

var toHex$1 = function toHex(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b;

  var hexOne = function hexOne(value) {
    value = Math.min(Math.round(value), 255);
    var high = Math.floor(value / 16);
    var low = value % 16;
    return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
  };

  if (isNaN(r) || isNaN(g) || isNaN(b)) return '';
  return '#' + hexOne(r) + hexOne(g) + hexOne(b);
};

var HEX_INT_MAP = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};

var parseHexChannel = function parseHexChannel(hex) {
  if (hex.length === 2) {
    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
  }

  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};

var hsl2hsv = function hsl2hsv(hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  var smin = sat;
  var lmin = Math.max(light, 0.01); // let sv
  // let v

  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  var v = (light + sat) / 2;
  var sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v * 100
  };
}; // `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]


var rgb2hsv = function rgb2hsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        {
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        }

      case g:
        {
          h = (b - r) / d + 2;
          break;
        }

      case b:
        {
          h = (r - g) / d + 4;
          break;
        }
    }

    h /= 6;
  }

  return {
    h: h * 360,
    s: s * 100,
    v: v * 100
  };
}; // `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]


var hsv2rgb = function hsv2rgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
};

var Color$1 = /*#__PURE__*/function () {
  function Color(options) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = 'hex';
    this.value = '';
    this.selected = false;
    this.options = options || {};

    for (var option in options) {
      // eslint-disable-next-line no-prototype-builtins
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }

    this.doOnChange();
  }

  var _proto = Color.prototype;

  _proto.set = function set(prop, value) {
    if (arguments.length === 1 && typeof prop === 'object') {
      for (var p in prop) {
        // eslint-disable-next-line no-prototype-builtins
        if (prop.hasOwnProperty(p)) {
          this.set(p, prop[p]);
        }
      }

      return;
    }

    this['_' + prop] = value;
    this.doOnChange();
  };

  _proto.get = function get(prop) {
    return this['_' + prop];
  };

  _proto.toRgb = function toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  };

  _proto.fromString = function fromString(value) {
    var _this = this;

    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }

    var fromHSV = function fromHSV(h, s, v) {
      _this._hue = Math.max(0, Math.min(360, h));
      _this._saturation = Math.max(0, Math.min(100, s));
      _this._value = Math.max(0, Math.min(100, v));

      _this.doOnChange();
    };

    if (value.indexOf('hsl') !== -1) {
      var parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }

      if (parts.length >= 3) {
        var _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]),
            h = _hsl2hsv.h,
            s = _hsl2hsv.s,
            v = _hsl2hsv.v;

        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      var _parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (_parts.length === 4) {
        this._alpha = Math.floor(parseFloat(_parts[3]) * 100);
      } else if (_parts.length === 3) {
        this._alpha = 100;
      }

      if (_parts.length >= 3) {
        fromHSV(_parts[0], _parts[1], _parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      var _parts2 = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter(function (val) {
        return val !== '';
      }).map(function (val, index) {
        return index > 2 ? parseFloat(val) : parseInt(val, 10);
      });

      if (_parts2.length === 4) {
        this._alpha = Math.floor(parseFloat(_parts2[3]) * 100);
      } else if (_parts2.length === 3) {
        this._alpha = 100;
      }

      if (_parts2.length >= 3) {
        var _rgb2hsv = rgb2hsv(_parts2[0], _parts2[1], _parts2[2]),
            _h = _rgb2hsv.h,
            _s = _rgb2hsv.s,
            _v = _rgb2hsv.v;

        fromHSV(_h, _s, _v);
      }
    } else if (value.indexOf('#') !== -1) {
      var hex = value.replace('#', '').trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex)) return;
      var r, g, b;

      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6 || hex.length === 8) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4, 6));
      }

      if (hex.length === 8) {
        this._alpha = Math.floor(parseHexChannel(hex.substring(6)) / 255 * 100);
      } else if (hex.length === 3 || hex.length === 6) {
        this._alpha = 100;
      }

      var _rgb2hsv2 = rgb2hsv(r, g, b),
          _h2 = _rgb2hsv2.h,
          _s2 = _rgb2hsv2.s,
          _v2 = _rgb2hsv2.v;

      fromHSV(_h2, _s2, _v2);
    }
  };

  _proto.compare = function compare(color) {
    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
  };

  _proto.doOnChange = function doOnChange() {
    var _hue = this._hue,
        _saturation = this._saturation,
        _value = this._value,
        _alpha = this._alpha,
        format = this.format;

    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          {
            var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
            this.value = "hsla(" + _hue + ", " + Math.round(hsl[1] * 100) + "%, " + Math.round(hsl[2] * 100) + "%, " + _alpha / 100 + ")";
            break;
          }

        case 'hsv':
          {
            this.value = "hsva(" + _hue + ", " + Math.round(_saturation) + "%, " + Math.round(_value) + "%, " + _alpha / 100 + ")";
            break;
          }

        default:
          {
            var _hsv2rgb = hsv2rgb(_hue, _saturation, _value),
                r = _hsv2rgb.r,
                g = _hsv2rgb.g,
                b = _hsv2rgb.b;

            this.value = "rgba(" + r + ", " + g + ", " + b + ", " + _alpha / 100 + ")";
          }
      }
    } else {
      switch (format) {
        case 'hsl':
          {
            var _hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);

            this.value = "hsl(" + _hue + ", " + Math.round(_hsl[1] * 100) + "%, " + Math.round(_hsl[2] * 100) + "%)";
            break;
          }

        case 'hsv':
          {
            this.value = "hsv(" + _hue + ", " + Math.round(_saturation) + "%, " + Math.round(_value) + "%)";
            break;
          }

        case 'rgb':
          {
            var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value),
                _r = _hsv2rgb2.r,
                _g = _hsv2rgb2.g,
                _b = _hsv2rgb2.b;

            this.value = "rgb(" + _r + ", " + _g + ", " + _b + ")";
            break;
          }

        default:
          {
            this.value = toHex$1(hsv2rgb(_hue, _saturation, _value));
          }
      }
    }
  };

  return Color;
}();

var isDragging = false;
function draggable (element, options) {
  if (isServer) return;

  var moveFn = function moveFn(event) {
    options.drag == null ? void 0 : options.drag(event);
  };

  var upFn = function upFn(event) {
    off$1(document, 'mousemove', moveFn);
    off$1(document, 'mouseup', upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    options.end == null ? void 0 : options.end(event);
  };

  on$1(element, 'mousedown', function (event) {
    if (isDragging) return;

    document.onselectstart = function () {
      return false;
    };

    document.ondragstart = function () {
      return false;
    };

    on$1(document, 'mousemove', moveFn);
    on$1(document, 'mouseup', upFn);
    isDragging = true;
    options.start == null ? void 0 : options.start(event);
  });
}

var script$x = {
  name: 'BSlPanel',
  props: {
    color: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props) {
    // instance
    var instance = vue.getCurrentInstance(); // data

    var cursorTop = vue.ref(0);
    var cursorLeft = vue.ref(0);
    var background = vue.ref('hsl(0, 100%, 50%)');
    var colorValue = vue.computed(function () {
      var hue = props.color.get('hue');
      var value = props.color.get('value');
      return {
        hue: hue,
        value: value
      };
    }); // methods

    function update() {
      var saturation = props.color.get('saturation');
      var value = props.color.get('value');
      var el = instance.vnode.el;
      var width = el.clientWidth,
          height = el.clientHeight;
      cursorLeft.value = saturation * width / 100;
      cursorTop.value = (100 - value) * height / 100;
      background.value = 'hsl(' + props.color.get('hue') + ', 100%, 50%)';
    }

    function handleDrag(event) {
      var el = instance.vnode.el;
      var rect = el.getBoundingClientRect();
      var left = event.clientX - rect.left;
      var top = event.clientY - rect.top;
      left = Math.max(0, left);
      left = Math.min(left, rect.width);
      top = Math.max(0, top);
      top = Math.min(top, rect.height);
      cursorLeft.value = left;
      cursorTop.value = top;
      props.color.set({
        saturation: left / rect.width * 100,
        value: 100 - top / rect.height * 100
      });
    } // watch


    vue.watch(function () {
      return colorValue.value;
    }, function () {
      update();
    }); // mounted

    vue.onMounted(function () {
      draggable(instance.vnode.el, {
        drag: function drag(event) {
          handleDrag(event);
        },
        end: function end(event) {
          handleDrag(event);
        }
      });
      update();
    });
    return {
      cursorTop: cursorTop,
      cursorLeft: cursorLeft,
      background: background,
      colorValue: colorValue,
      handleDrag: handleDrag,
      update: update
    };
  }
};

var _hoisted_1$m = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-color-svpanel__white"
}, null, -1
/* HOISTED */
);

var _hoisted_2$d = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-color-svpanel__black"
}, null, -1
/* HOISTED */
);

var _hoisted_3$9 = /*#__PURE__*/vue.createVNode("div", null, null, -1
/* HOISTED */
);

function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: "bin-color-svpanel",
    style: {
      backgroundColor: $setup.background
    }
  }, [_hoisted_1$m, _hoisted_2$d, vue.createVNode("div", {
    class: "bin-color-svpanel__cursor",
    style: {
      top: $setup.cursorTop + 'px',
      left: $setup.cursorLeft + 'px'
    }
  }, [_hoisted_3$9], 4
  /* STYLE */
  )], 4
  /* STYLE */
  );
}

script$x.render = render$w;
script$x.__file = "src/components/color-picker/sv-panel.vue";

var script$w = {
  name: 'BColorHueSlider',
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: Boolean
  },
  setup: function setup(props) {
    var instance = vue.getCurrentInstance(); // ref

    var thumb = vue.ref(null);
    var bar = vue.ref(null); // data

    var thumbLeft = vue.ref(0);
    var thumbTop = vue.ref(0); // computed

    var hueValue = vue.computed(function () {
      return props.color.get('hue');
    }); // watch

    vue.watch(function () {
      return hueValue.value;
    }, function () {
      update();
    }); // methods

    function handleClick(event) {
      var target = event.target;

      if (target !== thumb.value) {
        handleDrag(event);
      }
    }

    function handleDrag(event) {
      var el = instance.vnode.el;
      var rect = el.getBoundingClientRect();
      var hue;

      if (!props.vertical) {
        var left = event.clientX - rect.left;
        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
        left = Math.max(thumb.value.offsetWidth / 2, left);
        hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
      } else {
        var top = event.clientY - rect.top;
        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
        top = Math.max(thumb.value.offsetHeight / 2, top);
        hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
      }

      props.color.set('hue', hue);
    }

    function getThumbLeft() {
      var el = instance.vnode.el;
      if (props.vertical) return 0;
      var hue = props.color.get('hue');
      if (!el) return 0;
      return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
    }

    function getThumbTop() {
      var el = instance.vnode.el;
      if (!props.vertical) return 0;
      var hue = props.color.get('hue');
      if (!el) return 0;
      return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
    }

    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
    } // mounded


    vue.onMounted(function () {
      var dragConfig = {
        drag: function drag(event) {
          handleDrag(event);
        },
        end: function end(event) {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      bar: bar,
      thumb: thumb,
      thumbLeft: thumbLeft,
      thumbTop: thumbTop,
      hueValue: hueValue,
      handleClick: handleClick,
      update: update
    };
  }
};

function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-color-hue-slider", {
      'is-vertical': $props.vertical
    }]
  }, [vue.createVNode("div", {
    ref: "bar",
    class: "bin-color-hue-slider__bar",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    })
  }, null, 512
  /* NEED_PATCH */
  ), vue.createVNode("div", {
    ref: "thumb",
    class: "bin-color-hue-slider__thumb",
    style: {
      left: $setup.thumbLeft + 'px',
      top: $setup.thumbTop + 'px'
    }
  }, null, 4
  /* STYLE */
  )], 2
  /* CLASS */
  );
}

script$w.render = render$v;
script$w.__file = "src/components/color-picker/hue-slider.vue";

var script$v = {
  name: 'BColorAlphaSlider',
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props) {
    var instance = vue.getCurrentInstance(); // ref

    var thumb = vue.ref(null);
    var bar = vue.ref(null); // data

    var thumbLeft = vue.ref(0);
    var thumbTop = vue.ref(0);
    var background = vue.ref(null);
    vue.watch(function () {
      return props.color.get('alpha');
    }, function () {
      update();
    });
    vue.watch(function () {
      return props.color.value;
    }, function () {
      update();
    }); //methods

    function getThumbLeft() {
      if (props.vertical) return 0;
      var el = instance.vnode.el;
      var alpha = props.color.get('alpha');
      if (!el) return 0;
      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
    }

    function getThumbTop() {
      var el = instance.vnode.el;
      if (!props.vertical) return 0;
      var alpha = props.color.get('alpha');
      if (!el) return 0;
      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
    }

    function getBackground() {
      if (props.color && props.color.value) {
        var _props$color$toRgb = props.color.toRgb(),
            r = _props$color$toRgb.r,
            g = _props$color$toRgb.g,
            b = _props$color$toRgb.b;

        return "linear-gradient(to right, rgba(" + r + ", " + g + ", " + b + ", 0) 0%, rgba(" + r + ", " + g + ", " + b + ", 1) 100%)";
      }

      return null;
    }

    function handleClick(event) {
      var target = event.target;

      if (target !== thumb.value) {
        handleDrag(event);
      }
    }

    function handleDrag(event) {
      var el = instance.vnode.el;
      var rect = el.getBoundingClientRect();

      if (!props.vertical) {
        var left = event.clientX - rect.left;
        left = Math.max(thumb.value.offsetWidth / 2, left);
        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
        props.color.set('alpha', Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
      } else {
        var top = event.clientY - rect.top;
        top = Math.max(thumb.value.offsetHeight / 2, top);
        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
        props.color.set('alpha', Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
      }
    }

    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
      background.value = getBackground();
    } // mounded


    vue.onMounted(function () {
      var dragConfig = {
        drag: function drag(event) {
          handleDrag(event);
        },
        end: function end(event) {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      thumb: thumb,
      bar: bar,
      thumbLeft: thumbLeft,
      thumbTop: thumbTop,
      background: background,
      handleClick: handleClick,
      update: update
    };
  }
};

function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-color-alpha-slider", {
      'is-vertical': $props.vertical
    }]
  }, [vue.createVNode("div", {
    ref: "bar",
    class: "bin-color-alpha-slider__bar",
    style: {
      background: $setup.background
    },
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    })
  }, null, 4
  /* STYLE */
  ), vue.createVNode("div", {
    ref: "thumb",
    class: "bin-color-alpha-slider__thumb",
    style: {
      left: $setup.thumbLeft + 'px',
      top: $setup.thumbTop + 'px'
    }
  }, null, 4
  /* STYLE */
  )], 2
  /* CLASS */
  );
}

script$v.render = render$u;
script$v.__file = "src/components/color-picker/alpha-slider.vue";

var script$u = {
  props: {
    colors: {
      type: Array,
      required: true
    },
    color: {
      type: Object,
      required: true
    }
  },
  setup: function setup(props) {
    var _inject = vue.inject('ColorPicker', {}),
        currentColor = _inject.currentColor; //data


    var rgbaColors = vue.ref(parseColors(props.colors, props.color)); //watch

    vue.watch(function () {
      return currentColor.value;
    }, function (val) {
      var color = new Color$1();
      color.fromString(val);
      rgbaColors.value.forEach(function (item) {
        item.selected = color.compare(item);
      });
    });
    vue.watchEffect(function () {
      rgbaColors.value = parseColors(props.colors, props.color);
    });

    function handleSelect(index) {
      props.color.fromString(props.colors[index]);
    }

    function parseColors(colors, color) {
      return colors.map(function (value) {
        var c = new Color$1();
        c.enableAlpha = true;
        c.format = 'rgba';
        c.fromString(value);
        c.selected = c.value === color.value;
        return c;
      });
    }

    return {
      rgbaColors: rgbaColors,
      handleSelect: handleSelect
    };
  }
};

var _hoisted_1$l = {
  class: "bin-color-predefine"
};
var _hoisted_2$c = {
  class: "bin-color-predefine__colors"
};
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", _hoisted_1$l, [vue.createVNode("div", _hoisted_2$c, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.rgbaColors, function (item, index) {
    return vue.openBlock(), vue.createBlock("div", {
      key: $props.colors[index],
      class: ["bin-color-predefine__color-selector", {
        selected: item.selected,
        'is-alpha': item._alpha < 100
      }],
      onClick: function onClick($event) {
        return $setup.handleSelect(index);
      }
    }, [vue.createVNode("div", {
      style: {
        'background-color': item.value
      }
    }, null, 4
    /* STYLE */
    )], 10
    /* CLASS, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])]);
}

script$u.render = render$t;
script$u.__file = "src/components/color-picker/predefine.vue";

var script$t = {
  name: 'BColorPicker',
  components: {
    BPopper: script$1F,
    BInput: script$1D,
    BButton: script$1B,
    SvPanel: script$x,
    HueSlider: script$w,
    AlphaSlider: script$v,
    Predefine: script$u
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    modelValue: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: {
      type: String,
      validator: validSize
    },
    popperClass: String,
    colors: Array,
    showLabel: {
      type: Boolean
    }
  },
  emits: ['change', 'active-change', UPDATE_MODEL_EVENT],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useForm = useForm(),
        BForm = _useForm.BForm,
        BFormItem = _useForm.BFormItem,
        formEmit = _useForm.formEmit;

    var hue = vue.ref(null);
    var svPanel = vue.ref(null);
    var alpha = vue.ref(null);
    var popper = vue.ref(null); // data

    var color = vue.reactive(new Color$1({
      enableAlpha: props.showAlpha,
      format: props.colorFormat
    }));
    var showPicker = vue.ref(false);
    var showPanelColor = vue.ref(false);
    var customInput = vue.ref(''); // computed

    var displayedColor = vue.computed(function () {
      if (!props.modelValue && !showPanelColor.value) {
        return 'transparent';
      }

      return displayedRgb(color, props.showAlpha);
    });
    var colorSize = vue.computed(function () {
      return props.size || BFormItem.size;
    });
    var colorDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var currentColor = vue.computed(function () {
      return !props.modelValue && !showPanelColor.value ? '' : color.value;
    }); // watch

    vue.watch(function () {
      return props.modelValue;
    }, function (newVal) {
      if (!newVal) {
        showPanelColor.value = false;
      } else if (newVal && newVal !== color.value) {
        color.fromString(newVal);
      }
    });
    vue.watch(function () {
      return currentColor.value;
    }, function (val) {
      customInput.value = val;
      emit('active-change', val); // showPanelColor.value = true
    });
    vue.watch(function () {
      return color.value;
    }, function () {
      if (!props.modelValue && !showPanelColor.value) {
        showPanelColor.value = true;
      }
    }); // methods

    function displayedRgb(color, showAlpha) {
      if (!(color instanceof Color$1)) {
        throw Error('color should be instance of _color Class');
      }

      var _color$toRgb = color.toRgb(),
          r = _color$toRgb.r,
          g = _color$toRgb.g,
          b = _color$toRgb.b;

      return showAlpha ? "rgba(" + r + ", " + g + ", " + b + ", " + color.get('alpha') / 100 + ")" : "rgb(" + r + ", " + g + ", " + b + ")";
    }

    function setShowPicker(value) {
      showPicker.value = value;
    }

    var debounceSetShowPicker = debounce(setShowPicker, 100);

    function hide() {
      debounceSetShowPicker(false);
      resetColor();
    }

    function resetColor() {
      vue.nextTick(function () {
        if (props.modelValue) {
          color.fromString(props.modelValue);
        } else {
          showPanelColor.value = false;
        }
      });
    }

    function handleTrigger() {
      if (colorDisabled.value) return;
      debounceSetShowPicker(!showPicker.value);
    }

    function handleConfirm() {
      color.fromString(customInput.value);
    }

    function confirmValue() {
      var value = color.value;
      emit(UPDATE_MODEL_EVENT, value);
      emit('change', value);
      formEmit('change', value);
      debounceSetShowPicker(false); // check if modelValue change, if not change, then reset color.

      vue.nextTick(function () {
        var newColor = new Color$1({
          enableAlpha: props.showAlpha,
          format: props.colorFormat
        });
        newColor.fromString(props.modelValue);

        if (!color.compare(newColor)) {
          resetColor();
        }
      });
    }

    function clear() {
      debounceSetShowPicker(false);
      emit(UPDATE_MODEL_EVENT, null);
      emit('change', null);

      if (props.modelValue !== null) {
        formEmit('change', null);
      }

      resetColor();
    }

    vue.onMounted(function () {
      if (props.modelValue) {
        color.fromString(props.modelValue);
        customInput.value = currentColor.value;
      }
    });
    vue.watch(function () {
      return showPicker.value;
    }, function () {
      vue.nextTick(function () {
        var _hue$value, _svPanel$value, _alpha$value;

        (_hue$value = hue.value) == null ? void 0 : _hue$value.update();
        (_svPanel$value = svPanel.value) == null ? void 0 : _svPanel$value.update();
        (_alpha$value = alpha.value) == null ? void 0 : _alpha$value.update();
      });
    });
    vue.provide('ColorPicker', {
      currentColor: currentColor
    });
    return {
      color: color,
      colorDisabled: colorDisabled,
      colorSize: colorSize,
      displayedColor: displayedColor,
      showPanelColor: showPanelColor,
      showPicker: showPicker,
      customInput: customInput,
      BForm: BForm,
      BFormItem: BFormItem,
      formEmit: formEmit,
      handleConfirm: handleConfirm,
      hide: hide,
      handleTrigger: handleTrigger,
      clear: clear,
      confirmValue: confirmValue,
      hue: hue,
      svPanel: svPanel,
      alpha: alpha,
      popper: popper
    };
  }
};

var _hoisted_1$k = {
  class: "bin-color-dropdown__main-wrapper"
};
var _hoisted_2$b = {
  class: "bin-color-dropdown__btns"
};
var _hoisted_3$8 = {
  class: "bin-color-dropdown__value"
};

var _hoisted_4$7 = /*#__PURE__*/vue.createTextVNode(" 清空 ");

var _hoisted_5$6 = /*#__PURE__*/vue.createTextVNode(" 确定 ");

var _hoisted_6$5 = {
  key: 0,
  class: "bin-color-picker__mask"
};
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_hue_slider = vue.resolveComponent("hue-slider");

  var _component_sv_panel = vue.resolveComponent("sv-panel");

  var _component_alpha_slider = vue.resolveComponent("alpha-slider");

  var _component_predefine = vue.resolveComponent("predefine");

  var _component_b_input = vue.resolveComponent("b-input");

  var _component_b_button = vue.resolveComponent("b-button");

  var _component_b_popper = vue.resolveComponent("b-popper");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.openBlock(), vue.createBlock(_component_b_popper, {
    ref: "popper",
    visible: $setup.showPicker,
    "onUpdate:visible": _cache[4] || (_cache[4] = function ($event) {
      return $setup.showPicker = $event;
    }),
    placement: "bottom",
    theme: "light",
    "manual-mode": "",
    trigger: "click",
    "show-arrow": false,
    offset: 4,
    transition: "zoom-in-top",
    "gpu-acceleration": false,
    "popper-class": "bin-color-picker__panel bin-color-dropdown " + $props.popperClass,
    "stop-popper-mouse-event": false
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", null, [vue.createVNode("div", _hoisted_1$k, [vue.createVNode(_component_hue_slider, {
        ref: "hue",
        class: "hue-slider",
        color: $setup.color,
        vertical: ""
      }, null, 8
      /* PROPS */
      , ["color"]), vue.createVNode(_component_sv_panel, {
        ref: "svPanel",
        color: $setup.color
      }, null, 8
      /* PROPS */
      , ["color"])]), $props.showAlpha ? (vue.openBlock(), vue.createBlock(_component_alpha_slider, {
        key: 0,
        ref: "alpha",
        color: $setup.color
      }, null, 8
      /* PROPS */
      , ["color"])) : vue.createCommentVNode("v-if", true), $props.colors ? (vue.openBlock(), vue.createBlock(_component_predefine, {
        key: 1,
        ref: "predefine",
        color: $setup.color,
        colors: $props.colors
      }, null, 8
      /* PROPS */
      , ["color", "colors"])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_2$b, [vue.createVNode("span", _hoisted_3$8, [vue.createVNode(_component_b_input, {
        modelValue: $setup.customInput,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
          return $setup.customInput = $event;
        }),
        "validate-event": false,
        size: "mini",
        onKeyup: vue.withKeys($setup.handleConfirm, ["enter"]),
        onBlur: $setup.handleConfirm
      }, null, 8
      /* PROPS */
      , ["modelValue", "onKeyup", "onBlur"])]), vue.createVNode(_component_b_button, {
        size: "mini",
        type: "text",
        class: "bin-color-dropdown__link-btn",
        onClick: $setup.clear
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_4$7];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        type: "primary",
        size: "mini",
        class: "bin-color-dropdown__btn",
        onClick: $setup.confirmValue
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_5$6];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"])])], 512
      /* NEED_PATCH */
      ), [[_directive_click_outside, $setup.hide]])];
    }),
    trigger: vue.withCtx(function () {
      return [vue.createVNode("div", {
        class: ['bin-color-picker', {
          'show-label': $props.showLabel
        }, $setup.colorDisabled ? 'is-disabled' : '', $setup.colorSize ? "bin-color-picker--" + $setup.colorSize : '']
      }, [$setup.colorDisabled ? (vue.openBlock(), vue.createBlock("div", _hoisted_6$5)) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
        class: "bin-color-picker__trigger",
        onClick: _cache[2] || (_cache[2] = function () {
          return $setup.handleTrigger && $setup.handleTrigger.apply($setup, arguments);
        })
      }, [vue.createVNode("span", {
        class: ["bin-color-picker__color", {
          'is-alpha': $props.showAlpha
        }]
      }, [vue.createVNode("span", {
        class: "bin-color-picker__color-inner",
        style: {
          backgroundColor: $setup.displayedColor
        }
      }, null, 4
      /* STYLE */
      )], 2
      /* CLASS */
      )]), $props.showLabel ? (vue.openBlock(), vue.createBlock("div", {
        key: 1,
        class: "bin-color-picker__label",
        onClick: _cache[3] || (_cache[3] = function () {
          return $setup.handleTrigger && $setup.handleTrigger.apply($setup, arguments);
        })
      }, vue.toDisplayString($props.modelValue), 1
      /* TEXT */
      )) : vue.createCommentVNode("v-if", true)], 2
      /* CLASS */
      )];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["visible", "popper-class"]);
}

script$t.render = render$s;
script$t.__file = "src/components/color-picker/picker.vue";

script$t.install = function (app) {
  app.component(script$t.name, script$t);
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var dayjs_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},D="en",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else {var i=t.name;v[i]=t,r=i;}return !n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this;if(!this.isValid())return $;var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=O.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,f=i.months,h=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(i.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(i.weekdaysMin,this.$W,o,2),ddd:h(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:r};return n.replace(y,(function(t,e){return e||l[t]||r.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));
});

var customParseFormat = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},e=/(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d\d/,r=/\d\d?/,i=/\d*[^\s\d-_:/()]+/,o={};var s=function(t){return function(e){this[t]=+e;}},a=[/[+-]\d\d:?(\d\d)?|Z/,function(t){(this.zone||(this.zone={})).offset=function(t){if(!t)return 0;if("Z"===t)return 0;var e=t.match(/([+-]|\d\d)/g),n=60*e[1]+(+e[2]||0);return 0===n?0:"+"===e[0]?-n:n}(t);}],f=function(t){var e=o[t];return e&&(e.indexOf?e:e.s.concat(e.f))},h=function(t,e){var n,r=o.meridiem;if(r){for(var i=1;i<=24;i+=1)if(t.indexOf(r(i,0,e))>-1){n=i>12;break}}else n=t===(e?"pm":"PM");return n},u={A:[i,function(t){this.afternoon=h(t,!1);}],a:[i,function(t){this.afternoon=h(t,!0);}],S:[/\d/,function(t){this.milliseconds=100*+t;}],SS:[n,function(t){this.milliseconds=10*+t;}],SSS:[/\d{3}/,function(t){this.milliseconds=+t;}],s:[r,s("seconds")],ss:[r,s("seconds")],m:[r,s("minutes")],mm:[r,s("minutes")],H:[r,s("hours")],h:[r,s("hours")],HH:[r,s("hours")],hh:[r,s("hours")],D:[r,s("day")],DD:[n,s("day")],Do:[i,function(t){var e=o.ordinal,n=t.match(/\d+/);if(this.day=n[0],e)for(var r=1;r<=31;r+=1)e(r).replace(/\[|\]/g,"")===t&&(this.day=r);}],M:[r,s("month")],MM:[n,s("month")],MMM:[i,function(t){var e=f("months"),n=(f("monthsShort")||e.map((function(t){return t.substr(0,3)}))).indexOf(t)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[i,function(t){var e=f("months").indexOf(t)+1;if(e<1)throw new Error;this.month=e%12||e;}],Y:[/[+-]?\d+/,s("year")],YY:[n,function(t){t=+t,this.year=t+(t>68?1900:2e3);}],YYYY:[/\d{4}/,s("year")],Z:a,ZZ:a};function d(n){var r,i;r=n,i=o&&o.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(e,n,r){var o=r&&r.toUpperCase();return n||i[r]||t[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(t,e,n){return e||n.slice(1)}))}))).match(e),a=s.length,f=0;f<a;f+=1){var h=s[f],d=u[h],c=d&&d[0],l=d&&d[1];s[f]=l?{regex:c,parser:l}:h.replace(/^\[|\]$/g,"");}return function(t){for(var e={},n=0,r=0;n<a;n+=1){var i=s[n];if("string"==typeof i)r+=i.length;else {var o=i.regex,f=i.parser,h=t.substr(r),u=o.exec(h)[0];f.call(e,u),t=t.replace(u,"");}}return function(t){var e=t.afternoon;if(void 0!==e){var n=t.hours;e?n<12&&(t.hours+=12):12===n&&(t.hours=0),delete t.afternoon;}}(e),e}}return function(t,e,n){n.p.customParseFormat=!0;var r=e.prototype,i=r.parse;r.parse=function(t){var e=t.date,r=t.utc,s=t.args;this.$u=r;var a=s[1];if("string"==typeof a){var f=!0===s[2],h=!0===s[3],u=f||h,c=s[2];h&&(c=s[2]),o=this.$locale(),!f&&c&&(o=n.Ls[c]),this.$d=function(t,e,n){try{var r=d(e)(t),i=r.year,o=r.month,s=r.day,a=r.hours,f=r.minutes,h=r.seconds,u=r.milliseconds,c=r.zone,l=new Date,m=s||(i||o?1:l.getDate()),M=i||l.getFullYear(),Y=0;i&&!o||(Y=o>0?o-1:l.getMonth());var v=a||0,p=f||0,D=h||0,g=u||0;return c?new Date(Date.UTC(M,Y,m,v,p,D,g+60*c.offset*1e3)):n?new Date(Date.UTC(M,Y,m,v,p,D,g)):new Date(M,Y,m,v,p,D,g)}catch(t){return new Date("")}}(e,a,r),this.init(),c&&!0!==c&&(this.$L=this.locale(c).$L),u&&e!==this.format(a)&&(this.$d=new Date("")),o={};}else if(a instanceof Array)for(var l=a.length,m=1;m<=l;m+=1){s[1]=a[m-1];var M=n.apply(this,s);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===l&&(this.$d=new Date(""));}else i.call(this,t);};}}));
});

var DEFAULT_FORMATS_TIME = 'HH:mm:ss';
var DEFAULT_FORMATS_DATE = 'YYYY-MM-DD';
var DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: 'gggg[w]ww',
  year: 'YYYY',
  month: 'YYYY-MM',
  datetime: DEFAULT_FORMATS_DATE + " " + DEFAULT_FORMATS_TIME,
  monthrange: 'YYYY-MM',
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: DEFAULT_FORMATS_DATE + " " + DEFAULT_FORMATS_TIME
};

var defaultProps = {
  name: {
    type: [Array, String],
    default: ''
  },
  popperClass: {
    type: String,
    default: ''
  },
  format: {
    type: String
  },
  type: {
    type: String,
    default: ''
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: String,
    default: 'close-circle-fill'
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: String,
    default: ''
  },
  size: {
    type: String,
    validator: validSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ''
  },
  modelValue: {
    type: [Date, Array, String],
    default: ''
  },
  rangeSeparator: {
    type: String,
    default: '-'
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: function _default() {
      return [];
    }
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};

var dateEquals = function dateEquals(a, b) {
  var aIsDate = a instanceof Date;
  var bIsDate = b instanceof Date;

  if (aIsDate && bIsDate) {
    return a.getTime() === b.getTime();
  }

  if (!aIsDate && !bIsDate) {
    return a === b;
  }

  return false;
};

var valueEquals = function valueEquals(a, b) {
  var aIsArray = a instanceof Array;
  var bIsArray = b instanceof Array;

  if (aIsArray && bIsArray) {
    if (a.length !== b.length) {
      return false;
    }

    return a.every(function (item, index) {
      return dateEquals(item, b[index]);
    });
  }

  if (!aIsArray && !bIsArray) {
    return dateEquals(a, b);
  }

  return false;
};

var script$s = {
  name: 'Picker',
  components: {
    BInput: script$1D,
    BPopper: script$1F
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: defaultProps,
  emits: ['update:modelValue', 'change', 'focus', 'blur'],
  setup: function setup(props, ctx) {
    var _useForm = useForm(),
        BForm = _useForm.BForm,
        BFormItem = _useForm.BFormItem,
        formEmit = _useForm.formEmit;

    var refPopper = vue.ref(null);
    var pickerVisible = vue.ref(false);
    var pickerActualVisible = vue.ref(false);
    var valueOnOpen = vue.ref(null);
    vue.watch(pickerVisible, function (val) {
      if (!val) {
        userInput.value = null;
        vue.nextTick(function () {
          emitChange(props.modelValue);
        });
        ctx.emit('blur');
        blurInput();
        props.validateEvent && formEmit('blur');
      } else {
        valueOnOpen.value = props.modelValue;
      }
    });

    var emitChange = function emitChange(val, isClear) {
      // determine user real change only
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        ctx.emit('change', val);
        props.validateEvent && formEmit('change', val);
      }
    };

    var emitInput = function emitInput(val) {
      if (!valueEquals(props.modelValue, val)) {
        ctx.emit('update:modelValue', val);
      }
    };

    var refInput = vue.computed(function () {
      if (refPopper.value.triggerRef) {
        var _r = isRangeInput.value ? refPopper.value.triggerRef : refPopper.value.triggerRef.$el;

        return [].slice.call(_r.querySelectorAll('input'));
      }

      return [];
    });

    var setSelectionRange = function setSelectionRange(start, end, pos) {
      var _inputs = refInput.value;
      if (!_inputs.length) return;

      if (!pos || pos === 'min') {
        _inputs[0].setSelectionRange(start, end);

        _inputs[0].focus();
      } else if (pos === 'max') {
        _inputs[1].setSelectionRange(start, end);

        _inputs[1].focus();
      }
    };

    var onPick = function onPick(date, visible) {
      if (date === void 0) {
        date = '';
      }

      if (visible === void 0) {
        visible = false;
      }

      pickerVisible.value = visible;
      var result;

      if (Array.isArray(date)) {
        result = date.map(function (_) {
          return _.toDate();
        });
      } else {
        // clear btn emit null
        result = date ? date.toDate() : date;
      }

      userInput.value = null;
      emitInput(result);
    };

    var handleFocus = function handleFocus(e) {
      if (props.readonly || pickerDisabled.value) return;
      pickerVisible.value = true;
      ctx.emit('focus', e);
    };

    var pickerDisabled = vue.computed(function () {
      return props.disabled || BForm.disabled;
    });
    var parsedValue = vue.computed(function () {
      var result;

      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          result = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (Array.isArray(props.modelValue)) {
          result = props.modelValue.map(function (_) {
            return dayjs_min(_);
          });
        } else {
          result = dayjs_min(props.modelValue);
        }
      }

      if (pickerOptions.value.getRangeAvaliableTime) {
        result = pickerOptions.value.getRangeAvaliableTime(result);
      }

      return result;
    });
    var displayValue = vue.computed(function () {
      if (!pickerOptions.value.panelReady) return;
      var formattedValue = formatDayjsToString(parsedValue.value);

      if (Array.isArray(userInput.value)) {
        return [userInput.value[0] || formattedValue && formattedValue[0] || '', userInput.value[1] || formattedValue && formattedValue[1] || ''];
      } else if (userInput.value !== null) {
        return userInput.value;
      }

      if (!isTimePicker.value && valueIsEmpty.value) return;
      if (!pickerVisible.value && valueIsEmpty.value) return;

      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(', ') : formattedValue;
      }

      return '';
    });
    var isTimeLikePicker = vue.computed(function () {
      return props.type.indexOf('time') !== -1;
    });
    var isTimePicker = vue.computed(function () {
      return props.type.indexOf('time') === 0;
    });
    var isDatesPicker = vue.computed(function () {
      return props.type === 'dates';
    });
    var triggerClass = vue.computed(function () {
      return props.prefixIcon || (isTimeLikePicker.value ? 'b-icon-time-circle' : 'b-icon-calendar');
    });
    var showClose = vue.ref(false);

    var onClearIconClick = function onClearIconClick(event) {
      if (props.readonly || pickerDisabled.value) return;

      if (showClose.value) {
        event.stopPropagation();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };

    var valueIsEmpty = vue.computed(function () {
      return !props.modelValue || Array.isArray(props.modelValue) && !props.modelValue.length;
    });

    var onMouseEnter = function onMouseEnter() {
      if (props.readonly || pickerDisabled.value) return;

      if (!valueIsEmpty.value && props.clearable) {
        showClose.value = true;
      }
    };

    var onMouseLeave = function onMouseLeave() {
      showClose.value = false;
    };

    var isRangeInput = vue.computed(function () {
      return props.type.indexOf('range') > -1;
    });
    var pickerSize = vue.computed(function () {
      return props.size || BFormItem.size;
    });
    var popperPaneRef = vue.computed(function () {
      var _refPopper$value;

      return (_refPopper$value = refPopper.value) == null ? void 0 : _refPopper$value.popperRef;
    });

    var onClickOutside = function onClickOutside() {
      if (!pickerVisible.value) return;
      pickerVisible.value = false;
    };

    var userInput = vue.ref(null);

    var handleChange = function handleChange() {
      if (userInput.value) {
        var value = parseUserInputToDayjs(displayValue.value);

        if (value) {
          if (isValidValue(value)) {
            emitInput(Array.isArray(value) ? value.map(function (_) {
              return _.toDate();
            }) : value.toDate());
            userInput.value = null;
          }
        }
      }

      if (userInput.value === '') {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };

    var blurInput = function blurInput() {
      refInput.value.forEach(function (input) {
        return input.blur();
      });
    };

    var parseUserInputToDayjs = function parseUserInputToDayjs(value) {
      if (!value) return null;
      return pickerOptions.value.parseUserInput(value);
    };

    var formatDayjsToString = function formatDayjsToString(value) {
      if (!value) return null;
      return pickerOptions.value.formatToString(value);
    };

    var isValidValue = function isValidValue(value) {
      return pickerOptions.value.isValidValue(value);
    };

    var handleKeydown = function handleKeydown(event) {
      var code = event.code;

      if (code === EVENT_CODE.esc) {
        pickerVisible.value = false;
        event.stopPropagation();
        return;
      }

      if (code === EVENT_CODE.tab) {
        if (!isRangeInput.value) {
          handleChange();
          pickerVisible.value = false;
          event.stopPropagation();
        } else {
          // user may change focus between two input
          setTimeout(function () {
            if (refInput.value.indexOf(document.activeElement) === -1) {
              pickerVisible.value = false;
              blurInput();
            }
          }, 0);
        }

        return;
      }

      if (code === EVENT_CODE.enter) {
        if (userInput.value === '' || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }

        event.stopPropagation();
        return;
      } // if user is typing, do not let picker handle key input


      if (userInput.value) {
        event.stopPropagation();
        return;
      }

      if (pickerOptions.value.handleKeydown) {
        pickerOptions.value.handleKeydown(event);
      }
    };

    var onUserInput = function onUserInput(e) {
      userInput.value = e;
    };

    var handleStartInput = function handleStartInput(event) {
      if (userInput.value) {
        userInput.value = [event.target.value, userInput.value[1]];
      } else {
        userInput.value = [event.target.value, null];
      }
    };

    var handleEndInput = function handleEndInput(event) {
      if (userInput.value) {
        userInput.value = [userInput.value[0], event.target.value];
      } else {
        userInput.value = [null, event.target.value];
      }
    };

    var handleStartChange = function handleStartChange() {
      var value = parseUserInputToDayjs(userInput.value && userInput.value[0]);

      if (value && value.isValid()) {
        userInput.value = [formatDayjsToString(value), displayValue.value[1]];
        var newValue = [value, parsedValue.value && parsedValue.value[1]];

        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };

    var handleEndChange = function handleEndChange() {
      var value = parseUserInputToDayjs(userInput.value && userInput.value[1]);

      if (value && value.isValid()) {
        userInput.value = [displayValue.value[0], formatDayjsToString(value)];
        var newValue = [parsedValue.value && parsedValue.value[0], value];

        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };

    var pickerOptions = vue.ref({});

    var onSetPickerOption = function onSetPickerOption(e) {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };

    vue.provide('EP_PICKER_BASE', {
      props: props
    });
    return {
      isDatesPicker: isDatesPicker,
      handleEndChange: handleEndChange,
      handleStartChange: handleStartChange,
      handleStartInput: handleStartInput,
      handleEndInput: handleEndInput,
      onUserInput: onUserInput,
      handleChange: handleChange,
      handleKeydown: handleKeydown,
      popperPaneRef: popperPaneRef,
      onClickOutside: onClickOutside,
      pickerSize: pickerSize,
      isRangeInput: isRangeInput,
      onMouseLeave: onMouseLeave,
      onMouseEnter: onMouseEnter,
      onClearIconClick: onClearIconClick,
      showClose: showClose,
      triggerClass: triggerClass,
      onPick: onPick,
      handleFocus: handleFocus,
      pickerVisible: pickerVisible,
      pickerActualVisible: pickerActualVisible,
      displayValue: displayValue,
      parsedValue: parsedValue,
      setSelectionRange: setSelectionRange,
      refPopper: refPopper,
      pickerDisabled: pickerDisabled,
      onSetPickerOption: onSetPickerOption
    };
  }
};

var _hoisted_1$j = {
  class: "bin-range-separator"
};
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_input = vue.resolveComponent("b-input");

  var _component_b_popper = vue.resolveComponent("b-popper");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.openBlock(), vue.createBlock(_component_b_popper, vue.mergeProps({
    ref: "refPopper",
    visible: $setup.pickerVisible,
    "onUpdate:visible": _cache[18] || (_cache[18] = function ($event) {
      return $setup.pickerVisible = $event;
    }),
    "manual-mode": "",
    theme: "light",
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    placement: "bottom-start",
    "popper-class": "bin-picker__popper " + _ctx.popperClass,
    transition: "zoom-in-top",
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "show-arrow": false,
    offset: 4,
    "append-to-body": "",
    onBeforeEnter: _cache[19] || (_cache[19] = function ($event) {
      return $setup.pickerActualVisible = true;
    }),
    onAfterLeave: _cache[20] || (_cache[20] = function ($event) {
      return $setup.pickerActualVisible = false;
    })
  }), {
    trigger: vue.withCtx(function () {
      return [!$setup.isRangeInput ? vue.withDirectives((vue.openBlock(), vue.createBlock(_component_b_input, {
        key: 0,
        "model-value": $setup.displayValue,
        name: _ctx.name,
        size: $setup.pickerSize,
        disabled: $setup.pickerDisabled,
        placeholder: _ctx.placeholder,
        class: ["bin-date-editor", 'bin-date-editor--' + _ctx.type],
        readonly: !_ctx.editable || _ctx.readonly || $setup.isDatesPicker || _ctx.type === 'week',
        onInput: $setup.onUserInput,
        onFocus: $setup.handleFocus,
        onKeydown: $setup.handleKeydown,
        onChange: $setup.handleChange,
        onMouseenter: $setup.onMouseEnter,
        onMouseleave: $setup.onMouseLeave
      }, {
        prefix: vue.withCtx(function () {
          return [vue.createVNode("i", {
            class: ["b-iconfont", $setup.triggerClass],
            onClick: _cache[1] || (_cache[1] = function () {
              return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
            })
          }, null, 2
          /* CLASS */
          )];
        }),
        suffix: vue.withCtx(function () {
          return [vue.createVNode("i", {
            class: ["b-iconfont", [$setup.showClose ? 'b-icon-' + _ctx.clearIcon : '']],
            onClick: _cache[2] || (_cache[2] = function () {
              return $setup.onClearIconClick && $setup.onClearIconClick.apply($setup, arguments);
            })
          }, null, 2
          /* CLASS */
          )];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["model-value", "name", "size", "disabled", "placeholder", "class", "readonly", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])), [[_directive_click_outside, $setup.onClickOutside, $setup.popperPaneRef]]) : vue.withDirectives((vue.openBlock(), vue.createBlock("div", {
        key: 1,
        class: ["bin-date-editor bin-range-editor bin-input", ['bin-date-editor--' + _ctx.type, $setup.pickerSize ? "bin-range-editor--" + $setup.pickerSize : '', $setup.pickerDisabled ? 'is-disabled' : '', $setup.pickerVisible ? 'is-active' : '']],
        onClick: _cache[10] || (_cache[10] = function () {
          return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
        }),
        onMouseenter: _cache[11] || (_cache[11] = function () {
          return $setup.onMouseEnter && $setup.onMouseEnter.apply($setup, arguments);
        }),
        onMouseleave: _cache[12] || (_cache[12] = function () {
          return $setup.onMouseLeave && $setup.onMouseLeave.apply($setup, arguments);
        }),
        onKeydown: _cache[13] || (_cache[13] = function () {
          return $setup.handleKeydown && $setup.handleKeydown.apply($setup, arguments);
        })
      }, [vue.createVNode("i", {
        class: ['bin-input__icon b-iconfont', 'bin-range__icon', $setup.triggerClass]
      }, null, 2
      /* CLASS */
      ), vue.createVNode("input", {
        autocomplete: "off",
        name: _ctx.name && _ctx.name[0],
        placeholder: _ctx.startPlaceholder,
        value: $setup.displayValue && $setup.displayValue[0],
        disabled: $setup.pickerDisabled,
        readonly: !_ctx.editable || _ctx.readonly,
        class: "bin-range-input",
        onInput: _cache[3] || (_cache[3] = function () {
          return $setup.handleStartInput && $setup.handleStartInput.apply($setup, arguments);
        }),
        onChange: _cache[4] || (_cache[4] = function () {
          return $setup.handleStartChange && $setup.handleStartChange.apply($setup, arguments);
        }),
        onFocus: _cache[5] || (_cache[5] = function () {
          return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
        })
      }, null, 40
      /* PROPS, HYDRATE_EVENTS */
      , ["name", "placeholder", "value", "disabled", "readonly"]), vue.renderSlot(_ctx.$slots, "range-separator", {}, function () {
        return [vue.createVNode("span", _hoisted_1$j, vue.toDisplayString(_ctx.rangeSeparator), 1
        /* TEXT */
        )];
      }), vue.createVNode("input", {
        autocomplete: "off",
        name: _ctx.name && _ctx.name[1],
        placeholder: _ctx.endPlaceholder,
        value: $setup.displayValue && $setup.displayValue[1],
        disabled: $setup.pickerDisabled,
        readonly: !_ctx.editable || _ctx.readonly,
        class: "bin-range-input",
        onFocus: _cache[6] || (_cache[6] = function () {
          return $setup.handleFocus && $setup.handleFocus.apply($setup, arguments);
        }),
        onInput: _cache[7] || (_cache[7] = function () {
          return $setup.handleEndInput && $setup.handleEndInput.apply($setup, arguments);
        }),
        onChange: _cache[8] || (_cache[8] = function () {
          return $setup.handleEndChange && $setup.handleEndChange.apply($setup, arguments);
        })
      }, null, 40
      /* PROPS, HYDRATE_EVENTS */
      , ["name", "placeholder", "value", "disabled", "readonly"]), vue.createVNode("i", {
        class: ["bin-input__icon b-iconfont", [$setup.showClose ? 'b-icon-' + _ctx.clearIcon : '']],
        onClick: _cache[9] || (_cache[9] = function () {
          return $setup.onClearIconClick && $setup.onClearIconClick.apply($setup, arguments);
        })
      }, null, 2
      /* CLASS */
      )], 34
      /* CLASS, HYDRATE_EVENTS */
      )), [[_directive_click_outside, $setup.onClickOutside, $setup.popperPaneRef]])];
    }),
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {
        visible: $setup.pickerVisible,
        actualVisible: $setup.pickerActualVisible,
        parsedValue: $setup.parsedValue,
        format: _ctx.format,
        unlinkPanels: _ctx.unlinkPanels,
        type: _ctx.type,
        defaultValue: _ctx.defaultValue,
        onPick: _cache[14] || (_cache[14] = function () {
          return $setup.onPick && $setup.onPick.apply($setup, arguments);
        }),
        onSelectRange: _cache[15] || (_cache[15] = function () {
          return $setup.setSelectionRange && $setup.setSelectionRange.apply($setup, arguments);
        }),
        onSetPickerOption: _cache[16] || (_cache[16] = function () {
          return $setup.onSetPickerOption && $setup.onSetPickerOption.apply($setup, arguments);
        }),
        onMousedown: _cache[17] || (_cache[17] = vue.withModifiers(function () {}, ["stop"]))
      })];
    }),
    _: 1
    /* STABLE */

  }, 16
  /* FULL_PROPS */
  , ["visible", "popper-class"]);
}

script$s.render = render$r;
script$s.__file = "src/components/time-picker/common/picker.vue";

var makeList = function makeList(total, method, methodFunc) {
  var arr = [];
  var disabledArr = method && methodFunc();

  for (var i = 0; i < total; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }

  return arr;
};

var makeAvaliableArr = function makeAvaliableArr(list) {
  return list.map(function (_, index) {
    return !_ ? index : _;
  }).filter(function (_) {
    return _ !== true;
  });
};

var getTimeLists = function getTimeLists(disabledHours, disabledMinutes, disabledSeconds) {
  var getHoursList = function getHoursList(role, compare) {
    return makeList(24, disabledHours, function () {
      return disabledHours(role, compare);
    });
  };

  var getMinutesList = function getMinutesList(hour, role, compare) {
    return makeList(60, disabledMinutes, function () {
      return disabledMinutes(hour, role, compare);
    });
  };

  var getSecondsList = function getSecondsList(hour, minute, role, compare) {
    return makeList(60, disabledSeconds, function () {
      return disabledSeconds(hour, minute, role, compare);
    });
  };

  return {
    getHoursList: getHoursList,
    getMinutesList: getMinutesList,
    getSecondsList: getSecondsList
  };
};
var getAvaliableArrs = function getAvaliableArrs(disabledHours, disabledMinutes, disabledSeconds) {
  var _getTimeLists = getTimeLists(disabledHours, disabledMinutes, disabledSeconds),
      getHoursList = _getTimeLists.getHoursList,
      getMinutesList = _getTimeLists.getMinutesList,
      getSecondsList = _getTimeLists.getSecondsList;

  var getAvaliableHours = function getAvaliableHours(role, compare) {
    return makeAvaliableArr(getHoursList(role, compare));
  };

  var getAvaliableMinutes = function getAvaliableMinutes(hour, role, compare) {
    return makeAvaliableArr(getMinutesList(hour, role, compare));
  };

  var getAvaliableSeconds = function getAvaliableSeconds(hour, minute, role, compare) {
    return makeAvaliableArr(getSecondsList(hour, minute, role, compare));
  };

  return {
    getAvaliableHours: getAvaliableHours,
    getAvaliableMinutes: getAvaliableMinutes,
    getAvaliableSeconds: getAvaliableSeconds
  };
};
var useOldValue = function useOldValue(props) {
  var oldValue = vue.ref(props.parsedValue);
  vue.watch(function () {
    return props.visible;
  }, function (val) {
    if (!val) {
      oldValue.value = props.parsedValue;
    }
  });
  return oldValue;
};

var script$r = {
  components: {
    BScrollbar: script$1C
  },
  props: {
    role: {
      type: String,
      required: true
    },
    spinnerDate: {
      type: Object,
      required: true
    },
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean,
    amPmMode: {
      type: String,
      default: '' // 'a': am/pm; 'A': AM/PM

    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    }
  },
  emits: ['change', 'select-range', 'set-option'],
  setup: function setup(props, ctx) {
    // data
    var isScrolling = false;
    var debouncedResetScroll = debounce(function (type) {
      isScrolling = false;
      adjustCurrentSpinner(type);
    }, 200);
    var currentScrollbar = vue.ref(null);
    var listHoursRef = vue.ref(null);
    var listMinutesRef = vue.ref(null);
    var listSecondsRef = vue.ref(null);
    var listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    }; // computed

    var spinnerItems = vue.computed(function () {
      var arr = ['hours', 'minutes', 'seconds'];
      return props.showSeconds ? arr : arr.slice(0, 2);
    });
    var hours = vue.computed(function () {
      return props.spinnerDate.hour();
    });
    var minutes = vue.computed(function () {
      return props.spinnerDate.minute();
    });
    var seconds = vue.computed(function () {
      return props.spinnerDate.second();
    });
    var timePartsMap = vue.computed(function () {
      return {
        hours: hours,
        minutes: minutes,
        seconds: seconds
      };
    });
    var hoursList = vue.computed(function () {
      return getHoursList(props.role);
    });
    var minutesList = vue.computed(function () {
      return getMinutesList(hours.value, props.role);
    });
    var secondsList = vue.computed(function () {
      return getSecondsList(hours.value, minutes.value, props.role);
    });
    var listMap = vue.computed(function () {
      return {
        hours: hoursList,
        minutes: minutesList,
        seconds: secondsList
      };
    });
    var arrowHourList = vue.computed(function () {
      var hour = hours.value;
      return [hour > 0 ? hour - 1 : undefined, hour, hour < 23 ? hour + 1 : undefined];
    });
    var arrowMinuteList = vue.computed(function () {
      var minute = minutes.value;
      return [minute > 0 ? minute - 1 : undefined, minute, minute < 59 ? minute + 1 : undefined];
    });
    var arrowSecondList = vue.computed(function () {
      var second = seconds.value;
      return [second > 0 ? second - 1 : undefined, second, second < 59 ? second + 1 : undefined];
    });
    var arrowListMap = vue.computed(function () {
      return {
        hours: arrowHourList,
        minutes: arrowMinuteList,
        seconds: arrowSecondList
      };
    });

    var getAmPmFlag = function getAmPmFlag(hour) {
      var shouldShowAmPm = !!props.amPmMode;
      if (!shouldShowAmPm) return '';
      var isCapital = props.amPmMode === 'A'; // todo locale

      var content = hour < 12 ? ' am' : ' pm';
      if (isCapital) content = content.toUpperCase();
      return content;
    };

    var emitSelectRange = function emitSelectRange(type) {
      if (type === 'hours') {
        ctx.emit('select-range', 0, 2);
      } else if (type === 'minutes') {
        ctx.emit('select-range', 3, 5);
      } else if (type === 'seconds') {
        ctx.emit('select-range', 6, 8);
      }

      currentScrollbar.value = type;
    };

    var adjustCurrentSpinner = function adjustCurrentSpinner(type) {
      adjustSpinner(type, timePartsMap.value[type].value);
    }; // NOTE: used by datetime / date-range panel
    //       renamed from adjustScrollTop
    //       should try to refactory it


    var adjustSpinners = function adjustSpinners() {
      adjustCurrentSpinner('hours');
      adjustCurrentSpinner('minutes');
      adjustCurrentSpinner('seconds');
    };

    var adjustSpinner = function adjustSpinner(type, value) {
      if (props.arrowControl) return;
      var el = listRefsMap[type];

      if (el.value) {
        el.value.$el.querySelector('.bin-scrollbar__wrap').scrollTop = Math.max(0, value * typeItemHeight(type));
      }
    };

    var typeItemHeight = function typeItemHeight(type) {
      var el = listRefsMap[type];
      return el.value.$el.querySelector('li').offsetHeight;
    };

    var onIncreaseClick = function onIncreaseClick() {
      scrollDown(1);
    };

    var onDecreaseClick = function onDecreaseClick() {
      scrollDown(-1);
    };

    var scrollDown = function scrollDown(step) {
      if (!currentScrollbar.value) {
        emitSelectRange('hours');
      }

      var label = currentScrollbar.value;
      var now = timePartsMap.value[label].value;
      var total = currentScrollbar.value === 'hours' ? 24 : 60;
      now = (now + step + total) % total;
      modifyDateField(label, now);
      adjustSpinner(label, now);
      vue.nextTick(function () {
        return emitSelectRange(currentScrollbar.value);
      });
    };

    var modifyDateField = function modifyDateField(type, value) {
      var list = listMap.value[type].value;
      var isDisabled = list[value];
      if (isDisabled) return;

      switch (type) {
        case 'hours':
          ctx.emit('change', props.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
          break;

        case 'minutes':
          ctx.emit('change', props.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
          break;

        case 'seconds':
          ctx.emit('change', props.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
          break;
      }
    };

    var handleClick = function handleClick(type, _ref) {
      var value = _ref.value,
          disabled = _ref.disabled;

      if (!disabled) {
        modifyDateField(type, value);
        emitSelectRange(type);
        adjustSpinner(type, value);
      }
    };

    var handleScroll = function handleScroll(type) {
      isScrolling = true;
      debouncedResetScroll(type);
      var value = Math.min(Math.round((listRefsMap[type].value.$el.querySelector('.bin-scrollbar__wrap').scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === 'hours' ? 23 : 59);
      modifyDateField(type, value);
    };

    var scrollBarHeight = function scrollBarHeight(type) {
      return listRefsMap[type].value.$el.offsetHeight;
    };

    var bindScrollEvent = function bindScrollEvent() {
      var bindFuntion = function bindFuntion(type) {
        if (listRefsMap[type].value) {
          listRefsMap[type].value.$el.querySelector('.bin-scrollbar__wrap').onscroll = function () {
            // TODO: scroll is emitted when set scrollTop programatically
            // should find better solutions in the future!
            handleScroll(type);
          };
        }
      };

      bindFuntion('hours');
      bindFuntion('minutes');
      bindFuntion('seconds');
    };

    vue.onMounted(function () {
      vue.nextTick(function () {
        !props.arrowControl && bindScrollEvent();
        adjustSpinners(); // set selection on the first hour part

        if (props.role === 'start') emitSelectRange('hours');
      });
    });

    var getRefId = function getRefId(item) {
      return "list" + (item.charAt(0).toUpperCase() + item.slice(1)) + "Ref";
    };

    ctx.emit('set-option', [props.role + "_scrollDown", scrollDown]);
    ctx.emit('set-option', [props.role + "_emitSelectRange", emitSelectRange]);

    var _getTimeLists = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds),
        getHoursList = _getTimeLists.getHoursList,
        getMinutesList = _getTimeLists.getMinutesList,
        getSecondsList = _getTimeLists.getSecondsList;

    vue.watch(function () {
      return props.spinnerDate;
    }, function () {
      if (isScrolling) return;
      adjustSpinners();
    });
    return {
      getRefId: getRefId,
      spinnerItems: spinnerItems,
      currentScrollbar: currentScrollbar,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
      hoursList: hoursList,
      minutesList: minutesList,
      arrowHourList: arrowHourList,
      arrowMinuteList: arrowMinuteList,
      arrowSecondList: arrowSecondList,
      getAmPmFlag: getAmPmFlag,
      emitSelectRange: emitSelectRange,
      adjustCurrentSpinner: adjustCurrentSpinner,
      typeItemHeight: typeItemHeight,
      listHoursRef: listHoursRef,
      listMinutesRef: listMinutesRef,
      listSecondsRef: listSecondsRef,
      onIncreaseClick: onIncreaseClick,
      onDecreaseClick: onDecreaseClick,
      handleClick: handleClick,
      secondsList: secondsList,
      timePartsMap: timePartsMap,
      arrowListMap: arrowListMap,
      listMap: listMap
    };
  }
};

var _hoisted_1$i = {
  class: "bin-time-spinner__list"
};
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_scrollbar = vue.resolveComponent("b-scrollbar");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-time-spinner", {
      'has-seconds': $props.showSeconds
    }]
  }, [!$props.arrowControl ? (vue.openBlock(true), vue.createBlock(vue.Fragment, {
    key: 0
  }, vue.renderList($setup.spinnerItems, function (item) {
    return vue.openBlock(), vue.createBlock(_component_b_scrollbar, {
      key: item,
      ref: $setup.getRefId(item),
      class: "bin-time-spinner__wrapper",
      "wrap-style": "max-height: inherit;",
      "view-class": "bin-time-spinner__list",
      noresize: "",
      tag: "ul",
      onMouseenter: function onMouseenter($event) {
        return $setup.emitSelectRange(item);
      },
      onMousemove: function onMousemove($event) {
        return $setup.adjustCurrentSpinner(item);
      }
    }, {
      default: vue.withCtx(function () {
        return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.listMap[item].value, function (disabled, key) {
          return vue.openBlock(), vue.createBlock("li", {
            key: key,
            class: ["bin-time-spinner__item", {
              'active': key === $setup.timePartsMap[item].value,
              disabled: disabled
            }],
            onClick: function onClick($event) {
              return $setup.handleClick(item, {
                value: key,
                disabled: disabled
              });
            }
          }, [item === 'hours' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
            key: 0
          }, [vue.createTextVNode(vue.toDisplayString(('0' + ($props.amPmMode ? key % 12 || 12 : key)).slice(-2)) + vue.toDisplayString($setup.getAmPmFlag(key)), 1
          /* TEXT */
          )], 2112
          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
            key: 1
          }, [vue.createTextVNode(vue.toDisplayString(('0' + key).slice(-2)), 1
          /* TEXT */
          )], 2112
          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
          ))], 10
          /* CLASS, PROPS */
          , ["onClick"]);
        }), 128
        /* KEYED_FRAGMENT */
        ))];
      }),
      _: 2
      /* DYNAMIC */

    }, 1032
    /* PROPS, DYNAMIC_SLOTS */
    , ["onMouseenter", "onMousemove"]);
  }), 128
  /* KEYED_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true), $props.arrowControl ? (vue.openBlock(true), vue.createBlock(vue.Fragment, {
    key: 1
  }, vue.renderList($setup.spinnerItems, function (item) {
    return vue.openBlock(), vue.createBlock("div", {
      key: item,
      class: "bin-time-spinner__wrapper is-arrow",
      onMouseenter: function onMouseenter($event) {
        return $setup.emitSelectRange(item);
      }
    }, [vue.createVNode("i", {
      onClick: _cache[1] || (_cache[1] = function () {
        return $setup.onDecreaseClick && $setup.onDecreaseClick.apply($setup, arguments);
      }),
      class: "bin-time-spinner__arrow b-iconfont b-icon-up"
    }), vue.createVNode("i", {
      onClick: _cache[2] || (_cache[2] = function () {
        return $setup.onIncreaseClick && $setup.onIncreaseClick.apply($setup, arguments);
      }),
      class: "bin-time-spinner__arrow b-iconfont b-icon-down"
    }), vue.createVNode("ul", _hoisted_1$i, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.arrowListMap[item].value, function (time, key) {
      return vue.openBlock(), vue.createBlock("li", {
        key: key,
        class: ["bin-time-spinner__item", {
          'active': time === $setup.timePartsMap[item].value,
          'disabled': $setup.listMap[item].value[time]
        }]
      }, vue.toDisplayString(time === undefined ? '' : ('0' + ($props.amPmMode ? time % 12 || 12 : time)).slice(-2) + $setup.getAmPmFlag(time)), 3
      /* TEXT, CLASS */
      );
    }), 128
    /* KEYED_FRAGMENT */
    ))])], 40
    /* PROPS, HYDRATE_EVENTS */
    , ["onMouseenter"]);
  }), 128
  /* KEYED_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$r.render = render$q;
script$r.__file = "src/components/time-picker/time-picker-com/basic-time-spinner.vue";

var script$q = {
  components: {
    BButton: script$1B,
    TimeSpinner: script$r
  },
  props: {
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: undefined
    },
    datetimeRole: {
      type: String
    },
    parsedValue: {
      type: [Object, String]
    },
    format: {
      type: String,
      default: ''
    }
  },
  emits: ['pick', 'select-range', 'set-picker-option'],
  setup: function setup(props, ctx) {
    // data
    var selectionRange = vue.ref([0, 2]);
    var oldValue = useOldValue(props); // computed

    var transitionName = vue.computed(function () {
      return props.actualVisible === undefined ? 'zoom-in-top' : '';
    });
    var showSeconds = vue.computed(function () {
      return props.format.includes('ss');
    });
    var amPmMode = vue.computed(function () {
      if (props.format.includes('A')) return 'A';
      if (props.format.includes('a')) return 'a';
      return '';
    }); // method

    var isValidValue = function isValidValue(_date) {
      var parsedDate = dayjs_min(_date);
      var result = getRangeAvaliableTime(parsedDate);
      return parsedDate.isSame(result);
    };

    var handleCancel = function handleCancel() {
      ctx.emit('pick', oldValue.value, false);
    };

    var handleConfirm = function handleConfirm(visible, first) {
      if (visible === void 0) {
        visible = false;
      }

      if (first) return;
      ctx.emit('pick', props.parsedValue, visible);
    };

    var handleChange = function handleChange(_date) {
      // visible avoids edge cases, when use scrolls during panel closing animation
      if (!props.visible) {
        return;
      }

      var result = getRangeAvaliableTime(_date).millisecond(0);
      ctx.emit('pick', result, true);
    };

    var setSelectionRange = function setSelectionRange(start, end) {
      ctx.emit('select-range', start, end);
      selectionRange.value = [start, end];
    };

    var changeSelectionRange = function changeSelectionRange(step) {
      var list = [0, 3].concat(showSeconds.value ? [6] : []);
      var mapping = ['hours', 'minutes'].concat(showSeconds.value ? ['seconds'] : []);
      var index = list.indexOf(selectionRange.value[0]);
      var next = (index + step + list.length) % list.length;
      timePickeOptions['start_emitSelectRange'](mapping[next]);
    };

    var handleKeydown = function handleKeydown(event) {
      var code = event.code;

      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        var step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        var _step = code === EVENT_CODE.up ? -1 : 1;

        timePickeOptions['start_scrollDown'](_step);
        event.preventDefault();
        return;
      }
    };

    var getRangeAvaliableTime = function getRangeAvaliableTime(date) {
      var avaliableMap = {
        hour: getAvaliableHours,
        minute: getAvaliableMinutes,
        second: getAvaliableSeconds
      };
      var result = date;
      ['hour', 'minute', 'second'].forEach(function (_) {
        if (avaliableMap[_]) {
          var avaliableArr;
          var method = avaliableMap[_];

          if (_ === 'minute') {
            avaliableArr = method(result.hour(), props.datetimeRole);
          } else if (_ === 'second') {
            avaliableArr = method(result.hour(), result.minute(), props.datetimeRole);
          } else {
            avaliableArr = method(props.datetimeRole);
          }

          if (avaliableArr && avaliableArr.length && !avaliableArr.includes(result[_]())) {
            result = result[_](avaliableArr[0]);
          }
        }
      });
      return result;
    };

    var parseUserInput = function parseUserInput(value) {
      if (!value) return null;
      return dayjs_min(value, props.format);
    };

    var formatToString = function formatToString(value) {
      if (!value) return null;
      return value.format(props.format);
    };

    var getDefaultValue = function getDefaultValue() {
      return dayjs_min(defaultValue);
    };

    ctx.emit('set-picker-option', ['isValidValue', isValidValue]);
    ctx.emit('set-picker-option', ['formatToString', formatToString]);
    ctx.emit('set-picker-option', ['parseUserInput', parseUserInput]);
    ctx.emit('set-picker-option', ['handleKeydown', handleKeydown]);
    ctx.emit('set-picker-option', ['getRangeAvaliableTime', getRangeAvaliableTime]);
    ctx.emit('set-picker-option', ['getDefaultValue', getDefaultValue]);
    var timePickeOptions = {};

    var onSetOption = function onSetOption(e) {
      timePickeOptions[e[0]] = e[1];
    };

    var pickerBase = vue.inject('EP_PICKER_BASE');
    var _pickerBase$props = pickerBase.props,
        arrowControl = _pickerBase$props.arrowControl,
        disabledHours = _pickerBase$props.disabledHours,
        disabledMinutes = _pickerBase$props.disabledMinutes,
        disabledSeconds = _pickerBase$props.disabledSeconds,
        defaultValue = _pickerBase$props.defaultValue;

    var _getAvaliableArrs = getAvaliableArrs(disabledHours, disabledMinutes, disabledSeconds),
        getAvaliableHours = _getAvaliableArrs.getAvaliableHours,
        getAvaliableMinutes = _getAvaliableArrs.getAvaliableMinutes,
        getAvaliableSeconds = _getAvaliableArrs.getAvaliableSeconds;

    return {
      transitionName: transitionName,
      arrowControl: arrowControl,
      onSetOption: onSetOption,
      handleConfirm: handleConfirm,
      handleChange: handleChange,
      setSelectionRange: setSelectionRange,
      amPmMode: amPmMode,
      showSeconds: showSeconds,
      handleCancel: handleCancel,
      disabledHours: disabledHours,
      disabledMinutes: disabledMinutes,
      disabledSeconds: disabledSeconds
    };
  }
};

var _hoisted_1$h = {
  key: 0,
  class: "bin-time-panel"
};
var _hoisted_2$a = {
  class: "bin-time-panel__footer"
};

var _hoisted_3$7 = /*#__PURE__*/vue.createTextVNode(" 取消 ");

var _hoisted_4$6 = /*#__PURE__*/vue.createTextVNode(" 确定 ");

function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_time_spinner = vue.resolveComponent("time-spinner");

  var _component_b_button = vue.resolveComponent("b-button");

  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: $setup.transitionName
  }, {
    default: vue.withCtx(function () {
      return [$props.actualVisible || $props.visible ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$h, [vue.createVNode("div", {
        class: ["bin-time-panel__content", {
          'has-seconds': $setup.showSeconds
        }]
      }, [vue.createVNode(_component_time_spinner, {
        ref: "spinner",
        role: $props.datetimeRole || 'start',
        "arrow-control": $setup.arrowControl,
        "show-seconds": $setup.showSeconds,
        "am-pm-mode": $setup.amPmMode,
        "spinner-date": $props.parsedValue,
        "disabled-hours": $setup.disabledHours,
        "disabled-minutes": $setup.disabledMinutes,
        "disabled-seconds": $setup.disabledSeconds,
        onChange: $setup.handleChange,
        onSetOption: $setup.onSetOption,
        onSelectRange: $setup.setSelectionRange
      }, null, 8
      /* PROPS */
      , ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])], 2
      /* CLASS */
      ), vue.createVNode("div", _hoisted_2$a, [vue.createVNode(_component_b_button, {
        type: "text",
        size: "mini",
        onClick: $setup.handleCancel
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_3$7];
        }),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["onClick"]), vue.createVNode(_component_b_button, {
        type: "primary",
        size: "mini",
        onClick: _cache[1] || (_cache[1] = function ($event) {
          return $setup.handleConfirm();
        })
      }, {
        default: vue.withCtx(function () {
          return [_hoisted_4$6];
        }),
        _: 1
        /* STABLE */

      })])])) : vue.createCommentVNode("v-if", true)];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["name"]);
}

script$q.render = render$p;
script$q.__file = "src/components/time-picker/time-picker-com/panel-time-pick.vue";

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$5.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$4.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$4.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$3.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string) {
  return _defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, identity_1), func + '');
}

var _baseRest = baseRest;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var _baseFindIndex = baseFindIndex;

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

var _baseIsNaN = baseIsNaN;

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

var _strictIndexOf = strictIndexOf;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? _strictIndexOf(array, value, fromIndex)
    : _baseFindIndex(array, _baseIsNaN, fromIndex);
}

var _baseIndexOf = baseIndexOf;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && _baseIndexOf(array, value, 0) > -1;
}

var _arrayIncludes = arrayIncludes;

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

var _arrayIncludesWith = arrayIncludesWith;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/* Built-in method references that are verified to be native. */
var Set$1 = _getNative(_root, 'Set');

var _Set = Set$1;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

var noop_1 = noop;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY) ? noop_1 : function(values) {
  return new _Set(values);
};

var _createSet = createSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : _createSet(array);
    if (set) {
      return _setToArray(set);
    }
    isCommon = false;
    includes = _cacheHas;
    seen = new _SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

var _baseUniq = baseUniq;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike_1(value) && isArrayLike_1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject;

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = _baseRest(function(arrays) {
  return _baseUniq(_baseFlatten(arrays, 1, isArrayLikeObject_1, true));
});

var union_1 = union;

var makeSelectRange = function makeSelectRange(start, end) {
  var result = [];

  for (var i = start; i <= end; i++) {
    result.push(i);
  }

  return result;
};

var script$p = {
  components: {
    BButton: script$1B,
    TimeSpinner: script$r
  },
  props: {
    visible: Boolean,
    actualVisible: Boolean,
    parsedValue: {
      type: [Array, String]
    },
    format: {
      type: String,
      default: ''
    }
  },
  emits: ['pick', 'select-range', 'set-picker-option'],
  setup: function setup(props, ctx) {
    var minDate = vue.computed(function () {
      return props.parsedValue[0];
    });
    var maxDate = vue.computed(function () {
      return props.parsedValue[1];
    });
    var oldValue = useOldValue(props);

    var handleCancel = function handleCancel() {
      ctx.emit('pick', oldValue.value, null);
    };

    var showSeconds = vue.computed(function () {
      return props.format.includes('ss');
    });
    var amPmMode = vue.computed(function () {
      if (props.format.includes('A')) return 'A';
      if (props.format.includes('a')) return 'a';
      return '';
    });
    var minSelectableRange = vue.ref([]);
    var maxSelectableRange = vue.ref([]);

    var handleConfirm = function handleConfirm(visible) {
      if (visible === void 0) {
        visible = false;
      }

      ctx.emit('pick', [minDate.value, maxDate.value], visible);
    };

    var handleMinChange = function handleMinChange(date) {
      handleChange(date.millisecond(0), maxDate.value);
    };

    var handleMaxChange = function handleMaxChange(date) {
      handleChange(minDate.value, date.millisecond(0));
    };

    var isValidValue = function isValidValue(_date) {
      var parsedDate = _date.map(function (_) {
        return dayjs_min(_);
      });

      var result = getRangeAvaliableTime(parsedDate);
      return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
    };

    var handleChange = function handleChange(_minDate, _maxDate) {
      // todo getRangeAvaliableTime(_date).millisecond(0)
      ctx.emit('pick', [_minDate, _maxDate], true);
    };

    var btnConfirmDisabled = vue.computed(function () {
      return minDate.value > maxDate.value;
    });
    var selectionRange = vue.ref([0, 2]);

    var setMinSelectionRange = function setMinSelectionRange(start, end) {
      ctx.emit('select-range', start, end, 'min');
      selectionRange.value = [start, end];
    };

    var offset = vue.computed(function () {
      return showSeconds.value ? 11 : 8;
    });

    var setMaxSelectionRange = function setMaxSelectionRange(start, end) {
      ctx.emit('select-range', start, end, 'max');
      selectionRange.value = [start + offset.value, end + offset.value];
    };

    var changeSelectionRange = function changeSelectionRange(step) {
      var list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      var mapping = ['hours', 'minutes'].concat(showSeconds.value ? ['seconds'] : []);
      var index = list.indexOf(selectionRange.value[0]);
      var next = (index + step + list.length) % list.length;
      var half = list.length / 2;

      if (next < half) {
        timePickeOptions['start_emitSelectRange'](mapping[next]);
      } else {
        timePickeOptions['end_emitSelectRange'](mapping[next - half]);
      }
    };

    var handleKeydown = function handleKeydown(event) {
      var code = event.code;

      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        var step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }

      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        var _step = code === EVENT_CODE.up ? -1 : 1;

        var role = selectionRange.value[0] < offset.value ? 'start' : 'end';
        timePickeOptions[role + "_scrollDown"](_step);
        event.preventDefault();
        return;
      }
    };

    var disabledHours_ = function disabledHours_(role, compare) {
      var defaultDisable = disabledHours ? disabledHours(role) : [];
      var isStart = role === 'start';
      var compareDate = compare || (isStart ? maxDate.value : minDate.value);
      var compareHour = compareDate.hour();
      var nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
      return union_1(defaultDisable, nextDisable);
    };

    var disabledMinutes_ = function disabledMinutes_(hour, role, compare) {
      var defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
      var isStart = role === 'start';
      var compareDate = compare || (isStart ? maxDate.value : minDate.value);
      var compareHour = compareDate.hour();

      if (hour !== compareHour) {
        return defaultDisable;
      }

      var compareMinute = compareDate.minute();
      var nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
      return union_1(defaultDisable, nextDisable);
    };

    var disabledSeconds_ = function disabledSeconds_(hour, minute, role, compare) {
      var defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
      var isStart = role === 'start';
      var compareDate = compare || (isStart ? maxDate.value : minDate.value);
      var compareHour = compareDate.hour();
      var compareMinute = compareDate.minute();

      if (hour !== compareHour || minute !== compareMinute) {
        return defaultDisable;
      }

      var compareSecond = compareDate.second();
      var nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
      return union_1(defaultDisable, nextDisable);
    };

    var getRangeAvaliableTime = function getRangeAvaliableTime(dates) {
      return dates.map(function (_, index) {
        return getRangeAvaliableTimeEach(dates[0], dates[1], index === 0 ? 'start' : 'end');
      });
    };

    var _getAvaliableArrs = getAvaliableArrs(disabledHours_, disabledMinutes_, disabledSeconds_),
        getAvaliableHours = _getAvaliableArrs.getAvaliableHours,
        getAvaliableMinutes = _getAvaliableArrs.getAvaliableMinutes,
        getAvaliableSeconds = _getAvaliableArrs.getAvaliableSeconds;

    var getRangeAvaliableTimeEach = function getRangeAvaliableTimeEach(startDate, endDate, role) {
      var avaliableMap = {
        hour: getAvaliableHours,
        minute: getAvaliableMinutes,
        second: getAvaliableSeconds
      };
      var isStart = role === 'start';
      var result = isStart ? startDate : endDate;
      var compareDate = isStart ? endDate : startDate;
      ['hour', 'minute', 'second'].forEach(function (_) {
        if (avaliableMap[_]) {
          var avaliableArr;
          var method = avaliableMap[_];

          if (_ === 'minute') {
            avaliableArr = method(result.hour(), role, compareDate);
          } else if (_ === 'second') {
            avaliableArr = method(result.hour(), result.minute(), role, compareDate);
          } else {
            avaliableArr = method(role, compareDate);
          }

          if (avaliableArr && avaliableArr.length && !avaliableArr.includes(result[_]())) {
            var pos = isStart ? 0 : avaliableArr.length - 1;
            result = result[_](avaliableArr[pos]);
          }
        }
      });
      return result;
    };

    var parseUserInput = function parseUserInput(value) {
      if (!value) return null;

      if (Array.isArray(value)) {
        return value.map(function (_) {
          return dayjs_min(_, props.format);
        });
      }

      return dayjs_min(value, props.format);
    };

    var formatToString = function formatToString(value) {
      if (!value) return null;

      if (Array.isArray(value)) {
        return value.map(function (_) {
          return _.format(props.format);
        });
      }

      return value.format(props.format);
    };

    var getDefaultValue = function getDefaultValue() {
      if (Array.isArray(defaultValue)) {
        return defaultValue.map(function (_) {
          return dayjs_min(_);
        });
      }

      return [dayjs_min(defaultValue), dayjs_min(defaultValue).add(60, 'm')];
    };

    ctx.emit('set-picker-option', ['formatToString', formatToString]);
    ctx.emit('set-picker-option', ['parseUserInput', parseUserInput]);
    ctx.emit('set-picker-option', ['isValidValue', isValidValue]);
    ctx.emit('set-picker-option', ['handleKeydown', handleKeydown]);
    ctx.emit('set-picker-option', ['getDefaultValue', getDefaultValue]);
    ctx.emit('set-picker-option', ['getRangeAvaliableTime', getRangeAvaliableTime]);
    var timePickeOptions = {};

    var onSetOption = function onSetOption(e) {
      timePickeOptions[e[0]] = e[1];
    };

    var pickerBase = vue.inject('EP_PICKER_BASE', {});
    var _pickerBase$props = pickerBase.props,
        arrowControl = _pickerBase$props.arrowControl,
        disabledHours = _pickerBase$props.disabledHours,
        disabledMinutes = _pickerBase$props.disabledMinutes,
        disabledSeconds = _pickerBase$props.disabledSeconds,
        defaultValue = _pickerBase$props.defaultValue;
    return {
      arrowControl: arrowControl,
      onSetOption: onSetOption,
      setMaxSelectionRange: setMaxSelectionRange,
      setMinSelectionRange: setMinSelectionRange,
      btnConfirmDisabled: btnConfirmDisabled,
      handleCancel: handleCancel,
      handleConfirm: handleConfirm,
      showSeconds: showSeconds,
      minDate: minDate,
      maxDate: maxDate,
      amPmMode: amPmMode,
      handleMinChange: handleMinChange,
      handleMaxChange: handleMaxChange,
      minSelectableRange: minSelectableRange,
      maxSelectableRange: maxSelectableRange,
      disabledHours_: disabledHours_,
      disabledMinutes_: disabledMinutes_,
      disabledSeconds_: disabledSeconds_
    };
  }
};

var _hoisted_1$g = {
  key: 0,
  class: "bin-time-range-picker bin-picker-panel"
};
var _hoisted_2$9 = {
  class: "bin-time-range-picker__content"
};
var _hoisted_3$6 = {
  class: "bin-time-range-picker__cell"
};

var _hoisted_4$5 = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-time-range-picker__header"
}, "开始时间", -1
/* HOISTED */
);

var _hoisted_5$5 = {
  class: "bin-time-range-picker__cell"
};

var _hoisted_6$4 = /*#__PURE__*/vue.createVNode("div", {
  class: "bin-time-range-picker__header"
}, "结束时间", -1
/* HOISTED */
);

var _hoisted_7$4 = {
  class: "bin-time-panel__footer"
};

var _hoisted_8$4 = /*#__PURE__*/vue.createTextVNode(" 取消 ");

var _hoisted_9$4 = /*#__PURE__*/vue.createTextVNode(" 确定 ");

function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_time_spinner = vue.resolveComponent("time-spinner");

  var _component_b_button = vue.resolveComponent("b-button");

  return $props.actualVisible ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$g, [vue.createVNode("div", _hoisted_2$9, [vue.createVNode("div", _hoisted_3$6, [_hoisted_4$5, vue.createVNode("div", {
    class: [{
      'has-seconds': $setup.showSeconds,
      'is-arrow': $setup.arrowControl
    }, "bin-time-range-picker__body bin-time-panel__content"]
  }, [vue.createVNode(_component_time_spinner, {
    ref: "minSpinner",
    role: "start",
    "show-seconds": $setup.showSeconds,
    "am-pm-mode": $setup.amPmMode,
    "arrow-control": $setup.arrowControl,
    "spinner-date": $setup.minDate,
    "disabled-hours": $setup.disabledHours_,
    "disabled-minutes": $setup.disabledMinutes_,
    "disabled-seconds": $setup.disabledSeconds_,
    onChange: $setup.handleMinChange,
    onSetOption: $setup.onSetOption,
    onSelectRange: $setup.setMinSelectionRange
  }, null, 8
  /* PROPS */
  , ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])], 2
  /* CLASS */
  )]), vue.createVNode("div", _hoisted_5$5, [_hoisted_6$4, vue.createVNode("div", {
    class: [{
      'has-seconds': $setup.showSeconds,
      'is-arrow': $setup.arrowControl
    }, "bin-time-range-picker__body bin-time-panel__content"]
  }, [vue.createVNode(_component_time_spinner, {
    ref: "maxSpinner",
    role: "end",
    "show-seconds": $setup.showSeconds,
    "am-pm-mode": $setup.amPmMode,
    "arrow-control": $setup.arrowControl,
    "spinner-date": $setup.maxDate,
    "disabled-hours": $setup.disabledHours_,
    "disabled-minutes": $setup.disabledMinutes_,
    "disabled-seconds": $setup.disabledSeconds_,
    onChange: $setup.handleMaxChange,
    onSetOption: $setup.onSetOption,
    onSelectRange: $setup.setMaxSelectionRange
  }, null, 8
  /* PROPS */
  , ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])], 2
  /* CLASS */
  )])]), vue.createVNode("div", _hoisted_7$4, [vue.createVNode(_component_b_button, {
    type: "text",
    size: "mini",
    onClick: $setup.handleCancel
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_8$4];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onClick"]), vue.createVNode(_component_b_button, {
    type: "primary",
    size: "mini",
    onClick: _cache[1] || (_cache[1] = function ($event) {
      return $setup.handleConfirm();
    })
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_9$4];
    }),
    _: 1
    /* STABLE */

  })])])) : vue.createCommentVNode("v-if", true);
}

script$p.render = render$o;
script$p.__file = "src/components/time-picker/time-picker-com/panel-time-range.vue";

dayjs_min.extend(customParseFormat);
var TimePicker = {
  name: 'BTimePicker',
  install: null,
  props: _extends$2({}, defaultProps, {
    isRange: {
      type: Boolean,
      default: false
    }
  }),
  emits: ['update:modelValue'],
  setup: function setup(props, ctx) {
    var commonPicker = vue.ref(null);
    var type = props.isRange ? 'timerange' : 'time';
    var panel = props.isRange ? script$p : script$q;

    var refProps = _extends$2({}, props, {
      focus: function focus() {
        var _commonPicker$value;

        (_commonPicker$value = commonPicker.value) == null ? void 0 : _commonPicker$value.handleFocus();
      }
    });

    ctx.expose(refProps);
    return function () {
      return vue.h(script$s, _extends$2({
        format: DEFAULT_FORMATS_TIME
      }, props, {
        // allow format to be overwrite
        type: type,
        ref: commonPicker,
        'onUpdate:modelValue': function onUpdateModelValue(value) {
          return ctx.emit('update:modelValue', value);
        }
      }), {
        default: function _default(scopedProps) {
          return vue.h(panel, scopedProps);
        }
      });
    };
  }
};

var rangeArr = function rangeArr(n) {
  return Array.from(Array(n).keys());
};
var extractDateFormat = function extractDateFormat(format) {
  return format.replace(/\W?m{1,2}|\W?ZZ/g, '').replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, '').trim();
};
var extractTimeFormat = function extractTimeFormat(format) {
  return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, '').trim();
};

TimePicker.install = function (app) {
  app.component(TimePicker.name, TimePicker);
};

var script$o = {
  props: {
    date: {
      type: Object
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    selectionMode: {
      type: String,
      default: 'day'
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    rangeState: {
      type: Object,
      default: function _default() {
        return {
          endDate: null,
          selecting: false
        };
      }
    }
  },
  emits: ['changerange', 'pick', 'select'],
  setup: function setup(props, ctx) {
    // data
    var lastRow = vue.ref(null);
    var lastColumn = vue.ref(null);
    var tableRows = vue.ref([[], [], [], [], [], []]); // todo better way to get Day.js locale object

    var firstDayOfWeek = 1;
    var WEEKS_CONSTANT = props.date.locale('en').localeData().weekdaysShort().map(function (_) {
      return _.toLowerCase();
    });
    var offsetDay = vue.computed(function () {
      // Sunday 7(0), cal the left and right offset days, 3217654, such as Monday is -1, the is to adjust the position of the first two rows of dates
      return -firstDayOfWeek;
    });
    var startDate = vue.computed(function () {
      var startDayOfMonth = props.date.startOf('month');
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, 'day');
    });
    var weeksMap = vue.computed(function () {
      return {
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六',
        sun: '日'
      };
    });
    var WEEKS = vue.computed(function () {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    var rows = vue.computed(function () {
      // TODO: refactory rows / getCellClasses
      var startOfMonth = props.date.startOf('month');
      var startOfMonthDay = startOfMonth.day() || 7; // day of first day

      var dateCountOfMonth = startOfMonth.daysInMonth();
      var dateCountOfLastMonth = startOfMonth.subtract(1, 'month').daysInMonth();
      var offset = offsetDay.value;
      var rows_ = tableRows.value;
      var count = 1;
      var selectedDate = props.selectionMode === 'dates' ? coerceTruthyValueToArray(props.parsedValue) : [];
      var calNow = dayjs_min().startOf('day');

      for (var i = 0; i < 6; i++) {
        var row = rows_[i];

        if (props.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: 'week',
              text: startDate.value.add(i * 7 + 1, 'day').week()
            };
          }
        }

        var _loop = function _loop(j) {
          var _props$minDate;

          var cell = row[props.showWeekNumber ? j + 1 : j];

          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: 'normal',
              inRange: false,
              start: false,
              end: false
            };
          }

          var index = i * 7 + j;
          var calTime = startDate.value.add(index - offset, 'day');
          cell.type = 'normal';
          var calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
          cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, 'day') && calEndDate && calTime.isSameOrBefore(calEndDate, 'day') || props.minDate && calTime.isSameOrBefore(props.minDate, 'day') && calEndDate && calTime.isSameOrAfter(calEndDate, 'day');

          if ((_props$minDate = props.minDate) != null && _props$minDate.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, 'day');
            cell.end = props.minDate && calTime.isSame(props.minDate, 'day');
          } else {
            cell.start = props.minDate && calTime.isSame(props.minDate, 'day');
            cell.end = calEndDate && calTime.isSame(calEndDate, 'day');
          }

          var isToday = calTime.isSame(calNow, 'day');

          if (isToday) {
            cell.type = 'today';
          }

          if (i >= 0 && i <= 1) {
            var numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;

            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count++;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
              cell.type = 'prev-month';
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count++;
            } else {
              cell.text = count++ - dateCountOfMonth;
              cell.type = 'next-month';
            }
          }

          var cellDate = calTime.toDate();
          cell.selected = selectedDate.find(function (_) {
            return _.valueOf() === calTime.valueOf();
          });
          cell.disabled = props.disabledDate && props.disabledDate(cellDate);
          cell.customClass = props.cellClassName && props.cellClassName(cellDate);
          row[props.showWeekNumber ? j + 1 : j] = cell;
        };

        for (var j = 0; j < 7; j++) {
          _loop(j);
        }

        if (props.selectionMode === 'week') {
          var start = props.showWeekNumber ? 1 : 0;
          var end = props.showWeekNumber ? 7 : 6;
          var isActive = isWeekActive(row[start + 1]);
          row[start].inRange = isActive;
          row[start].start = isActive;
          row[end].inRange = isActive;
          row[end].end = isActive;
        }
      }

      return rows_;
    });

    var cellMatchesDate = function cellMatchesDate(cell, date) {
      if (!date) return false;
      return dayjs_min(date).isSame(props.date.date(Number(cell.text)), 'day');
    };

    var getCellClasses = function getCellClasses(cell) {
      var classes = [];

      if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
        classes.push('available');

        if (cell.type === 'today') {
          classes.push('today');
        }
      } else {
        classes.push(cell.type);
      }

      if (props.selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && cellMatchesDate(cell, props.parsedValue)) {
        classes.push('current');
      }

      if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || props.selectionMode === 'week')) {
        classes.push('in-range');

        if (cell.start) {
          classes.push('start-date');
        }

        if (cell.end) {
          classes.push('end-date');
        }
      }

      if (cell.disabled) {
        classes.push('disabled');
      }

      if (cell.selected) {
        classes.push('selected');
      }

      if (cell.customClass) {
        classes.push(cell.customClass);
      }

      return classes.join(' ');
    };

    var getDateOfCell = function getDateOfCell(row, column) {
      var offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, 'day');
    };

    var handleMouseMove = function handleMouseMove(event) {
      if (!props.rangeState.selecting) return;
      var target = event.target;

      if (target.tagName === 'SPAN') {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }

      if (target.tagName !== 'TD') return;
      var row = target.parentNode.rowIndex - 1;
      var column = target.cellIndex; // can not select disabled date

      if (rows.value[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
      // this avoids frequent Date object creation and improves performance

      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit('changerange', {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };

    var handleClick = function handleClick(event) {
      var target = event.target;

      if (target.tagName === 'SPAN') {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }

      if (target.tagName !== 'TD') return;
      var row = target.parentNode.rowIndex - 1;
      var column = target.cellIndex;
      var cell = rows.value[row][column];
      if (cell.disabled || cell.type === 'week') return;
      var newDate = getDateOfCell(row, column);

      if (props.selectionMode === 'range') {
        if (!props.rangeState.selecting) {
          ctx.emit('pick', {
            minDate: newDate,
            maxDate: null
          });
          ctx.emit('select', true);
        } else {
          if (newDate >= props.minDate) {
            ctx.emit('pick', {
              minDate: props.minDate,
              maxDate: newDate
            });
          } else {
            ctx.emit('pick', {
              minDate: newDate,
              maxDate: props.minDate
            });
          }

          ctx.emit('select', false);
        }
      } else if (props.selectionMode === 'day') {
        ctx.emit('pick', newDate);
      } else if (props.selectionMode === 'week') {
        var weekNumber = newDate.week();
        var value = newDate.year() + 'w' + weekNumber;
        ctx.emit('pick', {
          year: newDate.year(),
          week: weekNumber,
          value: value,
          date: newDate.startOf('week')
        });
      } else if (props.selectionMode === 'dates') {
        var newValue = cell.selected ? coerceTruthyValueToArray(props.parsedValue).filter(function (_) {
          return _.valueOf() !== newDate.valueOf();
        }) : coerceTruthyValueToArray(props.parsedValue).concat([newDate]);
        ctx.emit('pick', newValue);
      }
    };

    var isWeekActive = function isWeekActive(cell) {
      if (props.selectionMode !== 'week') return false;
      var newDate = props.date.startOf('day');

      if (cell.type === 'prev-month') {
        newDate = newDate.subtract(1, 'month');
      }

      if (cell.type === 'next-month') {
        newDate = newDate.add(1, 'month');
      }

      newDate = newDate.date(parseInt(cell.text, 10));

      if (props.parsedValue && !Array.isArray(props.parsedValue)) {
        var dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        var weekDate = props.parsedValue.subtract(dayOffset, 'day');
        return weekDate.isSame(newDate, 'day');
      }

      return false;
    };

    return {
      handleMouseMove: handleMouseMove,
      rows: rows,
      isWeekActive: isWeekActive,
      getCellClasses: getCellClasses,
      WEEKS: WEEKS,
      weeksMap: weeksMap,
      handleClick: handleClick
    };
  }
};

var _hoisted_1$f = {
  key: 0
};
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: ["bin-date-table", {
      'is-week-mode': $props.selectionMode === 'week'
    }],
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleClick && $setup.handleClick.apply($setup, arguments);
    }),
    onMousemove: _cache[2] || (_cache[2] = function () {
      return $setup.handleMouseMove && $setup.handleMouseMove.apply($setup, arguments);
    })
  }, [vue.createVNode("tbody", null, [vue.createVNode("tr", null, [$props.showWeekNumber ? (vue.openBlock(), vue.createBlock("th", _hoisted_1$f, "周次")) : vue.createCommentVNode("v-if", true), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.WEEKS, function (week, key) {
    return vue.openBlock(), vue.createBlock("th", {
      key: key
    }, vue.toDisplayString($setup.weeksMap[week]), 1
    /* TEXT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))]), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.rows, function (row, key) {
    return vue.openBlock(), vue.createBlock("tr", {
      key: key,
      class: ["bin-date-table__row", {
        current: $setup.isWeekActive(row[1])
      }]
    }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(row, function (cell, key_) {
      return vue.openBlock(), vue.createBlock("td", {
        key: key_,
        class: $setup.getCellClasses(cell)
      }, [vue.createVNode("div", null, [vue.createVNode("span", null, vue.toDisplayString(cell.text), 1
      /* TEXT */
      )])], 2
      /* CLASS */
      );
    }), 128
    /* KEYED_FRAGMENT */
    ))], 2
    /* CLASS */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))])], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$o.render = render$n;
script$o.__file = "src/components/date-picker/date-picker-com/basic-date-table.vue";

var datesInMonth = function datesInMonth(year, month) {
  var firstDay = dayjs_min().startOf('month').month(month).year(year);
  var numOfDays = firstDay.daysInMonth();
  return rangeArr(numOfDays).map(function (n) {
    return firstDay.add(n, 'day').toDate();
  });
};

var script$n = {
  props: {
    disabledDate: {
      type: Function
    },
    selectionMode: {
      type: String,
      default: 'month'
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    date: {
      type: Object
    },
    parsedValue: {
      type: Object
    },
    rangeState: {
      type: Object,
      default: function _default() {
        return {
          endDate: null,
          selecting: false
        };
      }
    }
  },
  emits: ['changerange', 'pick', 'select'],
  setup: function setup(props, ctx) {
    var monthMap = vue.ref({
      jan: '一月',
      feb: '二月',
      mar: '三月',
      apr: '四月',
      may: '五月',
      jun: '六月',
      jul: '七月',
      aug: '八月',
      sep: '九月',
      oct: '十月',
      nov: '十一月',
      dec: '十二月'
    });
    var months = vue.ref(props.date.locale('en').localeData().monthsShort().map(function (_) {
      return _.toLowerCase();
    }));
    var tableRows = vue.ref([[], [], []]);
    var lastRow = vue.ref(null);
    var lastColumn = vue.ref(null);
    var rows = vue.computed(function () {
      var rows = tableRows.value;
      var now = dayjs_min().startOf('month');

      for (var i = 0; i < 3; i++) {
        var row = rows[i];

        for (var j = 0; j < 4; j++) {
          var _props$minDate;

          var cell = row[j];

          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: 'normal',
              inRange: false,
              start: false,
              end: false
            };
          }

          cell.type = 'normal';
          var index = i * 4 + j;
          var calTime = props.date.startOf('year').month(index);
          var calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate;
          cell.inRange = props.minDate && calTime.isSameOrAfter(props.minDate, 'month') && calEndDate && calTime.isSameOrBefore(calEndDate, 'month') || props.minDate && calTime.isSameOrBefore(props.minDate, 'month') && calEndDate && calTime.isSameOrAfter(calEndDate, 'month');

          if ((_props$minDate = props.minDate) != null && _props$minDate.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, 'month');
            cell.end = props.minDate && calTime.isSame(props.minDate, 'month');
          } else {
            cell.start = props.minDate && calTime.isSame(props.minDate, 'month');
            cell.end = calEndDate && calTime.isSame(calEndDate, 'month');
          }

          var isToday = now.isSame(calTime);

          if (isToday) {
            cell.type = 'today';
          }

          cell.text = index;
          var cellDate = calTime.toDate();
          cell.disabled = props.disabledDate && props.disabledDate(cellDate);
          row[j] = cell;
        }
      }

      return rows;
    });

    var getCellStyle = function getCellStyle(cell) {
      var style = {};
      var year = props.date.year();
      var today = new Date();
      var month = cell.text;
      style.disabled = props.disabledDate ? datesInMonth(year, month).every(props.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props.parsedValue).findIndex(function (date) {
        return date.year() === year && date.month() === month;
      }) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;

      if (cell.inRange) {
        style['in-range'] = true;

        if (cell.start) {
          style['start-date'] = true;
        }

        if (cell.end) {
          style['end-date'] = true;
        }
      }

      return style;
    };

    var handleMouseMove = function handleMouseMove(event) {
      if (!props.rangeState.selecting) return;
      var target = event.target;

      if (target.tagName === 'A') {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }

      if (target.tagName !== 'TD') return;
      var row = target.parentNode.rowIndex;
      var column = target.cellIndex; // can not select disabled date

      if (rows.value[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
      // this avoids frequent Date object creation and improves performance

      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit('changerange', {
          selecting: true,
          endDate: props.date.startOf('year').month(row * 4 + column)
        });
      }
    };

    var handleMonthTableClick = function handleMonthTableClick(event) {
      var target = event.target;

      if (target.tagName === 'A') {
        target = target.parentNode.parentNode;
      }

      if (target.tagName === 'DIV') {
        target = target.parentNode;
      }

      if (target.tagName !== 'TD') return;
      if (hasClass(target, 'disabled')) return;
      var column = target.cellIndex;
      var row = target.parentNode.rowIndex;
      var month = row * 4 + column;
      var newDate = props.date.startOf('year').month(month);

      if (props.selectionMode === 'range') {
        if (!props.rangeState.selecting) {
          ctx.emit('pick', {
            minDate: newDate,
            maxDate: null
          });
          ctx.emit('select', true);
        } else {
          if (newDate >= props.minDate) {
            ctx.emit('pick', {
              minDate: props.minDate,
              maxDate: newDate
            });
          } else {
            ctx.emit('pick', {
              minDate: newDate,
              maxDate: props.minDate
            });
          }

          ctx.emit('select', false);
        }
      } else {
        ctx.emit('pick', month);
      }
    };

    return {
      handleMouseMove: handleMouseMove,
      handleMonthTableClick: handleMonthTableClick,
      rows: rows,
      getCellStyle: getCellStyle,
      monthMap: monthMap,
      months: months
    };
  }
};

var _hoisted_1$e = {
  class: "cell"
};
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("table", {
    class: "bin-month-table",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleMonthTableClick && $setup.handleMonthTableClick.apply($setup, arguments);
    }),
    onMousemove: _cache[2] || (_cache[2] = function () {
      return $setup.handleMouseMove && $setup.handleMouseMove.apply($setup, arguments);
    })
  }, [vue.createVNode("tbody", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.rows, function (row, key) {
    return vue.openBlock(), vue.createBlock("tr", {
      key: key
    }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(row, function (cell, key_) {
      return vue.openBlock(), vue.createBlock("td", {
        key: key_,
        class: $setup.getCellStyle(cell)
      }, [vue.createVNode("div", null, [vue.createVNode("a", _hoisted_1$e, vue.toDisplayString($setup.monthMap[$setup.months[cell.text]]), 1
      /* TEXT */
      )])], 2
      /* CLASS */
      );
    }), 128
    /* KEYED_FRAGMENT */
    ))]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])], 32
  /* HYDRATE_EVENTS */
  );
}

script$n.render = render$m;
script$n.__file = "src/components/date-picker/date-picker-com/basic-month-table.vue";

var datesInYear = function datesInYear(year) {
  var firstDay = dayjs_min(String(year)).startOf('year');
  var lastDay = firstDay.endOf('year');
  var numOfDays = lastDay.dayOfYear();
  return rangeArr(numOfDays).map(function (n) {
    return firstDay.add(n, 'day').toDate();
  });
};

var script$m = {
  props: {
    disabledDate: {
      type: Function
    },
    parsedValue: {
      type: Object
    },
    date: {
      type: Object
    }
  },
  emits: ['pick'],
  setup: function setup(props, ctx) {
    var startYear = vue.computed(function () {
      return Math.floor(props.date.year() / 10) * 10;
    });

    var getCellStyle = function getCellStyle(year) {
      var style = {};
      var today = dayjs_min();
      style.disabled = props.disabledDate ? datesInYear(year).every(props.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props.parsedValue).findIndex(function (_) {
        return _.year() === year;
      }) >= 0;
      style.today = today.year() === year;
      return style;
    };

    var handleYearTableClick = function handleYearTableClick(event) {
      var target = event.target;

      if (target.tagName === 'A') {
        if (hasClass(target.parentNode, 'disabled')) return;
        var year = target.textContent || target.innerText;
        ctx.emit('pick', Number(year));
      }
    };

    return {
      startYear: startYear,
      getCellStyle: getCellStyle,
      handleYearTableClick: handleYearTableClick
    };
  }
};

var _hoisted_1$d = {
  class: "cell"
};
var _hoisted_2$8 = {
  class: "cell"
};
var _hoisted_3$5 = {
  class: "cell"
};
var _hoisted_4$4 = {
  class: "cell"
};
var _hoisted_5$4 = {
  class: "cell"
};
var _hoisted_6$3 = {
  class: "cell"
};
var _hoisted_7$3 = {
  class: "cell"
};
var _hoisted_8$3 = {
  class: "cell"
};
var _hoisted_9$3 = {
  class: "cell"
};
var _hoisted_10$3 = {
  class: "cell"
};

var _hoisted_11$3 = /*#__PURE__*/vue.createVNode("td", null, null, -1
/* HOISTED */
);

var _hoisted_12$3 = /*#__PURE__*/vue.createVNode("td", null, null, -1
/* HOISTED */
);

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("table", {
    class: "bin-year-table",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.handleYearTableClick && $setup.handleYearTableClick.apply($setup, arguments);
    })
  }, [vue.createVNode("tbody", null, [vue.createVNode("tr", null, [vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 0)]
  }, [vue.createVNode("a", _hoisted_1$d, vue.toDisplayString($setup.startYear), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 1)]
  }, [vue.createVNode("a", _hoisted_2$8, vue.toDisplayString($setup.startYear + 1), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 2)]
  }, [vue.createVNode("a", _hoisted_3$5, vue.toDisplayString($setup.startYear + 2), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 3)]
  }, [vue.createVNode("a", _hoisted_4$4, vue.toDisplayString($setup.startYear + 3), 1
  /* TEXT */
  )], 2
  /* CLASS */
  )]), vue.createVNode("tr", null, [vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 4)]
  }, [vue.createVNode("a", _hoisted_5$4, vue.toDisplayString($setup.startYear + 4), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 5)]
  }, [vue.createVNode("a", _hoisted_6$3, vue.toDisplayString($setup.startYear + 5), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 6)]
  }, [vue.createVNode("a", _hoisted_7$3, vue.toDisplayString($setup.startYear + 6), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 7)]
  }, [vue.createVNode("a", _hoisted_8$3, vue.toDisplayString($setup.startYear + 7), 1
  /* TEXT */
  )], 2
  /* CLASS */
  )]), vue.createVNode("tr", null, [vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 8)]
  }, [vue.createVNode("a", _hoisted_9$3, vue.toDisplayString($setup.startYear + 8), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), vue.createVNode("td", {
    class: ["available", $setup.getCellStyle($setup.startYear + 9)]
  }, [vue.createVNode("a", _hoisted_10$3, vue.toDisplayString($setup.startYear + 9), 1
  /* TEXT */
  )], 2
  /* CLASS */
  ), _hoisted_11$3, _hoisted_12$3])])]);
}

script$m.render = render$l;
script$m.__file = "src/components/date-picker/date-picker-com/basic-year-table.vue";

var timeWithinRange = function timeWithinRange(date, selectableRange, format) {
  return true;
};

var script$l = {
  components: {
    DateTable: script$o,
    BInput: script$1D,
    BButton: script$1B,
    TimePickPanel: script$q,
    MonthTable: script$n,
    YearTable: script$m
  },
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    parsedValue: {
      type: [Object, Array]
    },
    format: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      required: true
    }
  },
  emits: ['pick', 'set-picker-option'],
  setup: function setup(props, ctx) {
    var innerDate = vue.ref(dayjs_min());
    var month = vue.computed(function () {
      return innerDate.value.month();
    });
    var year = vue.computed(function () {
      return innerDate.value.year();
    });
    var selectableRange = vue.ref([]);
    var userInputDate = vue.ref(null);
    var userInputTime = vue.ref(null); // todo update to disableHour

    var checkDateWithinRange = function checkDateWithinRange(date) {
      return selectableRange.value.length > 0 ? timeWithinRange(date, selectableRange.value, props.format || 'HH:mm:ss') : true;
    };

    var formatEmit = function formatEmit(emitDayjs) {
      if (showTime.value) return emitDayjs.millisecond(0);

      if (defaultTime) {
        var defaultTimeD = dayjs_min(defaultTime);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }

      return emitDayjs.startOf('day');
    };

    var emit = function emit(value) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (!value) {
        ctx.emit.apply(ctx, ['pick', value].concat(args));
      } else if (Array.isArray(value)) {
        var dates = value.map(formatEmit);
        ctx.emit.apply(ctx, ['pick', dates].concat(args));
      } else {
        ctx.emit.apply(ctx, ['pick', formatEmit(value)].concat(args));
      }

      userInputDate.value = null;
      userInputTime.value = null;
    };

    var handleDatePick = function handleDatePick(value) {
      if (selectionMode.value === 'day') {
        var newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value; // change default time while out of selectableRange

        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }

        innerDate.value = newDate;
        emit(newDate, showTime.value);
      } else if (selectionMode.value === 'week') {
        emit(value.date);
      } else if (selectionMode.value === 'dates') {
        emit(value, true); // set false to keep panel open
      }
    };

    var prevMonth_ = function prevMonth_() {
      innerDate.value = innerDate.value.subtract(1, 'month');
    };

    var nextMonth_ = function nextMonth_() {
      innerDate.value = innerDate.value.add(1, 'month');
    };

    var prevYear_ = function prevYear_() {
      if (currentView.value === 'year') {
        innerDate.value = innerDate.value.subtract(10, 'year');
      } else {
        innerDate.value = innerDate.value.subtract(1, 'year');
      }
    };

    var nextYear_ = function nextYear_() {
      if (currentView.value === 'year') {
        innerDate.value = innerDate.value.add(10, 'year');
      } else {
        innerDate.value = innerDate.value.add(1, 'year');
      }
    };

    var currentView = vue.ref('date');
    var yearLabel = vue.computed(function () {
      var yearTranslation = '年';

      if (currentView.value === 'year') {
        var startYear = Math.floor(year.value / 10) * 10;

        {
          return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
        }
      }

      return year.value + ' ' + yearTranslation;
    });

    var handleShortcutClick = function handleShortcutClick(shortcut) {
      if (shortcut.value) {
        emit(dayjs_min(shortcut.value));
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    var selectionMode = vue.computed(function () {
      if (['week', 'month', 'year', 'dates'].includes(props.type)) {
        return props.type;
      }

      return 'day';
    });
    vue.watch(function () {
      return selectionMode.value;
    }, function (val) {
      if (['month', 'year'].includes(val)) {
        currentView.value = val;
        return;
      }

      currentView.value = 'date';
    }, {
      immediate: true
    });
    var hasShortcuts = vue.computed(function () {
      return !!shortcuts.length;
    });

    var handleMonthPick = function handleMonthPick(month) {
      innerDate.value = innerDate.value.startOf('month').month(month);

      if (selectionMode.value === 'month') {
        emit(innerDate.value);
      } else {
        currentView.value = 'date';
      }
    };

    var handleYearPick = function handleYearPick(year) {
      if (selectionMode.value === 'year') {
        innerDate.value = innerDate.value.startOf('year').year(year);
        emit(innerDate.value);
      } else {
        innerDate.value = innerDate.value.year(year);
        currentView.value = 'month';
      }
    };

    var showMonthPicker = function showMonthPicker() {
      currentView.value = 'month';
    };

    var showYearPicker = function showYearPicker() {
      currentView.value = 'year';
    };

    var showTime = vue.computed(function () {
      return props.type === 'datetime' || props.type === 'datetimerange';
    });
    var footerVisible = vue.computed(function () {
      return showTime.value || selectionMode.value === 'dates';
    });

    var onConfirm = function onConfirm() {
      if (selectionMode.value === 'dates') {
        emit(props.parsedValue);
      } else {
        // deal with the scenario where: user opens the date time picker, then confirm without doing anything
        var result = props.parsedValue;

        if (!result) {
          var defaultTimeD = dayjs_min(defaultTime);
          var defaultValueD = getDefaultValue();
          result = defaultTimeD.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }

        innerDate.value = result;
        emit(result);
      }
    };

    var changeToNow = function changeToNow() {
      // NOTE: not a permanent solution
      //       consider disable "now" button in the future
      var now = dayjs_min();
      var nowDate = now.toDate();

      if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs_min();
        emit(innerDate.value);
      }
    };

    var timeFormat = vue.computed(function () {
      return extractTimeFormat(props.format);
    });
    var dateFormat = vue.computed(function () {
      return extractDateFormat(props.format);
    });
    var visibleTime = vue.computed(function () {
      if (userInputTime.value) return userInputTime.value;
      if (!props.parsedValue && !defaultValue) return;
      return (props.parsedValue || innerDate.value).format(timeFormat.value);
    });
    var visibleDate = vue.computed(function () {
      if (userInputDate.value) return userInputDate.value;
      if (!props.parsedValue && !defaultValue) return;
      return (props.parsedValue || innerDate.value).format(dateFormat.value);
    });
    var timePickerVisible = vue.ref(false);

    var onTimePickerInputFocus = function onTimePickerInputFocus() {
      timePickerVisible.value = true;
    };

    var handleTimePickClose = function handleTimePickClose() {
      timePickerVisible.value = false;
    };

    var handleTimePick = function handleTimePick(value, visible, first) {
      innerDate.value = props.parsedValue ? props.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
      emit(innerDate.value, true);

      if (!first) {
        timePickerVisible.value = visible;
      }
    };

    var handleVisibleTimeChange = function handleVisibleTimeChange(value) {
      var newDate = dayjs_min(value, timeFormat.value);

      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit(innerDate.value, true);
      }
    };

    var handleVisibleDateChange = function handleVisibleDateChange(value) {
      var newDate = dayjs_min(value, dateFormat.value);

      if (newDate.isValid()) {
        if (disabledDate && disabledDate(newDate.toDate())) {
          return;
        }

        innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
        userInputDate.value = null;
        emit(innerDate.value, true);
      }
    };

    var isValidValue = function isValidValue(date_) {
      return date_.isValid() && (disabledDate ? !disabledDate(date_.toDate()) : true);
    };

    var formatToString = function formatToString(value) {
      if (selectionMode.value === 'dates') {
        return value.map(function (_) {
          return _.format(props.format);
        });
      }

      return value.format(props.format);
    };

    var parseUserInput = function parseUserInput(value) {
      return dayjs_min(value, props.format);
    };

    var getDefaultValue = function getDefaultValue() {
      return dayjs_min(defaultValue);
    };

    var handleKeydown = function handleKeydown(event) {
      var code = event.code,
          keyCode = event.keyCode;
      var list = [EVENT_CODE.up, EVENT_CODE.down, EVENT_CODE.left, EVENT_CODE.right];

      if (props.visible && !timePickerVisible.value) {
        if (list.includes(code)) {
          handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }

        if (code === EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
          // Enter
          emit(innerDate, false);
        }
      }
    };

    var handleKeyControl = function handleKeyControl(keyCode) {
      var mapping = {
        'year': {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: function offset(date, step) {
            return date.setFullYear(date.getFullYear() + step);
          }
        },
        'month': {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: function offset(date, step) {
            return date.setMonth(date.getMonth() + step);
          }
        },
        'week': {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: function offset(date, step) {
            return date.setDate(date.getDate() + step * 7);
          }
        },
        'day': {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: function offset(date, step) {
            return date.setDate(date.getDate() + step);
          }
        }
      };
      var newDate = innerDate.value.toDate();

      while (Math.abs(innerDate.value.diff(newDate, 'year', true)) < 1) {
        var map = mapping[selectionMode.value];
        map.offset(newDate, map[keyCode]);

        if (disabledDate && disabledDate(newDate)) {
          continue;
        }

        var result = dayjs_min(newDate);
        innerDate.value = result;
        ctx.emit('pick', result, true);
        break;
      }
    };

    ctx.emit('set-picker-option', ['isValidValue', isValidValue]);
    ctx.emit('set-picker-option', ['formatToString', formatToString]);
    ctx.emit('set-picker-option', ['parseUserInput', parseUserInput]);
    ctx.emit('set-picker-option', ['handleKeydown', handleKeydown]);
    var pickerBase = vue.inject('EP_PICKER_BASE');
    var _pickerBase$props = pickerBase.props,
        shortcuts = _pickerBase$props.shortcuts,
        disabledDate = _pickerBase$props.disabledDate,
        cellClassName = _pickerBase$props.cellClassName,
        defaultTime = _pickerBase$props.defaultTime,
        defaultValue = _pickerBase$props.defaultValue,
        arrowControl = _pickerBase$props.arrowControl;
    vue.watch(function () {
      return props.parsedValue;
    }, function (val) {
      if (val) {
        if (selectionMode.value === 'dates') return;
        if (Array.isArray(val)) return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue();
      }
    }, {
      immediate: true
    });
    return {
      handleTimePick: handleTimePick,
      handleTimePickClose: handleTimePickClose,
      onTimePickerInputFocus: onTimePickerInputFocus,
      timePickerVisible: timePickerVisible,
      visibleTime: visibleTime,
      visibleDate: visibleDate,
      showTime: showTime,
      changeToNow: changeToNow,
      onConfirm: onConfirm,
      footerVisible: footerVisible,
      handleYearPick: handleYearPick,
      showMonthPicker: showMonthPicker,
      showYearPicker: showYearPicker,
      handleMonthPick: handleMonthPick,
      hasShortcuts: hasShortcuts,
      shortcuts: shortcuts,
      arrowControl: arrowControl,
      disabledDate: disabledDate,
      cellClassName: cellClassName,
      selectionMode: selectionMode,
      handleShortcutClick: handleShortcutClick,
      prevYear_: prevYear_,
      nextYear_: nextYear_,
      prevMonth_: prevMonth_,
      nextMonth_: nextMonth_,
      innerDate: innerDate,
      yearLabel: yearLabel,
      currentView: currentView,
      month: month,
      handleDatePick: handleDatePick,
      handleVisibleTimeChange: handleVisibleTimeChange,
      handleVisibleDateChange: handleVisibleDateChange,
      timeFormat: timeFormat,
      userInputTime: userInputTime,
      userInputDate: userInputDate
    };
  }
};

var _hoisted_1$c = {
  class: "bin-picker-panel__body-wrapper"
};
var _hoisted_2$7 = {
  key: 0,
  class: "bin-picker-panel__sidebar"
};
var _hoisted_3$4 = {
  class: "bin-picker-panel__body"
};
var _hoisted_4$3 = {
  key: 0,
  class: "bin-date-picker__time-header"
};
var _hoisted_5$3 = {
  class: "bin-date-picker__editor-wrap"
};
var _hoisted_6$2 = {
  class: "bin-date-picker__editor-wrap"
};

var _hoisted_7$2 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
}, null, -1
/* HOISTED */
);

var _hoisted_8$2 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
}, null, -1
/* HOISTED */
);

var _hoisted_9$2 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
}, null, -1
/* HOISTED */
);

var _hoisted_10$2 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

var _hoisted_11$2 = {
  class: "bin-picker-panel__content"
};
var _hoisted_12$2 = {
  class: "bin-picker-panel__footer"
};

var _hoisted_13$2 = /*#__PURE__*/vue.createTextVNode(" 此刻 ");

var _hoisted_14$1 = /*#__PURE__*/vue.createTextVNode(" 确定 ");

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_input = vue.resolveComponent("b-input");

  var _component_time_pick_panel = vue.resolveComponent("time-pick-panel");

  var _component_date_table = vue.resolveComponent("date-table");

  var _component_year_table = vue.resolveComponent("year-table");

  var _component_month_table = vue.resolveComponent("month-table");

  var _component_b_button = vue.resolveComponent("b-button");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-picker-panel bin-date-picker", [{
      'has-sidebar': _ctx.$slots.sidebar || $setup.hasShortcuts,
      'has-time': $setup.showTime
    }]]
  }, [vue.createVNode("div", _hoisted_1$c, [vue.renderSlot(_ctx.$slots, "sidebar", {
    class: "bin-picker-panel__sidebar"
  }), $setup.hasShortcuts ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$7, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.shortcuts, function (shortcut, key) {
    return vue.openBlock(), vue.createBlock("button", {
      key: key,
      type: "button",
      class: "bin-picker-panel__shortcut",
      onClick: function onClick($event) {
        return $setup.handleShortcutClick(shortcut);
      }
    }, vue.toDisplayString(shortcut.text), 9
    /* TEXT, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_3$4, [$setup.showTime ? (vue.openBlock(), vue.createBlock("div", _hoisted_4$3, [vue.createVNode("span", _hoisted_5$3, [vue.createVNode(_component_b_input, {
    placeholder: "选择日期",
    "model-value": $setup.visibleDate,
    size: "small",
    onInput: _cache[1] || (_cache[1] = function (val) {
      return $setup.userInputDate = val;
    }),
    onChange: $setup.handleVisibleDateChange
  }, null, 8
  /* PROPS */
  , ["model-value", "onChange"])]), vue.withDirectives(vue.createVNode("span", _hoisted_6$2, [vue.createVNode(_component_b_input, {
    placeholder: "选择时间",
    "model-value": $setup.visibleTime,
    size: "small",
    onFocus: $setup.onTimePickerInputFocus,
    onInput: _cache[2] || (_cache[2] = function (val) {
      return $setup.userInputTime = val;
    }),
    onChange: $setup.handleVisibleTimeChange
  }, null, 8
  /* PROPS */
  , ["model-value", "onFocus", "onChange"]), vue.createVNode(_component_time_pick_panel, {
    visible: $setup.timePickerVisible,
    format: $setup.timeFormat,
    "time-arrow-control": $setup.arrowControl,
    "parsed-value": $setup.innerDate,
    onPick: $setup.handleTimePick
  }, null, 8
  /* PROPS */
  , ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])], 512
  /* NEED_PATCH */
  ), [[_directive_click_outside, $setup.handleTimePickClose]])])) : vue.createCommentVNode("v-if", true), vue.withDirectives(vue.createVNode("div", {
    class: ["bin-date-picker__header", {
      'bin-date-picker__header--bordered': $setup.currentView === 'year' || $setup.currentView === 'month'
    }]
  }, [vue.createVNode("button", {
    type: "button",
    "aria-label": "上一年",
    class: "bin-picker-panel__icon-btn bin-date-picker__prev-btn",
    onClick: _cache[3] || (_cache[3] = function () {
      return $setup.prevYear_ && $setup.prevYear_.apply($setup, arguments);
    })
  }, [_hoisted_7$2]), vue.withDirectives(vue.createVNode("button", {
    type: "button",
    "aria-label": "上个月",
    class: "bin-picker-panel__icon-btn bin-date-picker__prev-btn",
    onClick: _cache[4] || (_cache[4] = function () {
      return $setup.prevMonth_ && $setup.prevMonth_.apply($setup, arguments);
    })
  }, [_hoisted_8$2], 512
  /* NEED_PATCH */
  ), [[vue.vShow, $setup.currentView === 'date']]), vue.createVNode("span", {
    role: "button",
    class: "bin-date-picker__header-label",
    onClick: _cache[5] || (_cache[5] = function () {
      return $setup.showYearPicker && $setup.showYearPicker.apply($setup, arguments);
    })
  }, vue.toDisplayString($setup.yearLabel), 1
  /* TEXT */
  ), vue.withDirectives(vue.createVNode("span", {
    role: "button",
    class: ["bin-date-picker__header-label", {
      active: $setup.currentView === 'month'
    }],
    onClick: _cache[6] || (_cache[6] = function () {
      return $setup.showMonthPicker && $setup.showMonthPicker.apply($setup, arguments);
    })
  }, vue.toDisplayString($setup.month + 1 + " \u6708"), 3
  /* TEXT, CLASS */
  ), [[vue.vShow, $setup.currentView === 'date']]), vue.createVNode("button", {
    type: "button",
    "aria-label": "下一年",
    class: "bin-picker-panel__icon-btn bin-date-picker__next-btn",
    onClick: _cache[7] || (_cache[7] = function () {
      return $setup.nextYear_ && $setup.nextYear_.apply($setup, arguments);
    })
  }, [_hoisted_9$2]), vue.withDirectives(vue.createVNode("button", {
    type: "button",
    "aria-label": "下个月",
    class: "bin-picker-panel__icon-btn bin-date-picker__next-btn",
    onClick: _cache[8] || (_cache[8] = function () {
      return $setup.nextMonth_ && $setup.nextMonth_.apply($setup, arguments);
    })
  }, [_hoisted_10$2], 512
  /* NEED_PATCH */
  ), [[vue.vShow, $setup.currentView === 'date']])], 2
  /* CLASS */
  ), [[vue.vShow, $setup.currentView !== 'time']]), vue.createVNode("div", _hoisted_11$2, [$setup.currentView === 'date' ? (vue.openBlock(), vue.createBlock(_component_date_table, {
    key: 0,
    "selection-mode": $setup.selectionMode,
    date: $setup.innerDate,
    "parsed-value": $props.parsedValue,
    "disabled-date": $setup.disabledDate,
    onPick: $setup.handleDatePick
  }, null, 8
  /* PROPS */
  , ["selection-mode", "date", "parsed-value", "disabled-date", "onPick"])) : vue.createCommentVNode("v-if", true), $setup.currentView === 'year' ? (vue.openBlock(), vue.createBlock(_component_year_table, {
    key: 1,
    date: $setup.innerDate,
    "disabled-date": $setup.disabledDate,
    "parsed-value": $props.parsedValue,
    onPick: $setup.handleYearPick
  }, null, 8
  /* PROPS */
  , ["date", "disabled-date", "parsed-value", "onPick"])) : vue.createCommentVNode("v-if", true), $setup.currentView === 'month' ? (vue.openBlock(), vue.createBlock(_component_month_table, {
    key: 2,
    date: $setup.innerDate,
    "parsed-value": $props.parsedValue,
    "disabled-date": $setup.disabledDate,
    onPick: $setup.handleMonthPick
  }, null, 8
  /* PROPS */
  , ["date", "parsed-value", "disabled-date", "onPick"])) : vue.createCommentVNode("v-if", true)])])]), vue.withDirectives(vue.createVNode("div", _hoisted_12$2, [vue.withDirectives(vue.createVNode(_component_b_button, {
    size: "mini",
    type: "text",
    class: "bin-picker-panel__link-btn",
    onClick: $setup.changeToNow
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_13$2];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onClick"]), [[vue.vShow, $setup.selectionMode !== 'dates']]), vue.createVNode(_component_b_button, {
    type: "primary",
    size: "mini",
    class: "bin-picker-panel__link-btn",
    onClick: $setup.onConfirm
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_14$1];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onClick"])], 512
  /* NEED_PATCH */
  ), [[vue.vShow, $setup.footerVisible && $setup.currentView === 'date']])], 2
  /* CLASS */
  );
}

script$l.render = render$k;
script$l.__file = "src/components/date-picker/date-picker-com/panel-date-pick.vue";

var script$k = {
  directives: {
    ClickOutside: ClickOutside
  },
  components: {
    TimePickPanel: script$q,
    DateTable: script$o,
    BInput: script$1D,
    BButton: script$1B
  },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    },
    type: {
      type: String,
      required: true
    }
  },
  emits: ['pick', 'set-picker-option'],
  setup: function setup(props, ctx) {
    var leftDate = vue.ref(dayjs_min());
    var rightDate = vue.ref(dayjs_min().add(1, 'month'));
    var minDate = vue.ref(null);
    var maxDate = vue.ref(null);
    var dateUserInput = vue.ref({
      min: null,
      max: null
    });
    var timeUserInput = vue.ref({
      min: null,
      max: null
    });
    var leftLabel = vue.computed(function () {
      return leftDate.value.year() + ' 年 ' + (leftDate.value.month() + 1 + "\u6708");
    });
    var rightLabel = vue.computed(function () {
      return rightDate.value.year() + ' 年 ' + (rightDate.value.month() + 1 + "\u6708");
    });
    var leftYear = vue.computed(function () {
      return leftDate.value.year();
    });
    var leftMonth = vue.computed(function () {
      return leftDate.value.month();
    });
    var rightYear = vue.computed(function () {
      return rightDate.value.year();
    });
    var rightMonth = vue.computed(function () {
      return rightDate.value.month();
    });
    var hasShortcuts = vue.computed(function () {
      return !!shortcuts.length;
    });
    var minVisibleDate = vue.computed(function () {
      if (dateUserInput.value.min !== null) return dateUserInput.value.min;
      if (minDate.value) return minDate.value.format(dateFormat.value);
      return '';
    });
    var maxVisibleDate = vue.computed(function () {
      if (dateUserInput.value.max !== null) return dateUserInput.value.max;
      if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(dateFormat.value);
      return '';
    });
    var minVisibleTime = vue.computed(function () {
      if (timeUserInput.value.min !== null) return timeUserInput.value.min;
      if (minDate.value) return minDate.value.format(timeFormat.value);
      return '';
    });
    var maxVisibleTime = vue.computed(function () {
      if (timeUserInput.value.max !== null) return timeUserInput.value.max;
      if (maxDate.value || minDate.value) return (maxDate.value || minDate.value).format(timeFormat.value);
      return '';
    });
    var timeFormat = vue.computed(function () {
      return extractTimeFormat(format);
    });
    var dateFormat = vue.computed(function () {
      return extractDateFormat(format);
    });

    var leftPrevYear = function leftPrevYear() {
      leftDate.value = leftDate.value.subtract(1, 'year');

      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, 'month');
      }
    };

    var leftPrevMonth = function leftPrevMonth() {
      leftDate.value = leftDate.value.subtract(1, 'month');

      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, 'month');
      }
    };

    var rightNextYear = function rightNextYear() {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, 'year');
        rightDate.value = leftDate.value.add(1, 'month');
      } else {
        rightDate.value = rightDate.value.add(1, 'year');
      }
    };

    var rightNextMonth = function rightNextMonth() {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, 'month');
        rightDate.value = leftDate.value.add(1, 'month');
      } else {
        rightDate.value = rightDate.value.add(1, 'month');
      }
    };

    var leftNextYear = function leftNextYear() {
      leftDate.value = leftDate.value.add(1, 'year');
    };

    var leftNextMonth = function leftNextMonth() {
      leftDate.value = leftDate.value.add(1, 'month');
    };

    var rightPrevYear = function rightPrevYear() {
      rightDate.value = rightDate.value.subtract(1, 'year');
    };

    var rightPrevMonth = function rightPrevMonth() {
      rightDate.value = rightDate.value.subtract(1, 'month');
    };

    var enableMonthArrow = vue.computed(function () {
      var nextMonth = (leftMonth.value + 1) % 12;
      var yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    var enableYearArrow = vue.computed(function () {
      return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });

    var isValidValue = function isValidValue(value) {
      return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };

    var rangeState = vue.ref({
      endDate: null,
      selecting: false
    });
    var btnDisabled = vue.computed(function () {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
    });

    var handleChangeRange = function handleChangeRange(val) {
      rangeState.value = val;
    };

    var onSelect = function onSelect(selecting) {
      rangeState.value.selecting = selecting;

      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };

    var showTime = vue.computed(function () {
      return props.type === 'datetime' || props.type === 'datetimerange';
    });

    var handleConfirm = function handleConfirm(visible) {
      if (visible === void 0) {
        visible = false;
      }

      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit('pick', [minDate.value, maxDate.value], visible);
      }
    };

    var formatEmit = function formatEmit(emitDayjs, index) {
      if (!emitDayjs) return;

      if (defaultTime) {
        var defaultTimeD = dayjs_min(defaultTime[index] || defaultTime);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }

      return emitDayjs;
    };

    var handleRangePick = function handleRangePick(val, close) {
      if (close === void 0) {
        close = true;
      }

      var minDate_ = formatEmit(val.minDate, 0);
      var maxDate_ = formatEmit(val.maxDate, 1);

      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }

      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close || showTime.value) return;
      handleConfirm();
    };

    var handleShortcutClick = function handleShortcutClick(shortcut) {
      if (shortcut.value) {
        ctx.emit('pick', [dayjs_min(shortcut.value[0]), dayjs_min(shortcut.value[1])]);
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    var minTimePickerVisible = vue.ref(false);
    var maxTimePickerVisible = vue.ref(false);

    var handleMinTimeClose = function handleMinTimeClose() {
      minTimePickerVisible.value = false;
    };

    var handleMaxTimeClose = function handleMaxTimeClose() {
      maxTimePickerVisible.value = false;
    };

    var handleDateInput = function handleDateInput(value, type) {
      dateUserInput.value[type] = value;
      var parsedValueD = dayjs_min(value, dateFormat.value);

      if (parsedValueD.isValid()) {
        if (disabledDate && disabledDate(parsedValueD.toDate())) {
          return;
        }

        if (type === 'min') {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());

          if (!props.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, 'month');
            maxDate.value = minDate.value.add(1, 'month');
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());

          if (!props.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, 'month');
            minDate.value = maxDate.value.subtract(1, 'month');
          }
        }
      }
    };

    var handleDateChange = function handleDateChange(value, type) {
      dateUserInput.value[type] = null;
    };

    var handleTimeInput = function handleTimeInput(value, type) {
      timeUserInput.value[type] = value;
      var parsedValueD = dayjs_min(value, timeFormat.value);

      if (parsedValueD.isValid()) {
        if (type === 'min') {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());

          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;

          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };

    var handleTimeChange = function handleTimeChange(value, type) {
      timeUserInput.value[type] = null;

      if (type === 'min') {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };

    var handleMinTimePick = function handleMinTimePick(value, visible, first) {
      if (timeUserInput.value.min) return;

      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }

      if (!first) {
        minTimePickerVisible.value = visible;
      }

      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
      }
    };

    var handleMaxTimePick = function handleMaxTimePick(value, visible, first) {
      if (timeUserInput.value.max) return;

      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }

      if (!first) {
        maxTimePickerVisible.value = visible;
      }

      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };

    var handleClear = function handleClear() {
      leftDate.value = getDefaultValue()[0];
      rightDate.value = leftDate.value.add(1, 'month');
      ctx.emit('pick', null);
    };

    var formatToString = function formatToString(value) {
      return Array.isArray(value) ? value.map(function (_) {
        return _.format(format);
      }) : value.format(format);
    };

    var parseUserInput = function parseUserInput(value) {
      return Array.isArray(value) ? value.map(function (_) {
        return dayjs_min(_, format);
      }) : dayjs_min(value, format);
    };

    var getDefaultValue = function getDefaultValue() {
      var start;

      if (Array.isArray(defaultValue)) {
        var left = dayjs_min(defaultValue[0]);
        var right = dayjs_min(defaultValue[1]);

        if (!props.unlinkPanels) {
          right = left.add(1, 'month');
        }

        return [left, right];
      } else if (defaultValue) {
        start = dayjs_min(defaultValue);
      } else {
        start = dayjs_min();
      }

      return [start, start.add(1, 'month')];
    };

    ctx.emit('set-picker-option', ['isValidValue', isValidValue]);
    ctx.emit('set-picker-option', ['parseUserInput', parseUserInput]);
    ctx.emit('set-picker-option', ['formatToString', formatToString]);
    ctx.emit('set-picker-option', ['handleClear', handleClear]);
    var pickerBase = vue.inject('EP_PICKER_BASE', {});
    var _pickerBase$props = pickerBase.props,
        shortcuts = _pickerBase$props.shortcuts,
        disabledDate = _pickerBase$props.disabledDate,
        cellClassName = _pickerBase$props.cellClassName,
        format = _pickerBase$props.format,
        defaultTime = _pickerBase$props.defaultTime,
        defaultValue = _pickerBase$props.defaultValue,
        arrowControl = _pickerBase$props.arrowControl;
    vue.watch(function () {
      return props.parsedValue;
    }, function (newVal) {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;

        if (props.unlinkPanels && maxDate.value) {
          var minDateYear = minDate.value.year();
          var minDateMonth = minDate.value.month();
          var maxDateYear = maxDate.value.year();
          var maxDateMonth = maxDate.value.month();
          rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, 'month') : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, 'month');
        }
      } else {
        var defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    return {
      shortcuts: shortcuts,
      disabledDate: disabledDate,
      cellClassName: cellClassName,
      minTimePickerVisible: minTimePickerVisible,
      maxTimePickerVisible: maxTimePickerVisible,
      handleMinTimeClose: handleMinTimeClose,
      handleMaxTimeClose: handleMaxTimeClose,
      handleShortcutClick: handleShortcutClick,
      rangeState: rangeState,
      minDate: minDate,
      maxDate: maxDate,
      handleRangePick: handleRangePick,
      onSelect: onSelect,
      handleChangeRange: handleChangeRange,
      btnDisabled: btnDisabled,
      enableYearArrow: enableYearArrow,
      enableMonthArrow: enableMonthArrow,
      rightPrevMonth: rightPrevMonth,
      rightPrevYear: rightPrevYear,
      rightNextMonth: rightNextMonth,
      rightNextYear: rightNextYear,
      leftPrevMonth: leftPrevMonth,
      leftPrevYear: leftPrevYear,
      leftNextMonth: leftNextMonth,
      leftNextYear: leftNextYear,
      hasShortcuts: hasShortcuts,
      leftLabel: leftLabel,
      rightLabel: rightLabel,
      leftDate: leftDate,
      rightDate: rightDate,
      showTime: showTime,
      minVisibleDate: minVisibleDate,
      maxVisibleDate: maxVisibleDate,
      minVisibleTime: minVisibleTime,
      maxVisibleTime: maxVisibleTime,
      arrowControl: arrowControl,
      handleDateInput: handleDateInput,
      handleDateChange: handleDateChange,
      handleTimeInput: handleTimeInput,
      handleTimeChange: handleTimeChange,
      handleMinTimePick: handleMinTimePick,
      handleMaxTimePick: handleMaxTimePick,
      handleClear: handleClear,
      handleConfirm: handleConfirm,
      timeFormat: timeFormat
    };
  }
};

var _hoisted_1$b = {
  class: "bin-picker-panel__body-wrapper"
};
var _hoisted_2$6 = {
  key: 0,
  class: "bin-picker-panel__sidebar"
};
var _hoisted_3$3 = {
  class: "bin-picker-panel__body"
};
var _hoisted_4$2 = {
  key: 0,
  class: "bin-date-range-picker__time-header"
};
var _hoisted_5$2 = {
  class: "bin-date-range-picker__editors-wrap"
};
var _hoisted_6$1 = {
  class: "bin-date-range-picker__time-picker-wrap"
};
var _hoisted_7$1 = {
  class: "bin-date-range-picker__time-picker-wrap"
};

var _hoisted_8$1 = /*#__PURE__*/vue.createVNode("span", {
  class: "bin-icon-arrow-right"
}, [/*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
})], -1
/* HOISTED */
);

var _hoisted_9$1 = {
  class: "bin-date-range-picker__editors-wrap is-right"
};
var _hoisted_10$1 = {
  class: "bin-date-range-picker__time-picker-wrap"
};
var _hoisted_11$1 = {
  class: "bin-date-range-picker__time-picker-wrap"
};
var _hoisted_12$1 = {
  class: "bin-picker-panel__content bin-date-range-picker__content is-left"
};
var _hoisted_13$1 = {
  class: "bin-date-range-picker__header"
};

var _hoisted_14 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
}, null, -1
/* HOISTED */
);

var _hoisted_15 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
}, null, -1
/* HOISTED */
);

var _hoisted_16 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
}, null, -1
/* HOISTED */
);

var _hoisted_17 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

var _hoisted_18 = {
  class: "bin-date-range-picker-table__content"
};
var _hoisted_19 = {
  class: "bin-picker-panel__content bin-date-range-picker__content is-right"
};
var _hoisted_20 = {
  class: "bin-date-range-picker__header"
};

var _hoisted_21 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
}, null, -1
/* HOISTED */
);

var _hoisted_22 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-left"
}, null, -1
/* HOISTED */
);

var _hoisted_23 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
}, null, -1
/* HOISTED */
);

var _hoisted_24 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

var _hoisted_25 = {
  class: "bin-date-range-picker-table__content"
};
var _hoisted_26 = {
  key: 0,
  class: "bin-picker-panel__footer"
};

var _hoisted_27 = /*#__PURE__*/vue.createTextVNode(" 清空 ");

var _hoisted_28 = /*#__PURE__*/vue.createTextVNode(" 确定 ");

function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_input = vue.resolveComponent("b-input");

  var _component_time_pick_panel = vue.resolveComponent("time-pick-panel");

  var _component_date_table = vue.resolveComponent("date-table");

  var _component_b_button = vue.resolveComponent("b-button");

  var _directive_click_outside = vue.resolveDirective("click-outside");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-picker-panel bin-date-range-picker", [{
      'has-sidebar': _ctx.$slots.sidebar || $setup.hasShortcuts,
      'has-time': $setup.showTime
    }]]
  }, [vue.createVNode("div", _hoisted_1$b, [vue.renderSlot(_ctx.$slots, "sidebar", {
    class: "bin-picker-panel__sidebar"
  }), $setup.hasShortcuts ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$6, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.shortcuts, function (shortcut, key) {
    return vue.openBlock(), vue.createBlock("button", {
      key: key,
      type: "button",
      class: "bin-picker-panel__shortcut",
      onClick: function onClick($event) {
        return $setup.handleShortcutClick(shortcut);
      }
    }, vue.toDisplayString(shortcut.text), 9
    /* TEXT, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_3$3, [$setup.showTime ? (vue.openBlock(), vue.createBlock("div", _hoisted_4$2, [vue.createVNode("span", _hoisted_5$2, [vue.createVNode("span", _hoisted_6$1, [vue.createVNode(_component_b_input, {
    size: "small",
    disabled: $setup.rangeState.selecting,
    placeholder: "开始日期",
    class: "bin-date-range-picker__editor",
    "model-value": $setup.minVisibleDate,
    onInput: _cache[1] || (_cache[1] = function (val) {
      return $setup.handleDateInput(val, 'min');
    }),
    onChange: _cache[2] || (_cache[2] = function (val) {
      return $setup.handleDateChange(val, 'min');
    })
  }, null, 8
  /* PROPS */
  , ["disabled", "model-value"])]), vue.withDirectives(vue.createVNode("span", _hoisted_7$1, [vue.createVNode(_component_b_input, {
    size: "small",
    class: "bin-date-range-picker__editor",
    disabled: $setup.rangeState.selecting,
    placeholder: "开始时间",
    "model-value": $setup.minVisibleTime,
    onFocus: _cache[3] || (_cache[3] = function ($event) {
      return $setup.minTimePickerVisible = true;
    }),
    onInput: _cache[4] || (_cache[4] = function (val) {
      return $setup.handleTimeInput(val, 'min');
    }),
    onChange: _cache[5] || (_cache[5] = function (val) {
      return $setup.handleTimeChange(val, 'min');
    })
  }, null, 8
  /* PROPS */
  , ["disabled", "model-value"]), vue.createVNode(_component_time_pick_panel, {
    visible: $setup.minTimePickerVisible,
    format: $setup.timeFormat,
    "datetime-role": "start",
    "time-arrow-control": $setup.arrowControl,
    "parsed-value": $setup.leftDate,
    onPick: $setup.handleMinTimePick
  }, null, 8
  /* PROPS */
  , ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])], 512
  /* NEED_PATCH */
  ), [[_directive_click_outside, $setup.handleMinTimeClose]])]), _hoisted_8$1, vue.createVNode("span", _hoisted_9$1, [vue.createVNode("span", _hoisted_10$1, [vue.createVNode(_component_b_input, {
    size: "small",
    class: "bin-date-range-picker__editor",
    disabled: $setup.rangeState.selecting,
    placeholder: "结束日期",
    "model-value": $setup.maxVisibleDate,
    readonly: !$setup.minDate,
    onInput: _cache[6] || (_cache[6] = function (val) {
      return $setup.handleDateInput(val, 'max');
    }),
    onChange: _cache[7] || (_cache[7] = function (val) {
      return $setup.handleDateChange(val, 'max');
    })
  }, null, 8
  /* PROPS */
  , ["disabled", "model-value", "readonly"])]), vue.withDirectives(vue.createVNode("span", _hoisted_11$1, [vue.createVNode(_component_b_input, {
    size: "small",
    class: "bin-date-range-picker__editor",
    disabled: $setup.rangeState.selecting,
    placeholder: "结束时间",
    "model-value": $setup.maxVisibleTime,
    readonly: !$setup.minDate,
    onFocus: _cache[8] || (_cache[8] = function ($event) {
      return $setup.minDate && ($setup.maxTimePickerVisible = true);
    }),
    onInput: _cache[9] || (_cache[9] = function (val) {
      return $setup.handleTimeInput(val, 'max');
    }),
    onChange: _cache[10] || (_cache[10] = function (val) {
      return $setup.handleTimeChange(val, 'max');
    })
  }, null, 8
  /* PROPS */
  , ["disabled", "model-value", "readonly"]), vue.createVNode(_component_time_pick_panel, {
    "datetime-role": "end",
    visible: $setup.maxTimePickerVisible,
    format: $setup.timeFormat,
    "time-arrow-control": $setup.arrowControl,
    "parsed-value": $setup.rightDate,
    onPick: $setup.handleMaxTimePick
  }, null, 8
  /* PROPS */
  , ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])], 512
  /* NEED_PATCH */
  ), [[_directive_click_outside, $setup.handleMaxTimeClose]])])])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_12$1, [vue.createVNode("div", _hoisted_13$1, [vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__prev-btn",
    onClick: _cache[11] || (_cache[11] = function () {
      return $setup.leftPrevYear && $setup.leftPrevYear.apply($setup, arguments);
    })
  }, [_hoisted_14]), vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__prev-btn",
    onClick: _cache[12] || (_cache[12] = function () {
      return $setup.leftPrevMonth && $setup.leftPrevMonth.apply($setup, arguments);
    })
  }, [_hoisted_15]), $props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 0,
    type: "button",
    disabled: !$setup.enableYearArrow,
    class: [{
      'is-disabled': !$setup.enableYearArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__next-btn"],
    onClick: _cache[13] || (_cache[13] = function () {
      return $setup.leftNextYear && $setup.leftNextYear.apply($setup, arguments);
    })
  }, [_hoisted_16], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), $props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 1,
    type: "button",
    disabled: !$setup.enableMonthArrow,
    class: [{
      'is-disabled': !$setup.enableMonthArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__next-btn"],
    onClick: _cache[14] || (_cache[14] = function () {
      return $setup.leftNextMonth && $setup.leftNextMonth.apply($setup, arguments);
    })
  }, [_hoisted_17], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", null, vue.toDisplayString($setup.leftLabel), 1
  /* TEXT */
  )]), vue.createVNode("div", _hoisted_18, [vue.createVNode(_component_date_table, {
    "selection-mode": "range",
    date: $setup.leftDate,
    "min-date": $setup.minDate,
    "max-date": $setup.maxDate,
    "range-state": $setup.rangeState,
    "disabled-date": $setup.disabledDate,
    "cell-class-name": $setup.cellClassName,
    onChangerange: $setup.handleChangeRange,
    onPick: $setup.handleRangePick,
    onSelect: $setup.onSelect
  }, null, 8
  /* PROPS */
  , ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])])]), vue.createVNode("div", _hoisted_19, [vue.createVNode("div", _hoisted_20, [$props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 0,
    type: "button",
    disabled: !$setup.enableYearArrow,
    class: [{
      'is-disabled': !$setup.enableYearArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__prev-btn"],
    onClick: _cache[15] || (_cache[15] = function () {
      return $setup.rightPrevYear && $setup.rightPrevYear.apply($setup, arguments);
    })
  }, [_hoisted_21], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), $props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 1,
    type: "button",
    disabled: !$setup.enableMonthArrow,
    class: [{
      'is-disabled': !$setup.enableMonthArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__prev-btn"],
    onClick: _cache[16] || (_cache[16] = function () {
      return $setup.rightPrevMonth && $setup.rightPrevMonth.apply($setup, arguments);
    })
  }, [_hoisted_22], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__next-btn",
    onClick: _cache[17] || (_cache[17] = function () {
      return $setup.rightNextYear && $setup.rightNextYear.apply($setup, arguments);
    })
  }, [_hoisted_23]), vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__next-btn",
    onClick: _cache[18] || (_cache[18] = function () {
      return $setup.rightNextMonth && $setup.rightNextMonth.apply($setup, arguments);
    })
  }, [_hoisted_24]), vue.createVNode("div", null, vue.toDisplayString($setup.rightLabel), 1
  /* TEXT */
  )]), vue.createVNode("div", _hoisted_25, [vue.createVNode(_component_date_table, {
    "selection-mode": "range",
    date: $setup.rightDate,
    "min-date": $setup.minDate,
    "max-date": $setup.maxDate,
    "range-state": $setup.rangeState,
    "disabled-date": $setup.disabledDate,
    "cell-class-name": $setup.cellClassName,
    onChangerange: $setup.handleChangeRange,
    onPick: $setup.handleRangePick,
    onSelect: $setup.onSelect
  }, null, 8
  /* PROPS */
  , ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])])])])]), $setup.showTime ? (vue.openBlock(), vue.createBlock("div", _hoisted_26, [vue.createVNode(_component_b_button, {
    size: "mini",
    type: "text",
    onClick: $setup.handleClear
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_27];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onClick"]), vue.createVNode(_component_b_button, {
    type: "primary",
    size: "mini",
    disabled: $setup.btnDisabled,
    onClick: _cache[19] || (_cache[19] = function ($event) {
      return $setup.handleConfirm(false);
    })
  }, {
    default: vue.withCtx(function () {
      return [_hoisted_28];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["disabled"])])) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$k.render = render$j;
script$k.__file = "src/components/date-picker/date-picker-com/panel-date-range.vue";

var script$j = {
  components: {
    MonthTable: script$n
  },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  },
  emits: ['pick', 'set-picker-option'],
  setup: function setup(props, ctx) {
    var leftDate = vue.ref(dayjs_min());
    var rightDate = vue.ref(dayjs_min().add(1, 'year'));
    var hasShortcuts = vue.computed(function () {
      return !!shortcuts.length;
    });

    var handleShortcutClick = function handleShortcutClick(shortcut) {
      if (shortcut.value) {
        ctx.emit('pick', [dayjs_min(shortcut.value[0]), dayjs_min(shortcut.value[1])]);
        return;
      }

      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };

    var leftPrevYear = function leftPrevYear() {
      leftDate.value = leftDate.value.subtract(1, 'year');

      if (!props.unlinkPanels) {
        rightDate.value = rightDate.value.subtract(1, 'year');
      }
    };

    var rightNextYear = function rightNextYear() {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, 'year');
      }

      rightDate.value = rightDate.value.add(1, 'year');
    };

    var leftNextYear = function leftNextYear() {
      leftDate.value = leftDate.value.add(1, 'year');
    };

    var rightPrevYear = function rightPrevYear() {
      rightDate.value = rightDate.value.subtract(1, 'year');
    };

    var leftLabel = vue.computed(function () {
      return leftDate.value.year() + " \u5E74";
    });
    var rightLabel = vue.computed(function () {
      return rightDate.value.year() + " \u5E74";
    });
    var leftYear = vue.computed(function () {
      return leftDate.value.year();
    });
    var rightYear = vue.computed(function () {
      return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
    });
    var enableYearArrow = vue.computed(function () {
      return props.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    var minDate = vue.ref(null);
    var maxDate = vue.ref(null);
    var rangeState = vue.ref({
      endDate: null,
      selecting: false
    });

    var handleChangeRange = function handleChangeRange(val) {
      rangeState.value = val;
    };

    var handleRangePick = function handleRangePick(val, close) {
      if (close === void 0) {
        close = true;
      }

      // const defaultTime = props.defaultTime || []
      // const minDate_ = modifyWithTimeString(val.minDate, defaultTime[0])
      // const maxDate_ = modifyWithTimeString(val.maxDate, defaultTime[1])
      // todo
      var minDate_ = val.minDate;
      var maxDate_ = val.maxDate;

      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }

      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close) return;
      handleConfirm();
    };

    var isValidValue = function isValidValue(value) {
      return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };

    var handleConfirm = function handleConfirm(visible) {
      if (visible === void 0) {
        visible = false;
      }

      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit('pick', [minDate.value, maxDate.value], visible);
      }
    };

    var onSelect = function onSelect(selecting) {
      rangeState.value.selecting = selecting;

      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };

    var formatToString = function formatToString(value) {
      return value.map(function (_) {
        return _.format(format);
      });
    };

    var getDefaultValue = function getDefaultValue() {
      var start;

      if (Array.isArray(defaultValue)) {
        var left = dayjs_min(defaultValue[0]);
        var right = dayjs_min(defaultValue[1]);

        if (!props.unlinkPanels) {
          right = left.add(1, 'year');
        }

        return [left, right];
      } else if (defaultValue) {
        start = dayjs_min(defaultValue);
      } else {
        start = dayjs_min();
      }

      return [start, start.add(1, 'year')];
    };

    ctx.emit('set-picker-option', ['formatToString', formatToString]);
    var pickerBase = vue.inject('EP_PICKER_BASE', {});
    var _pickerBase$props = pickerBase.props,
        shortcuts = _pickerBase$props.shortcuts,
        disabledDate = _pickerBase$props.disabledDate,
        format = _pickerBase$props.format,
        defaultValue = _pickerBase$props.defaultValue;
    vue.watch(function () {
      return props.parsedValue;
    }, function (newVal) {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;

        if (props.unlinkPanels && maxDate.value) {
          var minDateYear = minDate.value.year();
          var maxDateYear = maxDate.value.year();
          rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, 'year') : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, 'year');
        }
      } else {
        var defaultArr = getDefaultValue();
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, {
      immediate: true
    });
    return {
      shortcuts: shortcuts,
      disabledDate: disabledDate,
      onSelect: onSelect,
      handleRangePick: handleRangePick,
      rangeState: rangeState,
      handleChangeRange: handleChangeRange,
      minDate: minDate,
      maxDate: maxDate,
      enableYearArrow: enableYearArrow,
      leftLabel: leftLabel,
      rightLabel: rightLabel,
      leftNextYear: leftNextYear,
      leftPrevYear: leftPrevYear,
      rightNextYear: rightNextYear,
      rightPrevYear: rightPrevYear,
      leftDate: leftDate,
      rightDate: rightDate,
      hasShortcuts: hasShortcuts,
      handleShortcutClick: handleShortcutClick
    };
  }
};

var _hoisted_1$a = {
  class: "bin-picker-panel__body-wrapper"
};
var _hoisted_2$5 = {
  key: 0,
  class: "bin-picker-panel__sidebar"
};
var _hoisted_3$2 = {
  class: "bin-picker-panel__body"
};
var _hoisted_4$1 = {
  class: "bin-picker-panel__content bin-date-range-picker__content is-left"
};
var _hoisted_5$1 = {
  class: "bin-date-range-picker__header"
};

var _hoisted_6 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
}, null, -1
/* HOISTED */
);

var _hoisted_7 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
}, null, -1
/* HOISTED */
);

var _hoisted_8 = {
  class: "bin-date-range-picker-table__content"
};
var _hoisted_9 = {
  class: "bin-picker-panel__content bin-date-range-picker__content is-right"
};
var _hoisted_10 = {
  class: "bin-date-range-picker__header"
};

var _hoisted_11 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleleft"
}, null, -1
/* HOISTED */
);

var _hoisted_12 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-doubleright"
}, null, -1
/* HOISTED */
);

var _hoisted_13 = {
  class: "bin-date-range-picker-table__content"
};
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_month_table = vue.resolveComponent("month-table");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-picker-panel bin-date-range-picker", [{
      'has-sidebar': _ctx.$slots.sidebar || $setup.hasShortcuts
    }]]
  }, [vue.createVNode("div", _hoisted_1$a, [vue.renderSlot(_ctx.$slots, "sidebar", {
    class: "bin-picker-panel__sidebar"
  }), $setup.hasShortcuts ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$5, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.shortcuts, function (shortcut, key) {
    return vue.openBlock(), vue.createBlock("button", {
      key: key,
      type: "button",
      class: "bin-picker-panel__shortcut",
      onClick: function onClick($event) {
        return $setup.handleShortcutClick(shortcut);
      }
    }, vue.toDisplayString(shortcut.text), 9
    /* TEXT, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_3$2, [vue.createVNode("div", _hoisted_4$1, [vue.createVNode("div", _hoisted_5$1, [vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__prev-btn",
    onClick: _cache[1] || (_cache[1] = function () {
      return $setup.leftPrevYear && $setup.leftPrevYear.apply($setup, arguments);
    })
  }, [_hoisted_6]), $props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 0,
    type: "button",
    disabled: !$setup.enableYearArrow,
    class: [{
      'is-disabled': !$setup.enableYearArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__next-btn"],
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.leftNextYear && $setup.leftNextYear.apply($setup, arguments);
    })
  }, [_hoisted_7], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", null, vue.toDisplayString($setup.leftLabel), 1
  /* TEXT */
  )]), vue.createVNode("div", _hoisted_8, [vue.createVNode(_component_month_table, {
    "selection-mode": "range",
    date: $setup.leftDate,
    "min-date": $setup.minDate,
    "max-date": $setup.maxDate,
    "range-state": $setup.rangeState,
    "disabled-date": $setup.disabledDate,
    onChangerange: $setup.handleChangeRange,
    onPick: $setup.handleRangePick,
    onSelect: $setup.onSelect
  }, null, 8
  /* PROPS */
  , ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])])]), vue.createVNode("div", _hoisted_9, [vue.createVNode("div", _hoisted_10, [$props.unlinkPanels ? (vue.openBlock(), vue.createBlock("button", {
    key: 0,
    type: "button",
    disabled: !$setup.enableYearArrow,
    class: [{
      'is-disabled': !$setup.enableYearArrow
    }, "bin-picker-panel__icon-btn bin-date-picker__prev-btn"],
    onClick: _cache[3] || (_cache[3] = function () {
      return $setup.rightPrevYear && $setup.rightPrevYear.apply($setup, arguments);
    })
  }, [_hoisted_11], 10
  /* CLASS, PROPS */
  , ["disabled"])) : vue.createCommentVNode("v-if", true), vue.createVNode("button", {
    type: "button",
    class: "bin-picker-panel__icon-btn bin-date-picker__next-btn",
    onClick: _cache[4] || (_cache[4] = function () {
      return $setup.rightNextYear && $setup.rightNextYear.apply($setup, arguments);
    })
  }, [_hoisted_12]), vue.createVNode("div", null, vue.toDisplayString($setup.rightLabel), 1
  /* TEXT */
  )]), vue.createVNode("div", _hoisted_13, [vue.createVNode(_component_month_table, {
    "selection-mode": "range",
    date: $setup.rightDate,
    "min-date": $setup.minDate,
    "max-date": $setup.maxDate,
    "range-state": $setup.rangeState,
    "disabled-date": $setup.disabledDate,
    onChangerange: $setup.handleChangeRange,
    onPick: $setup.handleRangePick,
    onSelect: $setup.onSelect
  }, null, 8
  /* PROPS */
  , ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])])])])])], 2
  /* CLASS */
  );
}

script$j.render = render$i;
script$j.__file = "src/components/date-picker/date-picker-com/panel-month-range.vue";

var advancedFormat = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t,r){var n=t.prototype,s=n.format;r.en.ordinal=function(e){var t=["th","st","nd","rd"],r=e%100;return "["+e+(t[(r-20)%10]||t[r]||t[0])+"]"},n.format=function(e){var t=this,r=this.$locale(),n=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return n.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return n.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return n.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return "["+t.offsetName()+"]";case"zzz":return "["+t.offsetName("long")+"]";default:return e}}));return s.bind(this)(a)};}}));
});

var localeData = createCommonjsModule(function (module, exports) {
!function(n,e){module.exports=e();}(commonjsGlobal,(function(){return function(n,e,t){var r=e.prototype,o=function(n){return n&&(n.indexOf?n:n.s)},u=function(n,e,t,r,u){var i=n.name?n:n.$locale(),a=o(i[e]),s=o(i[t]),f=a||s.map((function(n){return n.substr(0,r)}));if(!u)return f;var d=i.weekStart;return f.map((function(n,e){return f[(e+(d||0))%7]}))},i=function(){return t.Ls[t.locale()]},a=function(n,e){return n.formats[e]||function(n){return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(n,e,t){return e||t.slice(1)}))}(n.formats[e.toUpperCase()])},s=function(){var n=this;return {months:function(e){return e?e.format("MMMM"):u(n,"months")},monthsShort:function(e){return e?e.format("MMM"):u(n,"monthsShort","months",3)},firstDayOfWeek:function(){return n.$locale().weekStart||0},weekdays:function(e){return e?e.format("dddd"):u(n,"weekdays")},weekdaysMin:function(e){return e?e.format("dd"):u(n,"weekdaysMin","weekdays",2)},weekdaysShort:function(e){return e?e.format("ddd"):u(n,"weekdaysShort","weekdays",3)},longDateFormat:function(e){return a(n.$locale(),e)},meridiem:this.$locale().meridiem,ordinal:this.$locale().ordinal}};r.localeData=function(){return s.bind(this)()},t.localeData=function(){var n=i();return {firstDayOfWeek:function(){return n.weekStart||0},weekdays:function(){return t.weekdays()},weekdaysShort:function(){return t.weekdaysShort()},weekdaysMin:function(){return t.weekdaysMin()},months:function(){return t.months()},monthsShort:function(){return t.monthsShort()},longDateFormat:function(e){return a(n,e)},meridiem:n.meridiem,ordinal:n.ordinal}},t.months=function(){return u(i(),"months")},t.monthsShort=function(){return u(i(),"monthsShort","months",3)},t.weekdays=function(n){return u(i(),"weekdays",null,null,n)},t.weekdaysShort=function(n){return u(i(),"weekdaysShort","weekdays",3,n)},t.weekdaysMin=function(n){return u(i(),"weekdaysMin","weekdays",2,n)};}}));
});

var weekOfYear = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e="week",t="year";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),"day");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,"millisecond"),o=this.diff(a,e,!0);return o<0?r(this).startOf("week").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)};}}));
});

var weekYear = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.weekYear=function(){var e=this.month(),t=this.week(),n=this.year();return 1===t&&11===e?n+1:0===e&&t>=52?n-1:n};}}));
});

var dayOfYear = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.dayOfYear=function(e){var t=Math.round((this.startOf("day")-this.startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"day")};}}));
});

var isSameOrAfter = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)};}}));
});

var isSameOrBefore = createCommonjsModule(function (module, exports) {
!function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i){i.prototype.isSameOrBefore=function(e,i){return this.isSame(e,i)||this.isBefore(e,i)};}}));
});

dayjs_min.extend(localeData);
dayjs_min.extend(advancedFormat);
dayjs_min.extend(customParseFormat);
dayjs_min.extend(weekOfYear);
dayjs_min.extend(weekYear);
dayjs_min.extend(dayOfYear);
dayjs_min.extend(isSameOrAfter);
dayjs_min.extend(isSameOrBefore);

var getPanel = function getPanel(type) {
  if (type === 'daterange' || type === 'datetimerange') {
    return script$k;
  } else if (type === 'monthrange') {
    return script$j;
  }

  return script$l;
};

var DatePicker = {
  name: 'BDatePicker',
  install: null,
  props: _extends$2({}, defaultProps, {
    type: {
      type: String,
      default: 'date'
    }
  }),
  emits: ['update:modelValue'],
  setup: function setup(props, ctx) {
    var commonPicker = vue.ref(null);
    var format = DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;

    var refProps = _extends$2({}, props, {
      focus: function focus() {
        var _commonPicker$value;

        (_commonPicker$value = commonPicker.value) == null ? void 0 : _commonPicker$value.handleFocus();
      }
    });

    ctx.expose(refProps);
    return function () {
      return vue.h(script$s, _extends$2({
        format: format
      }, props, {
        // allow format to be overwrite
        type: props.type,
        ref: commonPicker,
        'onUpdate:modelValue': function onUpdateModelValue(value) {
          return ctx.emit('update:modelValue', value);
        }
      }), {
        default: function _default(scopedProps) {
          return vue.h(getPanel(props.type), scopedProps);
        }
      });
    };
  }
};

DatePicker.install = function (app) {
  app.component(DatePicker.name, DatePicker);
};

// https://github.com/ElemeFE/element/blob/dev/packages/upload/src/ajax.js
function getError(action, option, xhr) {
  var msg = "fail to post " + action + " " + xhr.status;
  var err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = action;
  return err;
}

function getBody(xhr) {
  var text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}

function upload(option) {
  if (typeof XMLHttpRequest === 'undefined') {
    return;
  }

  var xhr = new XMLHttpRequest();
  var action = option.action;

  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  }

  var formData = new FormData();

  if (option.data) {
    Object.keys(option.data).map(function (key) {
      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.filename, option.file);

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr), getBody(xhr));
    }

    option.onSuccess(getBody(xhr));
  };

  xhr.open('post', action, true);

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  var headers = option.headers || {}; // if (headers['X-Requested-With'] !== null) {
  //   xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  // }

  for (var item in headers) {
    // eslint-disable-next-line no-prototype-builtins
    if (headers.hasOwnProperty(item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  }

  xhr.send(formData);
}

var prefixCls$3 = 'bin-upload';
var script$i = {
  name: 'UploadList',
  components: {
    BProgress: script$V
  },
  props: {
    files: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  data: function data() {
    return {
      prefixCls: prefixCls$3
    };
  },
  emits: ['file-click', 'file-preview', 'file-remove'],
  methods: {
    fileCls: function fileCls(file) {
      var _ref;

      return [prefixCls$3 + "-list-file", (_ref = {}, _ref[prefixCls$3 + "-list-file-finish"] = file.status === 'finished', _ref)];
    },
    handleClick: function handleClick(file) {
      this.$emit('file-click', file);
    },
    handlePreview: function handlePreview(file) {
      this.$emit('file-preview', file);
    },
    handleRemove: function handleRemove(file) {
      this.$emit('file-remove', file);
    },
    format: function format(file) {
      var format = file.name.split('.').pop().toLocaleLowerCase() || '';
      var type = 'file-text';

      if (['gif', 'jpg', 'jpeg', 'png', 'bmp', 'webp'].indexOf(format) > -1) {
        type = 'image';
      }

      if (['mp4', 'm3u8', 'rmvb', 'avi', 'swf', '3gp', 'mkv', 'flv'].indexOf(format) > -1) {
        type = 'video';
      }

      if (['mp3', 'wav', 'wma', 'ogg', 'aac', 'flac'].indexOf(format) > -1) {
        type = 'Youtube';
      }

      if (['pages', 'epub', 'pdf'].indexOf(format) > -1) {
        type = 'file-pdf';
      }

      if (['numbers', 'csv', 'xls', 'xlsx'].indexOf(format) > -1) {
        type = 'file-excel';
      }

      if (['keynote', 'ppt', 'pptx'].indexOf(format) > -1) {
        type = 'file-ppt';
      }

      return type;
    },
    parsePercentage: function parsePercentage(val) {
      return parseInt(val, 10);
    }
  }
};

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_progress = vue.resolveComponent("b-progress");

  return vue.openBlock(), vue.createBlock("ul", {
    class: [$data.prefixCls + '-list']
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.files, function (file, index) {
    return vue.openBlock(), vue.createBlock("li", {
      key: index,
      class: $options.fileCls(file),
      onClick: function onClick($event) {
        return $options.handleClick(file);
      }
    }, [vue.createVNode("span", {
      onClick: function onClick($event) {
        return $options.handlePreview(file);
      }
    }, [vue.createVNode("i", {
      class: "b-iconfont b-icon-" + $options.format(file)
    }, null, 2
    /* CLASS */
    ), vue.createTextVNode(" " + vue.toDisplayString(file.name), 1
    /* TEXT */
    )], 8
    /* PROPS */
    , ["onClick"]), vue.withDirectives(vue.createVNode("i", {
      class: ["b-iconfont b-icon-close", [$data.prefixCls + '-list-remove']],
      onClick: function onClick($event) {
        return $options.handleRemove(file);
      }
    }, null, 10
    /* CLASS, PROPS */
    , ["onClick"]), [[vue.vShow, file.status === 'finished']]), vue.createVNode(vue.Transition, {
      name: "fade"
    }, {
      default: vue.withCtx(function () {
        return [file.showProgress ? (vue.openBlock(), vue.createBlock(_component_b_progress, {
          key: 0,
          "stroke-width": 2,
          percent: $options.parsePercentage(file.percentage),
          status: file.status === 'finished' && file.showProgress ? 'success' : null
        }, null, 8
        /* PROPS */
        , ["percent", "status"])) : vue.createCommentVNode("v-if", true)];
      }),
      _: 2
      /* DYNAMIC */

    }, 1024
    /* DYNAMIC_SLOTS */
    )], 10
    /* CLASS, PROPS */
    , ["onClick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  );
}

script$i.render = render$h;
script$i.__file = "src/components/upload/upload-list.vue";

var prefixCls$2 = 'bin-upload';
var script$h = {
  name: 'BUpload',
  components: {
    BButton: script$1B,
    UploadList: script$i
  },
  props: {
    action: {
      type: String,
      required: true
    },
    headers: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    multiple: {
      type: Boolean,
      default: false
    },
    data: {
      type: Object
    },
    name: {
      type: String,
      default: 'file'
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    showUploadList: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      validator: function validator(value) {
        return ['select', 'drag'].includes(value);
      },
      default: 'select'
    },
    format: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    accept: {
      type: String
    },
    maxSize: {
      type: Number
    },
    beforeUpload: Function,
    onProgress: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onSuccess: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onError: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onRemove: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onPreview: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onExceededSize: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    onFormatError: {
      type: Function,
      default: function _default() {
        return {};
      }
    },
    defaultFileList: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    paste: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      prefixCls: prefixCls$2,
      dragOver: false,
      fileList: [],
      tempIndex: 1
    };
  },
  computed: {
    classes: function classes() {
      var _ref;

      return ["" + prefixCls$2, (_ref = {}, _ref[prefixCls$2 + "-select"] = this.type === 'select', _ref[prefixCls$2 + "-drag"] = this.type === 'drag', _ref[prefixCls$2 + "-dragOver"] = this.type === 'drag' && this.dragOver, _ref)];
    }
  },
  setup: function setup() {
    var _useForm = useForm(),
        formEmit = _useForm.formEmit;

    return {
      formEmit: formEmit
    };
  },
  methods: {
    handleClick: function handleClick() {
      if (this.disabled) return;
      this.$refs.input.click();
    },
    handleChange: function handleChange(e) {
      var files = e.target.files;

      if (!files) {
        return;
      }

      this.uploadFiles(files);
      this.$refs.input.value = null;
    },
    onDrop: function onDrop(e) {
      this.dragOver = false;
      if (this.disabled) return;
      this.uploadFiles(e.dataTransfer.files);
    },
    handlePaste: function handlePaste(e) {
      if (this.disabled) return;

      if (this.paste) {
        this.uploadFiles(e.clipboardData.files);
      }
    },
    uploadFiles: function uploadFiles(files) {
      var _this = this;

      var postFiles = Array.prototype.slice.call(files);
      if (!this.multiple) postFiles = postFiles.slice(0, 1);
      if (postFiles.length === 0) return;
      postFiles.forEach(function (file) {
        _this.upload(file);
      });
    },
    upload: function upload(file) {
      var _this2 = this;

      if (!this.beforeUpload) {
        return this.post(file);
      }

      var before = this.beforeUpload(file);

      if (before && before.then) {
        before.then(function (processedFile) {
          if (Object.prototype.toString.call(processedFile) === '[object File]') {
            _this2.post(processedFile);
          } else {
            _this2.post(file);
          }
        }, function () {// this.$emit('cancel', file);
        });
      } else if (before !== false) {
        this.post(file);
      } else ;
    },
    post: function post(file) {
      var _this3 = this;

      // check format
      if (this.format.length) {
        var fileFormat = file.name.split('.').pop().toLocaleLowerCase();
        var checked = this.format.some(function (item) {
          return item.toLocaleLowerCase() === fileFormat;
        });

        if (!checked) {
          this.onFormatError(file, this.fileList);
          return false;
        }
      } // check maxSize


      if (this.maxSize) {
        if (file.size > this.maxSize * 1024) {
          this.onExceededSize(file, this.fileList);
          return false;
        }
      }

      this.handleStart(file);
      var formData = new FormData();
      formData.append(this.name, file);
      upload({
        headers: this.headers,
        withCredentials: this.withCredentials,
        file: file,
        data: this.data,
        filename: this.name,
        action: this.action,
        onProgress: function onProgress(e) {
          _this3.handleProgress(e, file);
        },
        onSuccess: function onSuccess(res) {
          _this3.handleSuccess(res, file);
        },
        onError: function onError(err, response) {
          _this3.handleError(err, response, file);
        }
      });
    },
    handleStart: function handleStart(file) {
      file.uid = Date.now() + this.tempIndex++;
      var _file = {
        status: 'uploading',
        name: file.name,
        size: file.size,
        percentage: 0,
        uid: file.uid,
        showProgress: true
      };
      this.fileList.push(_file);
    },
    getFile: function getFile(file) {
      var fileList = this.fileList;
      var target;
      fileList.every(function (item) {
        target = file.uid === item.uid ? item : null;
        return !target;
      });
      return target;
    },
    handleProgress: function handleProgress(e, file) {
      var _file = this.getFile(file);

      this.onProgress(e, _file, this.fileList);
      _file.percentage = e.percent || 0;
    },
    handleSuccess: function handleSuccess(res, file) {
      var _file = this.getFile(file);

      if (_file) {
        _file.status = 'finished';
        _file.response = res;
        this.onSuccess(res, _file, this.fileList);
        this.formEmit('change', _file);
        setTimeout(function () {
          _file.showProgress = false;
        }, 1000);
      }
    },
    handleError: function handleError(err, response, file) {
      var _file = this.getFile(file);

      var fileList = this.fileList;
      _file.status = 'fail';
      fileList.splice(fileList.indexOf(_file), 1);
      this.onError(err, response, file);
    },
    handleRemove: function handleRemove(file) {
      var fileList = this.fileList;
      fileList.splice(fileList.indexOf(file), 1);
      this.onRemove(file, fileList);
    },
    handlePreview: function handlePreview(file) {
      if (file.status === 'finished') {
        this.onPreview(file);
      }
    },
    clearFiles: function clearFiles() {
      this.fileList = [];
    }
  },
  watch: {
    defaultFileList: {
      immediate: true,
      handler: function handler(fileList) {
        var _this4 = this;

        this.fileList = fileList.map(function (item) {
          item.status = 'finished';
          item.percentage = 100;
          item.uid = Date.now() + _this4.tempIndex++;
          return item;
        });
      }
    }
  }
};

var _hoisted_1$9 = /*#__PURE__*/vue.createTextVNode("点击上传");

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_button = vue.resolveComponent("b-button");

  var _component_upload_list = vue.resolveComponent("upload-list");

  return vue.openBlock(), vue.createBlock("div", {
    class: [$data.prefixCls]
  }, [vue.createVNode("div", {
    class: $options.classes,
    onClick: _cache[2] || (_cache[2] = function () {
      return $options.handleClick && $options.handleClick.apply($options, arguments);
    }),
    onDrop: _cache[3] || (_cache[3] = vue.withModifiers(function () {
      return $options.onDrop && $options.onDrop.apply($options, arguments);
    }, ["prevent"])),
    onPaste: _cache[4] || (_cache[4] = function () {
      return $options.handlePaste && $options.handlePaste.apply($options, arguments);
    }),
    onDragover: _cache[5] || (_cache[5] = vue.withModifiers(function ($event) {
      return $data.dragOver = true;
    }, ["prevent"])),
    onDragleave: _cache[6] || (_cache[6] = vue.withModifiers(function ($event) {
      return $data.dragOver = false;
    }, ["prevent"]))
  }, [vue.createVNode("input", {
    ref: "input",
    type: "file",
    class: [$data.prefixCls + '-input'],
    onChange: _cache[1] || (_cache[1] = function () {
      return $options.handleChange && $options.handleChange.apply($options, arguments);
    }),
    multiple: $props.multiple,
    accept: $props.accept
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , ["multiple", "accept"]), vue.renderSlot(_ctx.$slots, "default", {}, function () {
    return [vue.createVNode(_component_b_button, {
      icon: "cloud-upload"
    }, {
      default: vue.withCtx(function () {
        return [_hoisted_1$9];
      }),
      _: 1
      /* STABLE */

    })];
  })], 34
  /* CLASS, HYDRATE_EVENTS */
  ), vue.createCommentVNode("tip，说明插槽"), vue.renderSlot(_ctx.$slots, "tip"), $props.showUploadList ? (vue.openBlock(), vue.createBlock(_component_upload_list, {
    key: 0,
    files: $data.fileList,
    onFileRemove: $options.handleRemove,
    onFilePreview: $options.handlePreview
  }, null, 8
  /* PROPS */
  , ["files", "onFileRemove", "onFilePreview"])) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$h.render = render$g;
script$h.__file = "src/components/upload/upload.vue";

/* istanbul ignore next */

script$h.install = function (Vue) {
  Vue.component(script$h.name, script$h);
};

var useTooltip = function useTooltip(props, formatTooltip, showTooltip) {
  var tooltip = vue.ref(null);
  var tooltipVisible = vue.ref(false);
  var enableFormat = vue.computed(function () {
    return formatTooltip.value instanceof Function;
  });
  var formatValue = vue.computed(function () {
    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
  });

  var displayTooltip = function displayTooltip() {
    return showTooltip.value && (tooltipVisible.value = true);
  };

  var hideTooltip = function hideTooltip() {
    return showTooltip.value && (tooltipVisible.value = false);
  };

  return {
    tooltip: tooltip,
    tooltipVisible: tooltipVisible,
    formatValue: formatValue,
    displayTooltip: displayTooltip,
    hideTooltip: hideTooltip
  };
};

var useSliderButton = function useSliderButton(props, initData, emit) {
  var _inject = vue.inject('SliderProvider'),
      disabled = _inject.disabled,
      min = _inject.min,
      max = _inject.max,
      step = _inject.step,
      showTooltip = _inject.showTooltip,
      precision = _inject.precision,
      sliderSize = _inject.sliderSize,
      formatTooltip = _inject.formatTooltip,
      emitChange = _inject.emitChange,
      resetSize = _inject.resetSize,
      updateDragging = _inject.updateDragging;

  var _useTooltip = useTooltip(props, formatTooltip, showTooltip),
      tooltip = _useTooltip.tooltip,
      tooltipVisible = _useTooltip.tooltipVisible,
      formatValue = _useTooltip.formatValue,
      displayTooltip = _useTooltip.displayTooltip,
      hideTooltip = _useTooltip.hideTooltip;

  var currentPosition = vue.computed(function () {
    return (props.modelValue - min.value) / (max.value - min.value) * 100 + "%";
  });
  var wrapperStyle = vue.computed(function () {
    return props.vertical ? {
      bottom: currentPosition.value
    } : {
      left: currentPosition.value
    };
  });

  var handleMouseEnter = function handleMouseEnter() {
    initData.hovering = true;
    displayTooltip();
  };

  var handleMouseLeave = function handleMouseLeave() {
    initData.hovering = false;
    hideTooltip();
  };

  var onButtonDown = function onButtonDown(event) {
    if (disabled.value) return;
    event.preventDefault();
    onDragStart(event);
    on$1(window, 'mousemove', onDragging);
    on$1(window, 'touchmove', onDragging);
    on$1(window, 'mouseup', onDragEnd);
    on$1(window, 'touchend', onDragEnd);
    on$1(window, 'contextmenu', onDragEnd);
  };

  var onLeftKeyDown = function onLeftKeyDown() {
    if (disabled.value) return;
    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max.value - min.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };

  var onRightKeyDown = function onRightKeyDown() {
    if (disabled.value) return;
    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max.value - min.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };

  var getClientXY = function getClientXY(event) {
    var clientX;
    var clientY;

    if (event.type.startsWith('touch')) {
      clientY = event.touches[0].clientY;
      clientX = event.touches[0].clientX;
    } else {
      clientY = event.clientY;
      clientX = event.clientX;
    }

    return {
      clientX: clientX,
      clientY: clientY
    };
  };

  var onDragStart = function onDragStart(event) {
    initData.dragging = true;
    initData.isClick = true;

    var _getClientXY = getClientXY(event),
        clientX = _getClientXY.clientX,
        clientY = _getClientXY.clientY;

    if (props.vertical) {
      initData.startY = clientY;
    } else {
      initData.startX = clientX;
    }

    initData.startPosition = parseFloat(currentPosition.value);
    initData.newPosition = initData.startPosition;
  };

  var onDragging = function onDragging(event) {
    if (initData.dragging) {
      initData.isClick = false;
      displayTooltip();
      resetSize();
      var diff;

      var _getClientXY2 = getClientXY(event),
          clientX = _getClientXY2.clientX,
          clientY = _getClientXY2.clientY;

      if (props.vertical) {
        initData.currentY = clientY;
        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
      } else {
        initData.currentX = clientX;
        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
      }

      initData.newPosition = initData.startPosition + diff;
      setPosition(initData.newPosition);
    }
  };

  var onDragEnd = function onDragEnd() {
    if (initData.dragging) {
      /*
         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
         */
      setTimeout(function () {
        initData.dragging = false;
        hideTooltip();

        if (!initData.isClick) {
          setPosition(initData.newPosition);
          emitChange();
        }
      }, 0);
      off$1(window, 'mousemove', onDragging);
      off$1(window, 'touchmove', onDragging);
      off$1(window, 'mouseup', onDragEnd);
      off$1(window, 'touchend', onDragEnd);
      off$1(window, 'contextmenu', onDragEnd);
    }
  };

  var setPosition = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(newPosition) {
      var lengthPerStep, steps, value;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(newPosition === null || isNaN(newPosition))) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              if (newPosition < 0) {
                newPosition = 0;
              } else if (newPosition > 100) {
                newPosition = 100;
              }

              lengthPerStep = 100 / ((max.value - min.value) / step.value);
              steps = Math.round(newPosition / lengthPerStep);
              value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
              value = parseFloat(value.toFixed(precision.value));
              emit(UPDATE_MODEL_EVENT, value);

              if (!initData.dragging && props.modelValue !== initData.oldValue) {
                initData.oldValue = props.modelValue;
              }

              _context.next = 11;
              return vue.nextTick();

            case 11:
              initData.dragging && displayTooltip();
              tooltip.value.updatePopper();

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function setPosition(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  vue.watch(function () {
    return initData.dragging;
  }, function (val) {
    updateDragging(val);
  });
  return {
    tooltip: tooltip,
    tooltipVisible: tooltipVisible,
    showTooltip: showTooltip,
    wrapperStyle: wrapperStyle,
    formatValue: formatValue,
    handleMouseEnter: handleMouseEnter,
    handleMouseLeave: handleMouseLeave,
    onButtonDown: onButtonDown,
    onLeftKeyDown: onLeftKeyDown,
    onRightKeyDown: onRightKeyDown,
    setPosition: setPosition
  };
};

var script$g = {
  name: 'BSliderButton',
  components: {
    BTooltip: Tooltip
  },
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    tooltipClass: {
      type: String,
      default: ''
    }
  },
  emits: [UPDATE_MODEL_EVENT],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var initData = vue.reactive({
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: props.modelValue
    });

    var _useSliderButton = useSliderButton(props, initData, emit),
        tooltip = _useSliderButton.tooltip,
        showTooltip = _useSliderButton.showTooltip,
        tooltipVisible = _useSliderButton.tooltipVisible,
        wrapperStyle = _useSliderButton.wrapperStyle,
        formatValue = _useSliderButton.formatValue,
        handleMouseEnter = _useSliderButton.handleMouseEnter,
        handleMouseLeave = _useSliderButton.handleMouseLeave,
        onButtonDown = _useSliderButton.onButtonDown,
        onLeftKeyDown = _useSliderButton.onLeftKeyDown,
        onRightKeyDown = _useSliderButton.onRightKeyDown,
        setPosition = _useSliderButton.setPosition;

    var _toRefs = vue.toRefs(initData),
        hovering = _toRefs.hovering,
        dragging = _toRefs.dragging;

    return {
      tooltip: tooltip,
      tooltipVisible: tooltipVisible,
      showTooltip: showTooltip,
      wrapperStyle: wrapperStyle,
      formatValue: formatValue,
      handleMouseEnter: handleMouseEnter,
      handleMouseLeave: handleMouseLeave,
      onButtonDown: onButtonDown,
      onLeftKeyDown: onLeftKeyDown,
      onRightKeyDown: onRightKeyDown,
      setPosition: setPosition,
      hovering: hovering,
      dragging: dragging
    };
  }
};

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_tooltip = vue.resolveComponent("b-tooltip");

  return vue.openBlock(), vue.createBlock("div", {
    ref: "button",
    class: ["bin-slider__button-wrapper", {
      hover: $setup.hovering,
      dragging: $setup.dragging
    }],
    style: $setup.wrapperStyle,
    tabindex: "0",
    onMouseenter: _cache[2] || (_cache[2] = function () {
      return $setup.handleMouseEnter && $setup.handleMouseEnter.apply($setup, arguments);
    }),
    onMouseleave: _cache[3] || (_cache[3] = function () {
      return $setup.handleMouseLeave && $setup.handleMouseLeave.apply($setup, arguments);
    }),
    onMousedown: _cache[4] || (_cache[4] = function () {
      return $setup.onButtonDown && $setup.onButtonDown.apply($setup, arguments);
    }),
    onTouchstart: _cache[5] || (_cache[5] = function () {
      return $setup.onButtonDown && $setup.onButtonDown.apply($setup, arguments);
    }),
    onFocus: _cache[6] || (_cache[6] = function () {
      return $setup.handleMouseEnter && $setup.handleMouseEnter.apply($setup, arguments);
    }),
    onBlur: _cache[7] || (_cache[7] = function () {
      return $setup.handleMouseLeave && $setup.handleMouseLeave.apply($setup, arguments);
    }),
    onKeydown: [_cache[8] || (_cache[8] = vue.withKeys(function () {
      return $setup.onLeftKeyDown && $setup.onLeftKeyDown.apply($setup, arguments);
    }, ["left"])), _cache[9] || (_cache[9] = vue.withKeys(function () {
      return $setup.onRightKeyDown && $setup.onRightKeyDown.apply($setup, arguments);
    }, ["right"])), _cache[10] || (_cache[10] = vue.withKeys(vue.withModifiers(function () {
      return $setup.onLeftKeyDown && $setup.onLeftKeyDown.apply($setup, arguments);
    }, ["prevent"]), ["down"])), _cache[11] || (_cache[11] = vue.withKeys(vue.withModifiers(function () {
      return $setup.onRightKeyDown && $setup.onRightKeyDown.apply($setup, arguments);
    }, ["prevent"]), ["up"]))]
  }, [vue.createVNode(_component_b_tooltip, {
    ref: "tooltip",
    modelValue: $setup.tooltipVisible,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $setup.tooltipVisible = $event;
    }),
    placement: "top",
    "stop-popper-mouse-event": false,
    "popper-class": $props.tooltipClass,
    disabled: !$setup.showTooltip,
    manual: ""
  }, {
    content: vue.withCtx(function () {
      return [vue.createVNode("span", null, vue.toDisplayString($setup.formatValue), 1
      /* TEXT */
      )];
    }),
    default: vue.withCtx(function () {
      return [vue.createVNode("div", {
        class: ["bin-slider__button", {
          hover: $setup.hovering,
          dragging: $setup.dragging
        }]
      }, null, 2
      /* CLASS */
      )];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["modelValue", "popper-class", "disabled"])], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  );
}

script$g.render = render$f;
script$g.__file = "src/components/slider/src/button.vue";

var script$f = {
  name: 'BMarker',
  props: {
    mark: {
      type: [String, Object],
      default: function _default() {
        return undefined;
      }
    }
  },
  setup: function setup(props) {
    var label = vue.computed(function () {
      return typeof props.mark === 'string' ? props.mark : props.mark.label;
    });
    return {
      label: label
    };
  },
  render: function render() {
    var _this$mark;

    return vue.h('div', {
      class: 'bin-slider__marks-text',
      style: (_this$mark = this.mark) == null ? void 0 : _this$mark.style
    }, this.label);
  }
};

script$f.__file = "src/components/slider/src/marker.vue";

var useMarks = function useMarks(props) {
  return vue.computed(function () {
    if (!props.marks) {
      return [];
    }

    var marksKeys = Object.keys(props.marks);
    return marksKeys.map(parseFloat).sort(function (a, b) {
      return a - b;
    }).filter(function (point) {
      return point <= props.max && point >= props.min;
    }).map(function (point) {
      return {
        point: point,
        position: (point - props.min) * 100 / (props.max - props.min),
        mark: props.marks[point]
      };
    });
  });
};

var useSlide = function useSlide(props, initData, emit) {
  var _useForm = useForm(),
      BForm = _useForm.BForm,
      formEmit = _useForm.formEmit;

  var slider = vue.ref(null);
  var firstButton = vue.ref(null);
  var secondButton = vue.ref(null);
  var buttonRefs = {
    firstButton: firstButton,
    secondButton: secondButton
  };
  var sliderDisabled = vue.computed(function () {
    return props.disabled || BForm.disabled || false;
  });
  var minValue = vue.computed(function () {
    return Math.min(initData.firstValue, initData.secondValue);
  });
  var maxValue = vue.computed(function () {
    return Math.max(initData.firstValue, initData.secondValue);
  });
  var barSize = vue.computed(function () {
    return props.range ? 100 * (maxValue.value - minValue.value) / (props.max - props.min) + "%" : 100 * (initData.firstValue - props.min) / (props.max - props.min) + "%";
  });
  var barStart = vue.computed(function () {
    return props.range ? 100 * (minValue.value - props.min) / (props.max - props.min) + "%" : '0%';
  });
  var runwayStyle = vue.computed(function () {
    return props.vertical ? {
      height: props.height
    } : {};
  });
  var barStyle = vue.computed(function () {
    return props.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    };
  });

  var resetSize = function resetSize() {
    if (slider.value) {
      initData.sliderSize = slider.value["client" + (props.vertical ? 'Height' : 'Width')];
    }
  };

  var setPosition = function setPosition(percent) {
    var targetValue = props.min + percent * (props.max - props.min) / 100;

    if (!props.range) {
      firstButton.value.setPosition(percent);
      return;
    }

    var buttonRefName;

    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
      buttonRefName = initData.firstValue < initData.secondValue ? 'firstButton' : 'secondButton';
    } else {
      buttonRefName = initData.firstValue > initData.secondValue ? 'firstButton' : 'secondButton';
    }

    buttonRefs[buttonRefName].value.setPosition(percent);
  };

  var emitChange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return vue.nextTick();

            case 2:
              emit(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function emitChange() {
      return _ref.apply(this, arguments);
    };
  }();

  var onSliderClick = function onSliderClick(event) {
    if (sliderDisabled.value || initData.dragging) return;
    resetSize();

    if (props.vertical) {
      var sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
      setPosition((sliderOffsetBottom - event.clientY) / initData.sliderSize * 100);
    } else {
      var sliderOffsetLeft = slider.value.getBoundingClientRect().left;
      setPosition((event.clientX - sliderOffsetLeft) / initData.sliderSize * 100);
    }

    emitChange();
  };

  return {
    formEmit: formEmit,
    slider: slider,
    firstButton: firstButton,
    secondButton: secondButton,
    sliderDisabled: sliderDisabled,
    minValue: minValue,
    maxValue: maxValue,
    runwayStyle: runwayStyle,
    barStyle: barStyle,
    resetSize: resetSize,
    setPosition: setPosition,
    emitChange: emitChange,
    onSliderClick: onSliderClick
  };
};

var useStops = function useStops(props, initData, minValue, maxValue) {
  var stops = vue.computed(function () {
    if (!props.showStops || props.min > props.max) return [];

    if (props.step === 0) {
      process.env.NODE_ENV !== 'production' && console.warn('[Element Warn][Slider]step should not be 0.');
      return [];
    }

    var stopCount = (props.max - props.min) / props.step;
    var stepWidth = 100 * props.step / (props.max - props.min);
    var result = Array.from({
      length: stopCount - 1
    }).map(function (_, index) {
      return (index + 1) * stepWidth;
    });

    if (props.range) {
      return result.filter(function (step) {
        return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
      });
    } else {
      return result.filter(function (step) {
        return step > 100 * (initData.firstValue - props.min) / (props.max - props.min);
      });
    }
  });

  var getStopStyle = function getStopStyle(position) {
    return props.vertical ? {
      'bottom': position + '%'
    } : {
      'left': position + '%'
    };
  };

  return {
    stops: stops,
    getStopStyle: getStopStyle
  };
};

var script$e = {
  name: 'BSlider',
  components: {
    BInputNumber: script$U,
    SliderButton: script$g,
    SliderMarker: script$f
  },
  props: {
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    inputSize: {
      type: String,
      default: 'small'
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: {
      type: Function,
      default: undefined
    },
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: ''
    },
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String,
      default: undefined
    },
    tooltipClass: {
      type: String,
      default: undefined
    },
    marks: Object
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var initData = vue.reactive({
      firstValue: null,
      secondValue: null,
      oldValue: null,
      dragging: false,
      sliderSize: 1
    });

    var _useSlide = useSlide(props, initData, emit),
        formEmit = _useSlide.formEmit,
        slider = _useSlide.slider,
        firstButton = _useSlide.firstButton,
        secondButton = _useSlide.secondButton,
        sliderDisabled = _useSlide.sliderDisabled,
        minValue = _useSlide.minValue,
        maxValue = _useSlide.maxValue,
        runwayStyle = _useSlide.runwayStyle,
        barStyle = _useSlide.barStyle,
        resetSize = _useSlide.resetSize,
        emitChange = _useSlide.emitChange,
        onSliderClick = _useSlide.onSliderClick;

    var _useStops = useStops(props, initData, minValue, maxValue),
        stops = _useStops.stops,
        getStopStyle = _useStops.getStopStyle;

    var markList = useMarks(props);
    useWatch(props, initData, minValue, maxValue, emit, formEmit);
    var precision = vue.computed(function () {
      var precisions = [props.min, props.max, props.step].map(function (item) {
        var decimal = ('' + item).split('.')[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    });

    var _useLifecycle = useLifecycle(props, initData, resetSize),
        sliderWrapper = _useLifecycle.sliderWrapper;

    var _toRefs = vue.toRefs(initData),
        firstValue = _toRefs.firstValue,
        secondValue = _toRefs.secondValue,
        oldValue = _toRefs.oldValue,
        dragging = _toRefs.dragging,
        sliderSize = _toRefs.sliderSize;

    var updateDragging = function updateDragging(val) {
      initData.dragging = val;
    };

    vue.provide('SliderProvider', _extends$2({}, vue.toRefs(props), {
      sliderSize: sliderSize,
      disabled: sliderDisabled,
      precision: precision,
      emitChange: emitChange,
      resetSize: resetSize,
      updateDragging: updateDragging
    }));
    return {
      firstValue: firstValue,
      secondValue: secondValue,
      oldValue: oldValue,
      dragging: dragging,
      sliderSize: sliderSize,
      slider: slider,
      firstButton: firstButton,
      secondButton: secondButton,
      sliderDisabled: sliderDisabled,
      runwayStyle: runwayStyle,
      barStyle: barStyle,
      emitChange: emitChange,
      onSliderClick: onSliderClick,
      getStopStyle: getStopStyle,
      stops: stops,
      markList: markList,
      sliderWrapper: sliderWrapper
    };
  }
};

var useWatch = function useWatch(props, initData, minValue, maxValue, emit, formEmit) {
  var _emit = function _emit(val) {
    emit(UPDATE_MODEL_EVENT, val);
  };

  var valueChanged = function valueChanged() {
    if (props.range) {
      return ![minValue.value, maxValue.value].every(function (item, index) {
        return item === initData.oldValue[index];
      });
    } else {
      return props.modelValue !== initData.oldValue;
    }
  };

  var setValues = function setValues() {
    if (props.min > props.max) {
      log('Slider', 'min should not be greater than max.');
      return;
    }

    var val = props.modelValue;

    if (props.range && Array.isArray(val)) {
      if (val[1] < props.min) {
        _emit([props.min, props.min]);
      } else if (val[0] > props.max) {
        _emit([props.max, props.max]);
      } else if (val[0] < props.min) {
        _emit([props.min, val[1]]);
      } else if (val[1] > props.max) {
        _emit([val[0], props.max]);
      } else {
        initData.firstValue = val[0];
        initData.secondValue = val[1];

        if (valueChanged()) {
          formEmit('change', [minValue.value, maxValue.value]);
          initData.oldValue = val.slice();
        }
      }
    } else if (!props.range && typeof val === 'number' && !isNaN(val)) {
      if (val < props.min) {
        _emit(props.min);
      } else if (val > props.max) {
        _emit(props.max);
      } else {
        initData.firstValue = val;

        if (valueChanged()) {
          formEmit('change', val);
          initData.oldValue = val;
        }
      }
    }
  };

  vue.watch(function () {
    return initData.dragging;
  }, function (val) {
    if (!val) {
      setValues();
    }
  });
  vue.watch(function () {
    return initData.firstValue;
  }, function (val) {
    if (props.range) {
      _emit([minValue.value, maxValue.value]);
    } else {
      _emit(val);
    }
  });
  vue.watch(function () {
    return initData.secondValue;
  }, function () {
    if (props.range) {
      _emit([minValue.value, maxValue.value]);
    }
  });
  vue.watch(function () {
    return props.modelValue;
  }, function (val, oldVal) {
    if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every(function (item, index) {
      return item === oldVal[index];
    })) {
      return;
    }

    setValues();
  });
  vue.watch(function () {
    return [props.min, props.max];
  }, function () {
    setValues();
  });
};

var useLifecycle = function useLifecycle(props, initData, resetSize) {
  var sliderWrapper = vue.ref(null);
  vue.onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var valuetext;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (props.range) {
              if (Array.isArray(props.modelValue)) {
                initData.firstValue = Math.max(props.min, props.modelValue[0]);
                initData.secondValue = Math.min(props.max, props.modelValue[1]);
              } else {
                initData.firstValue = props.min;
                initData.secondValue = props.max;
              }

              initData.oldValue = [initData.firstValue, initData.secondValue];
              valuetext = initData.firstValue + "-" + initData.secondValue;
            } else {
              if (typeof props.modelValue !== 'number' || isNaN(props.modelValue)) {
                initData.firstValue = props.min;
              } else {
                initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
              }

              initData.oldValue = initData.firstValue;
              valuetext = initData.firstValue;
            }

            sliderWrapper.value.setAttribute('aria-valuetext', valuetext); // label screen reader

            sliderWrapper.value.setAttribute('aria-label', props.label ? props.label : "slider between " + props.min + " and " + props.max);
            on$1(window, 'resize', resetSize);
            _context.next = 6;
            return vue.nextTick();

          case 6:
            resetSize();

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  vue.onBeforeUnmount(function () {
    off$1(window, 'resize', resetSize);
  });
  return {
    sliderWrapper: sliderWrapper
  };
};

var _hoisted_1$8 = {
  key: 1
};
var _hoisted_2$4 = {
  class: "bin-slider__marks"
};
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_input_number = vue.resolveComponent("b-input-number");

  var _component_slider_button = vue.resolveComponent("slider-button");

  var _component_slider_marker = vue.resolveComponent("slider-marker");

  return vue.openBlock(), vue.createBlock("div", {
    ref: "sliderWrapper",
    class: ["bin-slider", {
      'is-vertical': $props.vertical,
      'bin-slider--with-input': $props.showInput
    }],
    role: "slider",
    "aria-valuemin": $props.min,
    "aria-valuemax": $props.max,
    "aria-orientation": $props.vertical ? 'vertical' : 'horizontal',
    "aria-disabled": $setup.sliderDisabled
  }, [$props.showInput && !$props.range ? (vue.openBlock(), vue.createBlock(_component_b_input_number, {
    key: 0,
    ref: "input",
    modelValue: $setup.firstValue,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
      return $setup.firstValue = $event;
    }),
    class: "bin-slider__input",
    step: $props.step,
    disabled: $setup.sliderDisabled,
    controls: $props.showInputControls,
    min: $props.min,
    max: $props.max,
    debounce: $props.debounce,
    size: $props.inputSize,
    onChange: $setup.emitChange
  }, null, 8
  /* PROPS */
  , ["modelValue", "step", "disabled", "controls", "min", "max", "debounce", "size", "onChange"])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    ref: "slider",
    class: ["bin-slider__runway", {
      'show-input': $props.showInput,
      'disabled': $setup.sliderDisabled
    }],
    style: $setup.runwayStyle,
    onClick: _cache[4] || (_cache[4] = function () {
      return $setup.onSliderClick && $setup.onSliderClick.apply($setup, arguments);
    })
  }, [vue.createVNode("div", {
    class: "bin-slider__bar",
    style: $setup.barStyle
  }, null, 4
  /* STYLE */
  ), vue.createVNode(_component_slider_button, {
    ref: "firstButton",
    modelValue: $setup.firstValue,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) {
      return $setup.firstValue = $event;
    }),
    vertical: $props.vertical,
    "tooltip-class": $props.tooltipClass
  }, null, 8
  /* PROPS */
  , ["modelValue", "vertical", "tooltip-class"]), $props.range ? (vue.openBlock(), vue.createBlock(_component_slider_button, {
    key: 0,
    ref: "secondButton",
    modelValue: $setup.secondValue,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = function ($event) {
      return $setup.secondValue = $event;
    }),
    vertical: $props.vertical,
    "tooltip-class": $props.tooltipClass
  }, null, 8
  /* PROPS */
  , ["modelValue", "vertical", "tooltip-class"])) : vue.createCommentVNode("v-if", true), $props.showStops ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$8, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.stops, function (item, key) {
    return vue.openBlock(), vue.createBlock("div", {
      key: key,
      class: "bin-slider__stop",
      style: $setup.getStopStyle(item)
    }, null, 4
    /* STYLE */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))])) : vue.createCommentVNode("v-if", true), $setup.markList.length > 0 ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 2
  }, [vue.createVNode("div", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.markList, function (item, key) {
    return vue.openBlock(), vue.createBlock("div", {
      key: key,
      style: $setup.getStopStyle(item.position),
      class: "bin-slider__stop bin-slider__marks-stop"
    }, null, 4
    /* STYLE */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))]), vue.createVNode("div", _hoisted_2$4, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.markList, function (item, key) {
    return vue.openBlock(), vue.createBlock(_component_slider_marker, {
      key: key,
      mark: item.mark,
      style: $setup.getStopStyle(item.position)
    }, null, 8
    /* PROPS */
    , ["mark", "style"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])], 64
  /* STABLE_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  )], 10
  /* CLASS, PROPS */
  , ["aria-valuemin", "aria-valuemax", "aria-orientation", "aria-disabled"]);
}

script$e.render = render$e;
script$e.__file = "src/components/slider/src/index.vue";

/* istanbul ignore next */

script$e.install = function (Vue) {
  Vue.component(script$e.name, script$e);
};

var script$d = {
  name: 'ImgPlaceholder'
};

var _hoisted_1$7 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};

var _hoisted_2$3 = /*#__PURE__*/vue.createVNode("path", {
  d: "M64 896V128h896v768H64z m64-128l192-192 116.352 116.352L640 448l256 307.2V192H128v576z m224-480a96 96 0 1 1-0.064 192.064A96 96 0 0 1 352 288z"
}, null, -1
/* HOISTED */
);

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("svg", _hoisted_1$7, [_hoisted_2$3]);
}

script$d.render = render$d;
script$d.__file = "src/components/skeleton-item/img-placeholder.vue";

var script$c = {
  name: 'BSkeletonItem',
  components: {
    ImgPlaceholder: script$d
  },
  props: {
    variant: {
      type: String,
      default: 'text'
    }
  }
};

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_img_placeholder = vue.resolveComponent("img-placeholder");

  return vue.openBlock(), vue.createBlock("div", {
    class: ['bin-skeleton__item', "bin-skeleton__" + $props.variant]
  }, [$props.variant === 'image' ? (vue.openBlock(), vue.createBlock(_component_img_placeholder, {
    key: 0
  })) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$c.render = render$c;
script$c.__file = "src/components/skeleton-item/item.vue";

script$c.install = function (app) {
  app.component(script$c.name, script$c);
};

function useThrottleRender (loading, throttle) {
  if (throttle === void 0) {
    throttle = 0;
  }

  if (throttle === 0) return loading;
  var throttled = vue.ref(false);
  var timeoutHandle = 0;

  var dispatchThrottling = function dispatchThrottling() {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }

    timeoutHandle = window.setTimeout(function () {
      throttled.value = loading.value;
    }, throttle);
  };

  vue.onMounted(dispatchThrottling);
  vue.watch(function () {
    return loading.value;
  }, function (val) {
    if (val) {
      dispatchThrottling();
    } else {
      throttled.value = val;
    }
  });
  return throttled;
}

var script$b = {
  name: 'BSkeleton',
  components: {
    BSkeletonItem: script$c
  },
  props: {
    animation: {
      type: Boolean,
      default: false
    },
    count: {
      type: Number,
      default: 1
    },
    rows: {
      type: Number,
      default: 3
    },
    loading: {
      type: Boolean,
      default: true
    },
    throttle: {
      type: Number
    }
  },
  setup: function setup(props) {
    var innerLoading = vue.computed(function () {
      return props.loading;
    });
    var uiLoading = useThrottleRender(innerLoading, props.throttle);
    return {
      uiLoading: uiLoading
    };
  }
};

function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_skeleton_item = vue.resolveComponent("b-skeleton-item");

  return $setup.uiLoading ? (vue.openBlock(), vue.createBlock("div", vue.mergeProps({
    key: 0,
    class: ['bin-skeleton', $props.animation ? 'is-animated' : '']
  }, _ctx.$attrs), [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.count, function (i) {
    return vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: i
    }, [$props.loading ? vue.renderSlot(_ctx.$slots, "template", {
      key: 0
    }, function () {
      return [vue.createVNode(_component_b_skeleton_item, {
        class: "is-first",
        variant: "p"
      }), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.rows, function (item) {
        return vue.openBlock(), vue.createBlock(_component_b_skeleton_item, {
          key: item,
          class: {
            'bin-skeleton__paragraph': true,
            'is-last': item === $props.rows && $props.rows > 1
          },
          variant: "p"
        }, null, 8
        /* PROPS */
        , ["class"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))];
    }) : vue.createCommentVNode("v-if", true)], 64
    /* STABLE_FRAGMENT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 16
  /* FULL_PROPS */
  )) : vue.renderSlot(_ctx.$slots, "default", vue.mergeProps({
    key: 1
  }, _ctx.$attrs));
}

script$b.render = render$b;
script$b.__file = "src/components/skeleton/skeleton.vue";

script$b.install = function (app) {
  app.component(script$b.name, script$b);
};

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/* eslint no-console:0 */
var formatRegExp = /%[sdj%]/g;
var warning = function warning() {}; // don't print warning message when in production env or node runtime

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn) {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;

  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }

  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve();
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields || [];

  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }

  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve();
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve();
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}
function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends$1({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}

/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
}

/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
}

/* eslint max-len:0 */

var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};
/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
}

/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

var ENUM = 'enum';
/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}

/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function pattern$1(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

var rules = {
  required: required,
  whitespace: whitespace,
  type: type,
  range: range,
  "enum": enumerable,
  pattern: pattern$1
};

/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
}

/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if ((value === undefined || value === null) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (value !== undefined && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

var ENUM$1 = 'enum';
/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable$1(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM$1](rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function pattern$2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
}

function required$1(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
}

function type$1(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Performs validation for any type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
}

var validators = {
  string: string,
  method: method,
  number: number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable$1,
  pattern: pattern$2,
  date: date,
  url: type$1,
  hex: type$1,
  email: type$1,
  required: required$1,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();

/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

function Schema(descriptor) {
  this.rules = null;
  this._messages = messages;
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    var z;
    var item;

    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_, o, oc) {
    var _this = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }

      return Promise.resolve();
    }

    function complete(results) {
      var i;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        fields = convertFieldsError(errors);
      }

      callback(errors, fields);
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var arr;
    var value;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends$1({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends$1({}, rule);
        }

        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);

        if (!rule.validator) {
          return;
        }

        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullfield(key, schema) {
        return _extends$1({}, schema, {
          fullField: rule.fullField + "." + key
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errors = e;

        if (!Array.isArray(errors)) {
          errors = [errors];
        }

        if (!options.suppressWarning && errors.length) {
          Schema.warning('async-validator:', errors);
        }

        if (errors.length && rule.message !== undefined) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(complementError(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }

        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message !== undefined) {
              errors = [].concat(rule.message).map(complementError(rule));
            } else if (options.error) {
              errors = [options.error(rule, format(options.messages.required, rule.field))];
            }

            return doIt(errors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }

          fieldsSchema = _extends$1({}, fieldsSchema, data.rule.fields);

          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }

          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (errors && errors.length) {
              finalErrors.push.apply(finalErrors, errors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(rule.message || rule.field + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

var LabelWrap = {
  name: 'BLabelWrap',
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots;
    var el = vue.ref(null);
    var elForm = vue.inject(FormKey);
    var elFormItem = vue.inject(FormItemKey);
    var computedWidth = vue.ref(0);
    vue.watch(computedWidth, function (val, oldVal) {
      if (props.updateAll) {
        elForm.registerLabelWidth(val, oldVal);
        elFormItem.updateComputedLabelWidth(val);
      }
    });

    var getLabelWidth = function getLabelWidth() {
      var _el$value;

      if ((_el$value = el.value) != null && _el$value.firstElementChild) {
        var width = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(parseFloat(width));
      } else {
        return 0;
      }
    };

    var updateLabelWidth = function updateLabelWidth(action) {
      if (action === void 0) {
        action = 'update';
      }

      vue.nextTick(function () {
        if (slots.default && props.isAutoWidth) {
          if (action === 'update') {
            computedWidth.value = getLabelWidth();
          } else if (action === 'remove') {
            elForm.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };

    var updateLabelWidthFn = function updateLabelWidthFn() {
      return updateLabelWidth('update');
    };

    vue.onMounted(function () {
      addResizeListener(el.value.firstElementChild, updateLabelWidthFn);
      updateLabelWidthFn();
    });
    vue.onUpdated(updateLabelWidthFn);
    vue.onBeforeUnmount(function () {
      updateLabelWidth('remove');
      removeResizeListener(el.value.firstElementChild, updateLabelWidthFn);
    });

    function render() {
      if (!slots) return null;

      if (props.isAutoWidth) {
        var autoLabelWidth = elForm.autoLabelWidth;
        var style = {};

        if (autoLabelWidth && autoLabelWidth !== 'auto') {
          var marginLeft = parseInt(autoLabelWidth, 10) - computedWidth.value;

          if (marginLeft) {
            style.marginLeft = marginLeft + 'px';
          }
        }

        return vue.h('div', {
          ref: el,
          class: ['bin-form-item__label-wrap'],
          style: style
        }, slots.default == null ? void 0 : slots.default());
      } else {
        return vue.h(vue.Fragment, {
          ref: el
        }, slots.default == null ? void 0 : slots.default());
      }
    }

    return render;
  }
};

var script$a = {
  name: 'BFormItem',
  componentName: 'BFormItem',
  components: {
    LabelWrap: LabelWrap
  },
  props: {
    label: String,
    labelWidth: String,
    prop: String,
    required: {
      type: Boolean,
      default: undefined
    },
    rules: [Object, Array],
    error: String,
    validateStatus: String,
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ''
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    size: {
      types: String,
      validator: validSize
    }
  },
  setup: function setup(props) {
    var formItemMitt = mitt();
    var elForm = vue.inject(FormKey, {});
    var validateState = vue.ref('');
    var validateMessage = vue.ref('');
    var validateDisabled = vue.ref(false);
    var computedLabelWidth = vue.ref('');
    var vm = vue.getCurrentInstance();
    var isNested = vue.computed(function () {
      var parent = vm.parent;

      while (parent && parent.type.name !== 'BForm') {
        if (parent.type.name === 'BFormItem') {
          return true;
        }

        parent = parent.parent;
      }

      return false;
    });
    var initialValue = undefined;
    vue.watch(function () {
      return props.error;
    }, function (val) {
      validateMessage.value = val;
      validateState.value = val ? 'error' : '';
    }, {
      immediate: true
    });
    vue.watch(function () {
      return props.validateStatus;
    }, function (val) {
      validateState.value = val;
    });
    var labelFor = vue.computed(function () {
      return props.for || props.prop;
    });
    var labelStyle = vue.computed(function () {
      if (elForm.labelPosition === 'top') return {};
      var labelWidth = props.labelWidth || elForm.labelWidth;

      if (labelWidth) {
        return {
          width: labelWidth
        };
      }

      return {};
    });
    var contentStyle = vue.computed(function () {
      if (elForm.labelPosition === 'top' || elForm.inline) {
        return {};
      }

      if (!props.label && !props.labelWidth && isNested.value) {
        return {};
      }

      var labelWidth = props.labelWidth || elForm.labelWidth;
      var ret = {};

      if (labelWidth === 'auto') {
        if (props.labelWidth === 'auto') {
          ret.marginLeft = computedLabelWidth.value;
        } else if (elForm.labelWidth === 'auto') {
          ret.marginLeft = elForm.autoLabelWidth;
        }
      } else {
        ret.marginLeft = labelWidth;
      }

      return ret;
    });
    var fieldValue = vue.computed(function () {
      var model = elForm.model;

      if (!model || !props.prop) {
        return;
      }

      var path = props.prop;

      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }

      return getPropByPath(model, path, true).v;
    });
    var isRequired = vue.computed(function () {
      var rules = getRules();
      var required = false;

      if (rules && rules.length) {
        rules.every(function (rule) {
          if (rule.required) {
            required = true;
            return false;
          }

          return true;
        });
      }

      return required;
    });
    var elFormItemSize = vue.computed(function () {
      return props.size || elForm.size;
    });
    var sizeClass = vue.computed(function () {
      return elFormItemSize.value;
    });

    var validate = function validate(trigger, callback) {
      if (callback === void 0) {
        callback = NOOP;
      }

      validateDisabled.value = false;
      var rules = getFilteredRule(trigger);

      if ((!rules || rules.length === 0) && props.required === undefined) {
        callback();
        return;
      }

      validateState.value = 'validating';
      var descriptor = {};

      if (rules && rules.length > 0) {
        rules.forEach(function (rule) {
          delete rule.trigger;
        });
      }

      descriptor[props.prop] = rules;
      var validator = new Schema(descriptor);
      var model = {};
      model[props.prop] = fieldValue.value;
      validator.validate(model, {
        firstFields: true
      }, function (errors, invalidFields) {
        validateState.value = !errors ? 'success' : 'error';
        validateMessage.value = errors ? errors[0].message : '';
        callback(validateMessage.value, invalidFields);
        elForm.emit == null ? void 0 : elForm.emit('validate', props.prop, !errors, validateMessage.value || null);
      });
    };

    var clearValidate = function clearValidate() {
      validateState.value = '';
      validateMessage.value = '';
      validateDisabled.value = false;
    };

    var resetField = function resetField() {
      validateState.value = '';
      validateMessage.value = '';
      var model = elForm.model;
      var value = fieldValue.value;
      var path = props.prop;

      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }

      var prop = getPropByPath(model, path, true);
      validateDisabled.value = true;

      if (Array.isArray(value)) {
        prop.o[prop.k] = [].concat(initialValue);
      } else {
        prop.o[prop.k] = initialValue;
      } // reset validateDisabled after onFieldChange triggered


      vue.nextTick(function () {
        validateDisabled.value = false;
      });
    };

    var getRules = function getRules() {
      var formRules = elForm.rules;
      var selfRules = props.rules;
      var requiredRule = props.required !== undefined ? {
        required: !!props.required
      } : [];
      var prop = getPropByPath(formRules, props.prop || '', false);
      var normalizedRule = formRules ? prop.o[props.prop || ''] || prop.v : [];
      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);
    };

    var getFilteredRule = function getFilteredRule(trigger) {
      var rules = getRules();
      return rules.filter(function (rule) {
        if (!rule.trigger || trigger === '') return true;

        if (Array.isArray(rule.trigger)) {
          return rule.trigger.indexOf(trigger) > -1;
        } else {
          return rule.trigger === trigger;
        }
      }).map(function (rule) {
        return _extends$2({}, rule);
      });
    };

    var onFieldBlur = function onFieldBlur() {
      validate('blur');
    };

    var onFieldChange = function onFieldChange() {
      if (validateDisabled.value) {
        validateDisabled.value = false;
        return;
      }

      validate('change');
    };

    var updateComputedLabelWidth = function updateComputedLabelWidth(width) {
      computedLabelWidth.value = width ? width + "px" : '';
    };

    var addValidateEvents = function addValidateEvents() {
      var rules = getRules();

      if (rules.length || props.required !== undefined) {
        formItemMitt.on(FormEvents.blur, onFieldBlur);
        formItemMitt.on(FormEvents.change, onFieldChange);
      }
    };

    var removeValidateEvents = function removeValidateEvents() {
      formItemMitt.off(FormEvents.blur, onFieldBlur);
      formItemMitt.off(FormEvents.change, onFieldChange);
    };

    var elFormItem = vue.reactive(_extends$2({}, vue.toRefs(props), {
      size: sizeClass,
      validateState: validateState,
      removeValidateEvents: removeValidateEvents,
      addValidateEvents: addValidateEvents,
      resetField: resetField,
      clearValidate: clearValidate,
      validate: validate,
      formItemMitt: formItemMitt,
      updateComputedLabelWidth: updateComputedLabelWidth
    }));
    vue.onMounted(function () {
      if (props.prop) {
        var _elForm$formMitt;

        (_elForm$formMitt = elForm.formMitt) == null ? void 0 : _elForm$formMitt.emit(FormEvents.addField, elFormItem);
        var value = fieldValue.value;
        initialValue = Array.isArray(value) ? [].concat(value) : value;
        addValidateEvents();
      }
    });
    vue.onBeforeUnmount(function () {
      var _elForm$formMitt2;

      (_elForm$formMitt2 = elForm.formMitt) == null ? void 0 : _elForm$formMitt2.emit(FormEvents.removeField, elFormItem);
    });
    vue.provide(FormItemKey, elFormItem);
    var formItemClass = vue.computed(function () {
      return [{
        'bin-form-item--feedback': elForm.statusIcon,
        'is-error': validateState.value === 'error',
        'is-validating': validateState.value === 'validating',
        'is-success': validateState.value === 'success',
        'is-required': isRequired.value || props.required,
        'is-no-asterisk': elForm.hideRequiredAsterisk
      }, sizeClass.value ? 'bin-form-item--' + sizeClass.value : ''];
    });
    var shouldShowError = vue.computed(function () {
      return validateState.value === 'error' && props.showMessage && elForm.showMessage;
    });
    return {
      formItemClass: formItemClass,
      shouldShowError: shouldShowError,
      elForm: elForm,
      labelStyle: labelStyle,
      contentStyle: contentStyle,
      validateMessage: validateMessage,
      labelFor: labelFor,
      resetField: resetField,
      clearValidate: clearValidate
    };
  }
};

var _hoisted_1$6 = {
  class: "item-suffix"
};
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_LabelWrap = vue.resolveComponent("LabelWrap");

  return vue.openBlock(), vue.createBlock("div", {
    class: ["bin-form-item", $setup.formItemClass]
  }, [vue.createVNode(_component_LabelWrap, {
    "is-auto-width": $setup.labelStyle.width === 'auto',
    "update-all": $setup.elForm.labelWidth === 'auto'
  }, {
    default: vue.withCtx(function () {
      return [$props.label || _ctx.$slots.label ? (vue.openBlock(), vue.createBlock("label", {
        key: 0,
        for: $setup.labelFor,
        class: "bin-form-item__label",
        style: $setup.labelStyle
      }, [vue.renderSlot(_ctx.$slots, "label", {}, function () {
        return [vue.createTextVNode(vue.toDisplayString($props.label), 1
        /* TEXT */
        )];
      }), vue.createVNode("span", _hoisted_1$6, vue.toDisplayString($setup.elForm.labelSuffix), 1
      /* TEXT */
      )], 12
      /* STYLE, PROPS */
      , ["for"])) : vue.createCommentVNode("v-if", true)];
    }),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["is-auto-width", "update-all"]), vue.createVNode("div", {
    class: "bin-form-item__content",
    style: $setup.contentStyle
  }, [vue.renderSlot(_ctx.$slots, "default"), vue.createVNode(vue.Transition, {
    name: "zoom-in-top"
  }, {
    default: vue.withCtx(function () {
      return [$setup.shouldShowError ? vue.renderSlot(_ctx.$slots, "error", {
        key: 0,
        error: $setup.validateMessage
      }, function () {
        return [vue.createVNode("div", {
          class: ["bin-form-item__error", {
            'bin-form-item__error--inline': typeof $props.inlineMessage === 'boolean' ? $props.inlineMessage : $setup.elForm.inlineMessage || false
          }]
        }, vue.toDisplayString($setup.validateMessage), 3
        /* TEXT, CLASS */
        )];
      }) : vue.createCommentVNode("v-if", true)];
    }),
    _: 3
    /* FORWARDED */

  })], 4
  /* STYLE */
  )], 2
  /* CLASS */
  );
}

script$a.render = render$a;
script$a.__file = "src/components/form/form-item.vue";

script$a.install = function (app) {
  app.component(script$a.name, script$a);
};

var convertColumnOrder = function convertColumnOrder(columns, fixedType) {
  var list = [];
  var other = [];
  columns.forEach(function (col) {
    if (col.fixed && col.fixed === fixedType) {
      list.push(col);
    } else {
      other.push(col);
    }
  });
  return list.concat(other);
};

var getAllColumns = function getAllColumns(cols, forTableHead) {
  if (forTableHead === void 0) {
    forTableHead = false;
  }

  var columns = deepCopy(cols);
  var result = [];
  columns.forEach(function (column) {
    if (column.children) {
      if (forTableHead) result.push(column);
      result.push.apply(result, getAllColumns(column.children, forTableHead));
    } else {
      result.push(column);
    }
  });
  return result;
};

var convertToRows = function convertToRows(columns, fixedType) {
  if (fixedType === void 0) {
    fixedType = false;
  }

  var originColumns = fixedType ? fixedType === 'left' ? deepCopy(convertColumnOrder(columns, 'left')) : deepCopy(convertColumnOrder(columns, 'right')) : deepCopy(columns);
  var maxLevel = 1;

  var traverse = function traverse(column, parent) {
    if (parent) {
      column.level = parent.level + 1;

      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }

    if (column.children) {
      var colSpan = 0;
      column.children.forEach(function (subColumn) {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  originColumns.forEach(function (column) {
    column.level = 1;
    traverse(column);
  });
  var rows = [];

  for (var i = 0; i < maxLevel; i++) {
    rows.push([]);
  }

  var allColumns = getAllColumns(originColumns, true);
  allColumns.forEach(function (column) {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }

    rows[column.level - 1].push(column);
  });
  return rows;
};

var getRandomStr = function getRandomStr(len) {
  if (len === void 0) {
    len = 32;
  }

  var $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
  var maxPos = $chars.length;
  var str = '';

  for (var i = 0; i < len; i++) {
    str += $chars.charAt(Math.floor(Math.random() * maxPos));
  }

  return str;
};

/**!
 * Sortable 1.13.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version$2 = "1.13.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !!
    /*@__PURE__*/
    navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index$1(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins$1 = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins$1.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins$1.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins$1.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins$1.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins$1.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins$1.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$1(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version$2;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

var renderHeader = {
  name: 'TableRenderHeader',
  functional: true,
  props: {
    render: Function,
    column: Object,
    index: Number
  },
  render: function render(ctx) {
    var params = {
      column: ctx.props.column,
      index: ctx.props.index
    };
    return ctx.props.render(vue.h, params);
  }
};

function useMixin(props) {
  function alignCls(column, row) {
    var _ref;

    if (row === void 0) {
      row = {};
    }

    var cellClassName = '';

    if (row.cellClassName && column.key && row.cellClassName[column.key]) {
      cellClassName = row.cellClassName[column.key];
    }

    return [(_ref = {}, _ref["" + cellClassName] = cellClassName, _ref["" + column.className] = column.className, _ref[props.prefixCls + "-column-" + column.align] = column.align, _ref[props.prefixCls + "-hidden"] = props.fixed === 'left' && column.fixed !== 'left' || props.fixed === 'right' && column.fixed !== 'right' || !props.fixed && column.fixed && (column.fixed === 'left' || column.fixed === 'right'), _ref)];
  }

  function isPopperShow(column) {
    return column.filters && (!props.fixed && !column.fixed || props.fixed === 'left' && column.fixed === 'left' || props.fixed === 'right' && column.fixed === 'right');
  }

  function setCellWidth(column) {
    var width = '';

    if (column.width) {
      width = column.width;
    } else if (props.columnsWidth[column._index]) {
      width = props.columnsWidth[column._index].width;
    }

    if (width === '0') width = '';
    return width;
  }

  return {
    alignCls: alignCls,
    isPopperShow: isPopperShow,
    setCellWidth: setCellWidth
  };
}

var script$9 = {
  name: 'TableHead',
  components: {
    BCheckbox: script$S,
    renderHeader: renderHeader
  },
  props: {
    prefixCls: String,
    styleObject: Object,
    columns: Array,
    objData: Object,
    data: Array,
    // rebuildData
    columnsWidth: Object,
    fixed: {
      type: [Boolean, String],
      default: false
    },
    columnRows: Array,
    fixedColumnRows: Array
  },
  computed: {
    styles: function styles() {
      var style = Object.assign({}, this.styleObject);
      var width = parseInt(this.styleObject.width);
      style.width = width + "px";
      return style;
    }
  },
  setup: function setup(props) {
    var parentRef = vue.inject('BTable', {});

    var _useMixin = useMixin(props),
        alignCls = _useMixin.alignCls,
        setCellWidth = _useMixin.setCellWidth;

    var isSelectAll = vue.computed(function () {
      var flag = true;
      var data = props.data;
      var objData = props.objData;
      if (!data.length) flag = false;
      if (!data.find(function (item) {
        return !item._disabled;
      })) flag = false; // #1751

      for (var i = 0; i < data.length; i++) {
        if (!objData[data[i]._index]._isChecked && !objData[data[i]._index]._isDisabled) {
          flag = false;
          break;
        }
      }

      return flag;
    });
    var indeterminate = vue.computed(function () {
      var flag = false;
      var data = props.data;
      var objData = props.objData;
      if (!data.length) flag = false;
      if (!data.find(function (item) {
        return !item._disabled;
      })) flag = false; // #1751

      for (var i = 0; i < data.length; i++) {
        if (objData[data[i]._index]._isChecked && !objData[data[i]._index]._isDisabled) {
          flag = true;
          break;
        }
      }

      if (isSelectAll.value) flag = false;
      return flag;
    });
    var headRows = vue.computed(function () {
      var isGroup = props.columnRows.length > 1;

      if (isGroup) {
        return props.fixed ? props.fixedColumnRows : props.columnRows;
      } else {
        return [props.columns];
      }
    });

    function cellClasses(column) {
      var _ref;

      return [props.prefixCls + "-cell", (_ref = {}, _ref[props.prefixCls + "-hidden"] = !props.fixed && column.fixed && (column.fixed === 'left' || column.fixed === 'right'), _ref[props.prefixCls + "-cell-with-selection"] = column.type === 'selection', _ref)];
    }

    function selectAll() {
      var status = !isSelectAll.value;
      parentRef.selectAll(status);
    }

    function scrollBarCellClass() {
      var _ref2;

      var hasRightFixed = false;
      var head = headRows.value;

      for (var i in head) {
        for (var j in head[i]) {
          if (head[i][j].fixed === 'right') {
            hasRightFixed = true;
            break;
          }

          if (hasRightFixed) break;
        }
      }

      return [(_ref2 = {}, _ref2[this.prefixCls + "-hidden"] = hasRightFixed, _ref2)];
    } // 因为表头嵌套不是深拷贝，所以没有 _ 开头的方法，在 isGroup 下用此列


    function getColumn(rowIndex, index) {
      var isGroup = props.columnRows.length > 1;

      if (isGroup) {
        var id = headRows.value[rowIndex][index].__id;
        return props.columns.filter(function (item) {
          return item.__id === id;
        })[0];
      } else {
        return headRows.value[rowIndex][index];
      }
    }

    function handleSortByHead(index) {
      // 在固定列时，寻找正确的 index
      var column = props.columns.find(function (item) {
        return item._index === index;
      });

      if (column.sortable) {
        var type = column._sortType;

        if (type === 'normal') {
          handleSort(index, 'asc');
        } else if (type === 'asc') {
          handleSort(index, 'desc');
        } else {
          handleSort(index, 'normal');
        }
      }
    }

    function handleSort(index, type) {
      // 在固定列时，寻找正确的 index
      var column = props.columns.find(function (item) {
        return item._index === index;
      });
      var _index = column._index;

      if (column._sortType === type) {
        type = 'normal';
      }

      parentRef.handleSort(_index, type);
    }

    return {
      showVerticalScrollBar: parentRef.showVerticalScrollBar,
      scrollBarWidth: parentRef.scrollBarWidth,
      isSelectAll: isSelectAll,
      indeterminate: indeterminate,
      headRows: headRows,
      setCellWidth: setCellWidth,
      alignCls: alignCls,
      scrollBarCellClass: scrollBarCellClass,
      cellClasses: cellClasses,
      selectAll: selectAll,
      getColumn: getColumn,
      handleSortByHead: handleSortByHead,
      handleSort: handleSort
    };
  }
};

var _hoisted_1$5 = {
  key: 0
};
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_render_header = vue.resolveComponent("render-header");

  var _component_b_checkbox = vue.resolveComponent("b-checkbox");

  return vue.openBlock(), vue.createBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    border: "0",
    style: $options.styles
  }, [vue.createVNode("colgroup", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.columns, function (column, index) {
    return vue.openBlock(), vue.createBlock("col", {
      width: $setup.setCellWidth(column),
      key: index
    }, null, 8
    /* PROPS */
    , ["width"]);
  }), 128
  /* KEYED_FRAGMENT */
  )), $setup.showVerticalScrollBar ? (vue.openBlock(), vue.createBlock("col", {
    key: 0,
    width: $setup.scrollBarWidth
  }, null, 8
  /* PROPS */
  , ["width"])) : vue.createCommentVNode("v-if", true)]), vue.createVNode("thead", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($setup.headRows, function (cols, rowIndex) {
    return vue.openBlock(), vue.createBlock("tr", {
      key: rowIndex
    }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(cols, function (column, index) {
      var _class;

      return vue.openBlock(), vue.createBlock("th", {
        key: index,
        colspan: column.colSpan,
        rowspan: column.rowSpan,
        class: $setup.alignCls(column)
      }, [vue.createVNode("div", {
        class: $setup.cellClasses(column)
      }, [column.type === 'expand' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
        key: 0
      }, [!column.renderHeader ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$5, vue.toDisplayString(column.title || ''), 1
      /* TEXT */
      )) : (vue.openBlock(), vue.createBlock(_component_render_header, {
        key: 1,
        render: column.renderHeader,
        column: column,
        index: index
      }, null, 8
      /* PROPS */
      , ["render", "column", "index"]))], 2112
      /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
      )) : column.type === 'selection' ? (vue.openBlock(), vue.createBlock(_component_b_checkbox, {
        key: 1,
        indeterminate: $setup.indeterminate,
        "model-value": $setup.isSelectAll,
        disabled: !$props.data.length,
        onChange: $setup.selectAll
      }, null, 8
      /* PROPS */
      , ["indeterminate", "model-value", "disabled", "onChange"])) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
        key: 2
      }, [!column.renderHeader ? (vue.openBlock(), vue.createBlock("span", {
        key: 0,
        class: (_class = {}, _class[$props.prefixCls + '-cell-sort'] = column.sortable, _class),
        onClick: function onClick($event) {
          return $setup.handleSortByHead($setup.getColumn(rowIndex, index)._index);
        }
      }, vue.toDisplayString(column.title || '#'), 11
      /* TEXT, CLASS, PROPS */
      , ["onClick"])) : (vue.openBlock(), vue.createBlock(_component_render_header, {
        key: 1,
        render: column.renderHeader,
        column: column,
        index: index
      }, null, 8
      /* PROPS */
      , ["render", "column", "index"])), column.sortable ? (vue.openBlock(), vue.createBlock("span", {
        key: 2,
        class: [$props.prefixCls + '-sort']
      }, [vue.createVNode("i", {
        class: ["b-iconfont b-icon-caret-up", {
          on: $setup.getColumn(rowIndex, index)._sortType === 'asc'
        }],
        onClick: function onClick($event) {
          return $setup.handleSort($setup.getColumn(rowIndex, index)._index, 'asc');
        }
      }, null, 10
      /* CLASS, PROPS */
      , ["onClick"]), vue.createVNode("i", {
        class: ["b-iconfont b-icon-caret-down", {
          on: $setup.getColumn(rowIndex, index)._sortType === 'desc'
        }],
        onClick: function onClick($event) {
          return $setup.handleSort($setup.getColumn(rowIndex, index)._index, 'desc');
        }
      }, null, 10
      /* CLASS, PROPS */
      , ["onClick"])], 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true)], 64
      /* STABLE_FRAGMENT */
      ))], 2
      /* CLASS */
      )], 10
      /* CLASS, PROPS */
      , ["colspan", "rowspan"]);
    }), 128
    /* KEYED_FRAGMENT */
    )), $setup.showVerticalScrollBar && rowIndex === 0 ? (vue.openBlock(), vue.createBlock("th", {
      key: 0,
      class: $setup.scrollBarCellClass(),
      rowspan: $setup.headRows.length
    }, null, 10
    /* CLASS, PROPS */
    , ["rowspan"])) : vue.createCommentVNode("v-if", true)]);
  }), 128
  /* KEYED_FRAGMENT */
  ))])], 4
  /* STYLE */
  );
}

script$9.render = render$9;
script$9.__file = "src/components/table/table-head.vue";

var script$8 = {
  props: {
    row: Object,
    prefixCls: String,
    draggable: Boolean
  },
  setup: function setup(props) {
    var parentRef = vue.inject('BTable', {});

    function rowClsName(_index) {
      return parentRef.props.rowClassName(parentRef.objData.value[_index], _index);
    }

    function rowClasses(_index) {
      var _ref;

      var obj = parentRef.objData.value;

      if (props.draggable) {
        return [props.prefixCls + "-row", rowClsName(_index)];
      }

      return [props.prefixCls + "-row", rowClsName(_index), (_ref = {}, _ref[props.prefixCls + "-row-highlight"] = obj[_index] && obj[_index]._isHighlight, _ref[props.prefixCls + "-row-hover"] = obj[_index] && obj[_index]._isHover, _ref)];
    }

    return {
      rowClasses: rowClasses
    };
  }
};

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("tr", {
    class: $setup.rowClasses($props.row._index)
  }, [vue.renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$8.render = render$8;
script$8.__file = "src/components/table/table-tr.vue";

var Expand = {
  name: 'TableExpand',
  functional: true,
  props: {
    row: Object,
    render: Function,
    index: Number,
    column: {
      type: Object,
      default: null
    }
  },
  render: function render(ctx) {
    var params = {
      row: ctx.row,
      index: ctx.index
    };
    if (ctx.column) params.column = ctx.column;
    return ctx.render(params);
  }
};

var TableSlot = {
  name: 'TableSlot',
  functional: true,
  props: {
    row: Object,
    index: Number,
    column: {
      type: Object,
      default: null
    }
  },
  setup: function setup(props) {
    var tableRoot = vue.inject('BTable', {});
    var render = tableRoot.slots[props.column.slot];

    if (!render) {
      throw Error('columns slot should be write <template> in table slots');
    }

    return function () {
      return vue.h('div', render({
        row: props.row,
        column: props.column,
        index: props.index
      }));
    };
  }
};

var script$7 = {
  name: 'TableCell',
  components: {
    BTooltip: Tooltip,
    BCheckbox: script$S,
    TableExpand: Expand,
    TableSlot: TableSlot
  },
  props: {
    prefixCls: String,
    row: Object,
    column: Object,
    naturalIndex: Number,
    // 重建数据索引
    index: Number,
    // _index of data
    checked: Boolean,
    disabled: Boolean,
    expanded: Boolean,
    fixed: {
      type: [Boolean, String],
      default: false
    }
  },
  computed: {
    classes: function classes() {
      var _ref;

      return [this.prefixCls + "-cell", (_ref = {}, _ref[this.prefixCls + "-hidden"] = !this.fixed && this.column.fixed && (this.column.fixed === 'left' || this.column.fixed === 'right'), _ref[this.prefixCls + "-cell-ellipsis"] = this.column.ellipsis || false, _ref[this.prefixCls + "-cell-tooltip"] = this.column.tooltip || false, _ref[this.prefixCls + "-cell-with-expand"] = this.renderType === 'expand', _ref[this.prefixCls + "-cell-with-selection"] = this.renderType === 'selection', _ref)];
    },
    expandCls: function expandCls() {
      var _ref2;

      return [this.prefixCls + "-cell-expand", (_ref2 = {}, _ref2[this.prefixCls + "-cell-expand-expanded"] = this.expanded, _ref2)];
    }
  },
  setup: function setup(props) {
    var tooltipContentRef = vue.ref(null);
    var TableRoot = vue.inject('BTable', {});
    var renderType = vue.ref(getRenderType());

    function getRenderType() {
      var column = props.column;

      if (column.type === 'index') {
        return 'index';
      } else if (column.type === 'selection') {
        return 'selection';
      } else if (column.type === 'html') {
        return 'html';
      } else if (column.type === 'expand') {
        return 'expand';
      } else if (column.render) {
        return 'render';
      } else if (column.slot) {
        return 'slot';
      } else {
        return 'normal';
      }
    }

    function toggleSelect() {
      TableRoot.toggleSelect(props.index);
    }

    function toggleExpand() {
      TableRoot.toggleExpand(props.index);
    }

    return {
      tooltipTheme: TableRoot.props.tooltipTheme,
      renderType: renderType,
      tooltipContentRef: tooltipContentRef,
      toggleSelect: toggleSelect,
      toggleExpand: toggleExpand
    };
  }
};

var _hoisted_1$4 = {
  key: 0
};
var _hoisted_2$2 = {
  key: 2
};

var _hoisted_3$1 = /*#__PURE__*/vue.createVNode("i", {
  class: "b-iconfont b-icon-right"
}, null, -1
/* HOISTED */
);

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_checkbox = vue.resolveComponent("b-checkbox");

  var _component_b_tooltip = vue.resolveComponent("b-tooltip");

  var _component_table_expand = vue.resolveComponent("table-expand");

  var _component_table_slot = vue.resolveComponent("table-slot");

  return vue.openBlock(), vue.createBlock("div", {
    class: $options.classes,
    ref: "cell"
  }, [$setup.renderType === 'index' ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$4, vue.toDisplayString($props.column.indexMethod ? $props.column.indexMethod($props.row) : $props.naturalIndex + 1), 1
  /* TEXT */
  )) : vue.createCommentVNode("v-if", true), $setup.renderType === 'selection' ? (vue.openBlock(), vue.createBlock(_component_b_checkbox, {
    key: 1,
    "model-value": $props.checked,
    onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["stop"])),
    onChange: $setup.toggleSelect,
    disabled: $props.disabled
  }, null, 8
  /* PROPS */
  , ["model-value", "onChange", "disabled"])) : vue.createCommentVNode("v-if", true), $setup.renderType === 'html' ? (vue.openBlock(), vue.createBlock("span", {
    key: 2,
    innerHTML: $props.row[$props.column.key]
  }, null, 8
  /* PROPS */
  , ["innerHTML"])) : vue.createCommentVNode("v-if", true), $setup.renderType === 'normal' ? (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 3
  }, [$props.column.tooltip && $setup.tooltipTheme ? (vue.openBlock(), vue.createBlock(_component_b_tooltip, {
    key: 0,
    class: "bin-table-cell-tooltip-content",
    "append-to-body": "",
    theme: $setup.tooltipTheme
  }, {
    content: vue.withCtx(function () {
      return [vue.createVNode("div", null, vue.toDisplayString($props.row[$props.column.key]), 1
      /* TEXT */
      )];
    }),
    default: vue.withCtx(function () {
      return [vue.createVNode("span", null, vue.toDisplayString($props.row[$props.column.key]), 1
      /* TEXT */
      )];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["theme"])) : $props.column.tooltip && !$setup.tooltipTheme ? (vue.openBlock(), vue.createBlock("span", {
    key: 1,
    class: "bin-table-cell-tooltip-content",
    title: $props.row[$props.column.key]
  }, vue.toDisplayString($props.row[$props.column.key]), 9
  /* TEXT, PROPS */
  , ["title"])) : (vue.openBlock(), vue.createBlock("span", _hoisted_2$2, vue.toDisplayString($props.row[$props.column.key]), 1
  /* TEXT */
  ))], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  )) : vue.createCommentVNode("v-if", true), $setup.renderType === 'expand' && !$props.row._disableExpand ? (vue.openBlock(), vue.createBlock("div", {
    key: 4,
    class: $options.expandCls,
    onClick: _cache[2] || (_cache[2] = function () {
      return $setup.toggleExpand && $setup.toggleExpand.apply($setup, arguments);
    })
  }, [_hoisted_3$1], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), $setup.renderType === 'render' ? (vue.openBlock(), vue.createBlock(_component_table_expand, {
    key: 5,
    row: $props.row,
    column: $props.column,
    index: $props.index,
    render: $props.column.render
  }, null, 8
  /* PROPS */
  , ["row", "column", "index", "render"])) : vue.createCommentVNode("v-if", true), $setup.renderType === 'slot' ? (vue.openBlock(), vue.createBlock(_component_table_slot, {
    key: 6,
    row: $props.row,
    column: $props.column,
    index: $props.index
  }, null, 8
  /* PROPS */
  , ["row", "column", "index"])) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$7.render = render$7;
script$7.__file = "src/components/table/cell.vue";

var script$6 = {
  name: 'TableBody',
  components: {
    TableCell: script$7,
    Expand: Expand,
    TableTr: script$8
  },
  props: {
    prefixCls: String,
    styleObject: Object,
    columns: Array,
    data: Array,
    // rebuildData
    objData: Object,
    columnsWidth: Object,
    fixed: {
      type: [Boolean, String],
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    rowKey: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props) {
    var parentRef = vue.inject('BTable', {});

    var _useMixin = useMixin(props),
        alignCls = _useMixin.alignCls,
        setCellWidth = _useMixin.setCellWidth;

    var expandRender = vue.computed(function () {
      var render = function render() {
        return '';
      };

      var _column = props.columns;

      for (var i = 0; i < _column.length; i++) {
        var column = _column[i];

        if (column.type && column.type === 'expand') {
          if (column.render) render = column.render;
        }
      }

      return render;
    });
    var isExpandModel = vue.computed(function () {
      return props.columns.some(function (v) {
        return v.type === 'expand';
      });
    });

    function getSpan(row, column, rowIndex, columnIndex) {
      var fn = parentRef.props.mergeMethod;

      if (typeof fn === 'function') {
        var result = fn({
          row: row,
          column: column,
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });
        var rowspan = 1;
        var colspan = 1;

        if (Array.isArray(result)) {
          rowspan = result[0];
          colspan = result[1];
        } else if (typeof result === 'object') {
          rowspan = result.rowspan;
          colspan = result.colspan;
        }

        return {
          rowspan: rowspan,
          colspan: colspan
        };
      } else {
        return {};
      }
    }

    function showWithSpan(row, column, rowIndex, columnIndex) {
      var result = getSpan(row, column, rowIndex, columnIndex);
      return !('rowspan' in result && result.rowspan === 0 || 'colspan' in result && result.colspan === 0);
    }

    function rowChecked(_index) {
      var row = props.objData[_index];
      return row && row._isChecked;
    }

    function rowDisabled(_index) {
      var row = props.objData[_index];
      return row && row._isDisabled;
    }

    function rowExpanded(_index) {
      var row = props.objData[_index];
      return row && row._isExpanded;
    }

    function handleMouseIn(_index) {
      parentRef.handleMouseIn(_index);
    }

    function handleMouseOut(_index) {
      parentRef.handleMouseOut(_index);
    }

    function clickCurrentRow(_index) {
      parentRef.clickCurrentRow(_index);
    }

    function dblclickCurrentRow(_index) {
      parentRef.dblclickCurrentRow(_index);
    }

    return {
      setCellWidth: setCellWidth,
      alignCls: alignCls,
      expandRender: expandRender,
      isExpandModel: isExpandModel,
      getSpan: getSpan,
      showWithSpan: showWithSpan,
      rowChecked: rowChecked,
      rowDisabled: rowDisabled,
      rowExpanded: rowExpanded,
      handleMouseIn: handleMouseIn,
      handleMouseOut: handleMouseOut,
      clickCurrentRow: clickCurrentRow,
      dblclickCurrentRow: dblclickCurrentRow
    };
  }
};

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_table_cell = vue.resolveComponent("table-cell");

  var _component_table_tr = vue.resolveComponent("table-tr");

  var _component_expand = vue.resolveComponent("expand");

  return vue.openBlock(), vue.createBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    border: "0",
    style: $props.styleObject
  }, [vue.createVNode("colgroup", null, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.columns, function (column, index) {
    return vue.openBlock(), vue.createBlock("col", {
      width: $setup.setCellWidth(column),
      key: 'group-' + index
    }, null, 8
    /* PROPS */
    , ["width"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))]), !$setup.isExpandModel ? (vue.openBlock(), vue.createBlock("tbody", {
    key: 0,
    class: [$props.prefixCls + '-tbody']
  }, [vue.createCommentVNode("v-for的内容需要保持只有一个元素，这样拖拽的时候才会更新正确的dom"), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.data, function (row, index) {
    var _ref;

    return vue.openBlock(), vue.createBlock(_component_table_tr, {
      key: $props.rowKey ? row._rowKey : row._index,
      draggable: $props.draggable,
      row: row,
      "prefix-cls": $props.prefixCls,
      "row-key": row._rowKey,
      class: $setup.rowExpanded(row._index) ? (_ref = {}, _ref[$props.prefixCls + '-expanded-hidden'] = $props.fixed, _ref) : null,
      onMouseenter: vue.withModifiers(function ($event) {
        return $setup.handleMouseIn(row._index);
      }, ["stop"]),
      onMouseleave: vue.withModifiers(function ($event) {
        return $setup.handleMouseOut(row._index);
      }, ["stop"]),
      onClick: function onClick($event) {
        return $setup.clickCurrentRow(row._index);
      },
      onDblclick: vue.withModifiers(function ($event) {
        return $setup.dblclickCurrentRow(row._index);
      }, ["stop"])
    }, {
      default: vue.withCtx(function () {
        return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.columns, function (column, colIndex) {
          var _mergeProps2;

          return vue.openBlock(), vue.createBlock(vue.Fragment, null, [$setup.showWithSpan(row, column, index, colIndex) ? (vue.openBlock(), vue.createBlock("td", vue.mergeProps((_mergeProps2 = {
            key: 0,
            class: $setup.alignCls(column, row)
          }, _mergeProps2["key"] = column._columnKey, _mergeProps2), $setup.getSpan(row, column, index, colIndex)), [vue.createVNode(_component_table_cell, {
            fixed: $props.fixed,
            "prefix-cls": $props.prefixCls,
            row: row,
            key: column._columnKey,
            column: column,
            "natural-index": index,
            index: row._index,
            checked: $setup.rowChecked(row._index),
            disabled: $setup.rowDisabled(row._index),
            expanded: $setup.rowExpanded(row._index)
          }, null, 8
          /* PROPS */
          , ["fixed", "prefix-cls", "row", "column", "natural-index", "index", "checked", "disabled", "expanded"])], 16
          /* FULL_PROPS */
          )) : vue.createCommentVNode("v-if", true)], 64
          /* STABLE_FRAGMENT */
          );
        }), 256
        /* UNKEYED_FRAGMENT */
        ))];
      }),
      _: 2
      /* DYNAMIC */

    }, 1032
    /* PROPS, DYNAMIC_SLOTS */
    , ["draggable", "row", "prefix-cls", "row-key", "class", "onMouseenter", "onMouseleave", "onClick", "onDblclick"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : (vue.openBlock(), vue.createBlock(vue.Fragment, {
    key: 1
  }, [vue.createCommentVNode("需要展开行的模式无法拖拽排序"), vue.createVNode("tbody", {
    class: [$props.prefixCls + '-tbody']
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.data, function (row, index) {
    var _class;

    return vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: $props.rowKey ? row._rowKey : row._index
    }, [vue.createVNode(_component_table_tr, {
      row: row,
      "prefix-cls": $props.prefixCls,
      onMouseenter: vue.withModifiers(function ($event) {
        return $setup.handleMouseIn(row._index);
      }, ["stop"]),
      onMouseleave: vue.withModifiers(function ($event) {
        return $setup.handleMouseOut(row._index);
      }, ["stop"]),
      onClick: function onClick($event) {
        return $setup.clickCurrentRow(row._index);
      },
      onDblclick: vue.withModifiers(function ($event) {
        return $setup.dblclickCurrentRow(row._index);
      }, ["stop"])
    }, {
      default: vue.withCtx(function () {
        return [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.columns, function (column, colIndex) {
          var _mergeProps3;

          return vue.openBlock(), vue.createBlock(vue.Fragment, null, [$setup.showWithSpan(row, column, index, colIndex) ? (vue.openBlock(), vue.createBlock("td", vue.mergeProps((_mergeProps3 = {
            key: 0,
            class: $setup.alignCls(column, row)
          }, _mergeProps3["key"] = column._columnKey, _mergeProps3), $setup.getSpan(row, column, index, colIndex)), [vue.createVNode(_component_table_cell, {
            fixed: $props.fixed,
            "prefix-cls": $props.prefixCls,
            row: row,
            key: column._columnKey,
            column: column,
            "natural-index": index,
            index: row._index,
            checked: $setup.rowChecked(row._index),
            disabled: $setup.rowDisabled(row._index),
            expanded: $setup.rowExpanded(row._index)
          }, null, 8
          /* PROPS */
          , ["fixed", "prefix-cls", "row", "column", "natural-index", "index", "checked", "disabled", "expanded"])], 16
          /* FULL_PROPS */
          )) : vue.createCommentVNode("v-if", true)], 64
          /* STABLE_FRAGMENT */
          );
        }), 256
        /* UNKEYED_FRAGMENT */
        ))];
      }),
      _: 2
      /* DYNAMIC */

    }, 1032
    /* PROPS, DYNAMIC_SLOTS */
    , ["row", "prefix-cls", "onMouseenter", "onMouseleave", "onClick", "onDblclick"]), $setup.rowExpanded(row._index) ? (vue.openBlock(), vue.createBlock("tr", {
      class: (_class = {}, _class[$props.prefixCls + '-expanded-hidden'] = $props.fixed, _class),
      key: row._index
    }, [vue.createVNode("td", {
      colspan: $props.columns.length,
      class: $props.prefixCls + '-expanded-cell'
    }, [vue.createVNode(_component_expand, {
      key: $props.rowKey ? row._rowKey : index,
      row: row,
      render: $setup.expandRender,
      index: row._index
    }, null, 8
    /* PROPS */
    , ["row", "render", "index"])], 10
    /* CLASS, PROPS */
    , ["colspan"])], 2
    /* CLASS */
    )) : vue.createCommentVNode("v-if", true)], 64
    /* STABLE_FRAGMENT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )], 2112
  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  ))], 4
  /* STYLE */
  );
}

script$6.render = render$6;
script$6.__file = "src/components/table/table-body.vue";

var prefixCls$1 = 'bin-table';
var rowKey = 1;
var columnKey = 1;
var script$5 = {
  name: 'BTable',
  components: {
    BEmpty: script$1H,
    TableBody: script$6,
    TableHead: script$9
  },
  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    columns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    size: {
      validator: function validator(value) {
        return ['small', 'large', 'default'].includes(value);
      },
      default: 'default'
    },
    width: {
      type: [Number, String]
    },
    height: {
      type: [Number, String]
    },
    maxHeight: {
      type: [Number, String]
    },
    stripe: {
      type: Boolean,
      default: false
    },
    border: {
      type: Boolean,
      default: false
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    highlightRow: {
      type: Boolean,
      default: false
    },
    rowClassName: {
      type: Function,
      default: function _default() {
        return '';
      }
    },
    context: {
      type: Object
    },
    noDataText: {
      type: String,
      default: '暂无数据'
    },
    disabledHover: {
      type: Boolean
    },
    loading: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    dragHandle: String,
    tooltipTheme: {
      type: String,
      validator: function validator(value) {
        return ['dark', 'light'].includes(value);
      }
    },
    rowKey: {
      type: Boolean,
      default: false
    },
    mergeMethod: {
      type: Function
    },
    loadingText: String
  },
  emits: ['sort-change', 'current-change', 'row-click', 'row-dblclick', 'select', 'select-cancel', 'selection-change', 'select-all', 'select-all-cancel', 'selection-change', 'expand', 'drag-drop'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var containerRef = vue.ref(null);
    var titleRef = vue.ref(null);
    var headerRef = vue.ref(null);
    var bodyRef = vue.ref(null);
    var tbodyRef = vue.ref(null);
    var footerRef = vue.ref(null);
    var fixedBodyRef = vue.ref(null);
    var fixedRightBodyRef = vue.ref(null); // 基础数据

    var colsWithId = makeColumnsId(deepCopy(props.columns)); // data

    var read = vue.ref(false);
    var cloneColumns = vue.ref(makeColumns(colsWithId));
    var columnRows = vue.ref(makeColumnRows(false, colsWithId));
    var leftFixedColumnRows = vue.ref(makeColumnRows('left', colsWithId));
    var rightFixedColumnRows = vue.ref(makeColumnRows('right', colsWithId));
    var allColumns = vue.ref(getAllColumns(colsWithId));
    var tableWidth = vue.ref(0);
    var headerWidth = vue.ref(0);
    var headerHeight = vue.ref(0);
    var bodyHeight = vue.ref(0);
    var columnsWidth = vue.ref({});
    var cloneData = vue.ref(deepCopy(props.data));
    var rebuildData = vue.ref(makeDataWithSort());
    var objData = vue.ref(makeObjData());
    var showVerticalScrollBar = vue.ref(false);
    var showHorizontalScrollBar = vue.ref(false);
    var scrollBarWidth = vue.ref(getScrollBarWidth()); // computed

    var wrapClasses = vue.computed(function () {
      var _ref2;

      return [prefixCls$1 + "-wrapper", (_ref2 = {}, _ref2[prefixCls$1 + "-hide"] = !read.value, _ref2[prefixCls$1 + "-wrapper-with-border"] = props.border, _ref2)];
    });
    var wrapStyles = vue.computed(function () {
      var height = props.height;
      var maxHeight = props.maxHeight;
      var width = props.width;
      var style = {};
      if (height) style.height = parseInt(height) + "px";
      if (maxHeight) style.maxHeight = parseInt(maxHeight) + "px";
      if (width) style.width = parseInt(width) + "px";
      return style;
    });
    var classes = vue.computed(function () {
      var _ref3;

      return ["" + prefixCls$1, (_ref3 = {}, _ref3[prefixCls$1 + "-" + props.size] = !!props.size, _ref3[prefixCls$1 + "-border"] = props.border, _ref3[prefixCls$1 + "-stripe"] = props.stripe, _ref3[prefixCls$1 + "-with-fixed-top"] = !!props.height, _ref3)];
    });
    var bodyStyle = vue.computed(function () {
      var style = {};
      var _bodyHeight = bodyHeight.value;

      if (_bodyHeight !== 0) {
        var height = _bodyHeight;

        if (props.height) {
          style.height = height + "px";
        } else if (props.maxHeight) {
          style.maxHeight = height + "px";
        }
      }

      return style;
    });
    var tableHeaderStyle = vue.computed(function () {
      var _tableWidth = tableWidth.value;
      var style = {};

      if (_tableWidth !== 0) {
        style.width = _tableWidth + "px";
      }

      return style;
    });
    var tableStyle = vue.computed(function () {
      var style = {};
      var _tableWidth = tableWidth.value;
      var _bodyHeight = bodyHeight.value;

      if (_tableWidth !== 0) {
        var width = '';

        if (_bodyHeight === 0) {
          width = _tableWidth;
        } else {
          width = _tableWidth - (showVerticalScrollBar.value ? scrollBarWidth.value : 0);
        }

        style.width = width + "px";
      }

      return style;
    });
    var sortInstance = null; // fixed table

    var isLeftFixed = vue.computed(function () {
      return props.columns.some(function (col) {
        return col.fixed && col.fixed === 'left';
      });
    });
    var isRightFixed = vue.computed(function () {
      return props.columns.some(function (col) {
        return col.fixed && col.fixed === 'right';
      });
    });
    var leftFixedColumns = vue.computed(function () {
      return convertColumnOrder(cloneColumns.value, 'left');
    });
    var rightFixedColumns = vue.computed(function () {
      return convertColumnOrder(cloneColumns.value, 'right');
    });
    var fixedTableStyle = vue.computed(function () {
      var style = {};
      var width = 0;
      leftFixedColumns.value.forEach(function (col) {
        if (col.fixed && col.fixed === 'left') width += col._width;
      });
      style.width = width - 1 + "px";
      style.left = "1px";
      return style;
    });
    var fixedRightTableStyle = vue.computed(function () {
      var style = {};
      var width = 0;
      rightFixedColumns.value.forEach(function (col) {
        if (col.fixed && col.fixed === 'right') width += col._width;
      }); // width += this.scrollBarWidth;

      style.width = width + "px";
      style.right = (showVerticalScrollBar.value ? scrollBarWidth.value : 0) + "px";
      return style;
    });
    var fixedRightHeaderStyle = vue.computed(function () {
      var style = {};
      var width = 0;
      var height = headerHeight.value + 1;

      if (showVerticalScrollBar.value) {
        width = scrollBarWidth.value;
      }

      style.width = width + "px";
      style.height = height + "px";
      return style;
    });
    var fixedBodyStyle = vue.computed(function () {
      var style = {};
      var _bodyHeight = bodyHeight.value;
      var _showHorizontalScrollBar = showHorizontalScrollBar.value;

      if (_bodyHeight !== 0) {
        var height = _bodyHeight - (_showHorizontalScrollBar ? scrollBarWidth.value : 0);
        style.height = _showHorizontalScrollBar ? height + "px" : height - 1 + "px";
      }

      return style;
    });
    var fixedHeaderClasses = vue.computed(function () {
      var _ref4;

      return [prefixCls$1 + "-fixed-header", (_ref4 = {}, _ref4[prefixCls$1 + "-fixed-header-with-empty"] = !rebuildData.value.length, _ref4)];
    }); // methods
    // 修改列，设置一个隐藏的 id，便于后面的多级表头寻找对应的列，否则找不到

    function makeColumnsId(columns) {
      return columns.map(function (item) {
        if ('children' in item) makeColumnsId(item.children);
        item.__id = getRandomStr(6);
        return item;
      });
    }

    function makeColumns(cols) {
      // 在 data 时，this.allColumns 暂时为 undefined
      var columns = deepCopy(getAllColumns(cols));
      var left = [];
      var right = [];
      var center = [];
      columns.forEach(function (column, index) {
        column._index = index;
        column._columnKey = columnKey++;
        column.width = parseInt(column.width);
        column._width = column.width ? column.width : ''; // update in handleResize()

        column._sortType = 'normal';

        if ('sortType' in column) {
          column._sortType = column.sortType;
        }

        if (column.fixed && column.fixed === 'left') {
          left.push(column);
        } else if (column.fixed && column.fixed === 'right') {
          right.push(column);
        } else {
          center.push(column);
        }
      });
      return left.concat(center).concat(right);
    } // create a multiple table-head


    function makeColumnRows(fixedType, cols) {
      return convertToRows(cols, fixedType);
    }

    function makeData() {
      var data = deepCopy(props.data);
      data.forEach(function (row, index) {
        row._index = index;
        row._rowKey = generateId$1() + rowKey++;
      });
      return data;
    }

    function makeObjData() {
      var data = {};
      props.data.forEach(function (row, index) {
        var newRow = deepCopy(row); // todo 直接替换

        newRow._isHover = false;

        if (newRow._disabled) {
          newRow._isDisabled = newRow._disabled;
        } else {
          newRow._isDisabled = false;
        }

        if (newRow._checked) {
          newRow._isChecked = newRow._checked;
        } else {
          newRow._isChecked = false;
        }

        if (newRow._expanded) {
          newRow._isExpanded = newRow._expanded;
        } else {
          newRow._isExpanded = false;
        }

        if (newRow._highlight) {
          newRow._isHighlight = newRow._highlight;
        } else {
          newRow._isHighlight = false;
        }

        data[index] = newRow;
      });
      return data;
    } // 排序函数


    function sortData(data, type, index) {
      var key = cloneColumns.value[index].key;
      data.sort(function (a, b) {
        var method = cloneColumns.value[index]['sortMethod'];

        if (method) {
          return method(a[key], b[key], type);
        } else {
          if (type === 'asc') {
            return a[key] > b[key] ? 1 : -1;
          } else if (type === 'desc') {
            return a[key] < b[key] ? 1 : -1;
          }
        }
      });
      return data;
    }

    function makeDataWithSort() {
      var data = makeData();
      var sortType = 'normal';
      var sortIndex = -1;
      var isCustom = false;

      for (var i = 0; i < cloneColumns.value.length; i++) {
        var columnType = cloneColumns.value[i]['_sortType'];

        if (columnType !== 'normal') {
          sortType = columnType;
          sortIndex = i;
          isCustom = columnType === 'custom';
          break;
        }
      }

      if (sortType !== 'normal' && !isCustom) data = sortData(data, sortType, sortIndex);
      return data;
    }

    function fixedHeader() {
      var height = props.height;
      var maxHeight = props.maxHeight;

      if (height || maxHeight) {
        vue.nextTick(function () {
          var titleHeight = parseInt(getStyle(titleRef.value, 'height')) || 0;
          var headerHeight = parseInt(getStyle(headerRef.value, 'height')) || 0;
          var footerHeight = parseInt(getStyle(footerRef.value, 'height')) || 0;

          if (height) {
            bodyHeight.value = height - titleHeight - headerHeight - footerHeight;
          } else if (maxHeight) {
            bodyHeight.value = maxHeight - titleHeight - headerHeight - footerHeight;
          }

          vue.nextTick(function () {
            return fixedBody();
          });
        });
      } else {
        bodyHeight.value = 0;
        vue.nextTick(function () {
          return fixedBody();
        });
      }
    }

    function fixedBody() {
      var header = headerRef.value;
      var tbody = tbodyRef.value;

      if (header) {
        headerWidth.value = header.children[0].offsetWidth;
        headerHeight.value = header.children[0].offsetHeight;
      }

      if (!tbody || !props.data || props.data.length === 0) {
        showVerticalScrollBar.value = false;
      } else {
        var bodyContentEl = tbody.$el;
        var bodyEl = bodyContentEl.parentElement;
        var bodyContentHeight = bodyContentEl.offsetHeight;
        var offsetHeight = bodyEl.offsetHeight;
        var showHBar = showHorizontalScrollBar.value = bodyEl.offsetWidth < bodyContentEl.offsetWidth + (showVerticalScrollBar.value ? scrollBarWidth.value : 0);
        showVerticalScrollBar.value = bodyHeight.value ? offsetHeight - (showHBar ? scrollBarWidth.value : 0) < bodyContentHeight : false;

        if (showVerticalScrollBar.value) {
          bodyEl.classList.add('bin-table-overflowY');
        } else {
          bodyEl.classList.remove('bin-table-overflowY');
        }

        if (showHorizontalScrollBar.value) {
          bodyEl.classList.add('bin-table-overflowX');
        } else {
          bodyEl.classList.remove('bin-table-overflowX');
        }
      }
    }

    function handleResize() {
      var cloneColumnsBuf = cloneColumns.value;
      var offsetWidth = containerRef.value.offsetWidth;
      var columnsWidthObj = {};
      var sumMinWidth = 0;
      var hasWidthColumns = [];
      var noWidthColumns = [];
      var noMaxWidthColumns = [];
      cloneColumnsBuf.forEach(function (col) {
        if (col.width) {
          hasWidthColumns.push(col);
        } else {
          noWidthColumns.push(col);

          if (col.minWidth) {
            sumMinWidth += col.minWidth;
          }

          if (col.maxWidth) ; else {
            noMaxWidthColumns.push(col);
          }
        }

        col._width = null;
      });
      var unUsableWidth = hasWidthColumns.map(function (cell) {
        return cell.width;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
      var usableWidth = offsetWidth - unUsableWidth - sumMinWidth - (showVerticalScrollBar.value ? scrollBarWidth.value : 0) - 1;
      var usableLength = noWidthColumns.length;
      var columnWidth = 0;

      if (usableWidth > 0 && usableLength > 0) {
        columnWidth = parseInt(usableWidth / usableLength);
      }

      for (var i = 0; i < cloneColumnsBuf.length; i++) {
        var column = cloneColumnsBuf[i];
        var width = columnWidth + (column.minWidth ? column.minWidth : 0);

        if (column.width) {
          width = column.width;
        } else {
          if (column._width) {
            width = column._width;
          } else {
            if (column.minWidth > width) {
              width = column.minWidth;
            } else if (column.maxWidth < width) {
              width = column.maxWidth;
            }

            if (usableWidth > 0) {
              usableWidth -= width - (column.minWidth ? column.minWidth : 0);
              usableLength--;

              if (usableLength > 0) {
                columnWidth = parseInt(usableWidth / usableLength);
              } else {
                columnWidth = 0;
              }
            } else {
              columnWidth = 0;
            }
          }
        }

        column._width = width;
        columnsWidthObj[column._index] = {
          width: width
        };
      }

      if (usableWidth > 0) {
        usableLength = noMaxWidthColumns.length;
        columnWidth = parseInt(usableWidth / usableLength);

        for (var _i = 0; _i < noMaxWidthColumns.length; _i++) {
          var _column = noMaxWidthColumns[_i];

          var _width = _column._width + columnWidth;

          if (usableLength > 1) {
            usableLength--;
            usableWidth -= columnWidth;
            columnWidth = parseInt(usableWidth / usableLength);
          } else {
            columnWidth = 0;
          }

          _column._width = _width;
          columnsWidthObj[_column._index] = {
            width: _width
          };
        }
      }

      tableWidth.value = cloneColumnsBuf.map(function (cell) {
        return cell._width;
      }).reduce(function (a, b) {
        return a + b;
      }, 0) + (showVerticalScrollBar.value ? scrollBarWidth.value : 0) + 1;
      columnsWidth.value = columnsWidthObj;
      fixedHeader();
    }

    function GetOriginalIndex(_index) {
      return cloneColumns.value.findIndex(function (item) {
        return item._index === _index;
      });
    }

    function handleSort(_index, type) {
      var index = GetOriginalIndex(_index);
      var columns = cloneColumns.value;
      columns.forEach(function (col) {
        col._sortType = 'normal';
      });
      var key = columns[index].key;

      if (columns[index].sortable !== 'custom') {
        // custom is for remote sort
        if (type === 'normal') {
          rebuildData.value = makeDataWithSort();
        } else {
          rebuildData.value = sortData(rebuildData.value, type, index);
        }
      }

      columns[index]._sortType = type;
      emit('sort-change', {
        column: JSON.parse(JSON.stringify(allColumns.value[columns[index]._index])),
        key: key,
        order: type
      });
    }

    function handleMouseIn(_index) {
      if (props.disabledHover) return;
      if (objData.value[_index]._isHover) return;
      objData.value[_index]._isHover = true;
    }

    function handleMouseOut(_index) {
      if (props.disabledHover) return;
      objData.value[_index]._isHover = false;
    }

    function handleBodyScroll(event) {
      if (props.showHeader) headerRef.value.scrollLeft = event.target.scrollLeft;
      if (isLeftFixed.value) fixedBodyRef.value.scrollTop = event.target.scrollTop;
      if (isRightFixed.value) fixedRightBodyRef.value.scrollTop = event.target.scrollTop;
    }

    function handleFixedMousewheel(e) {
      var deltaY = e.deltaY;

      if (!deltaY && e.detail) {
        deltaY = e.detail * 40;
      }

      if (!deltaY && e.wheelDeltaY) {
        deltaY = -e.wheelDeltaY;
      }

      if (!deltaY && e.wheelDelta) {
        deltaY = -e.wheelDelta;
      }

      if (!deltaY) return;
      var body = bodyRef.value;
      var currentScrollTop = body.scrollTop;

      if (deltaY < 0 && currentScrollTop !== 0) {
        e.preventDefault();
      }

      if (deltaY > 0 && body.scrollHeight - body.clientHeight > currentScrollTop) {
        e.preventDefault();
      } // body.scrollTop += deltaY;


      var step = 0;
      var timeId = setInterval(function () {
        step += 5;

        if (deltaY > 0) {
          body.scrollTop += 2;
        } else {
          body.scrollTop -= 2;
        }

        if (step >= Math.abs(deltaY)) {
          clearInterval(timeId);
        }
      }, 5);
    }

    function handleMouseWheel(e) {
      var deltaX = e.deltaX;
      var $body = bodyRef.value;

      if (deltaX > 0) {
        $body.scrollLeft = $body.scrollLeft + 10;
      } else {
        $body.scrollLeft = $body.scrollLeft - 10;
      }
    } // 通用处理 highlightCurrentRow 和 clearCurrentRow


    function handleCurrentRow(type, _index) {
      var oldIndex = -1;
      var _objData = objData.value;
      var _cloneData = cloneData.value;

      for (var i in _objData) {
        if (_objData[i]._isHighlight) {
          oldIndex = parseInt(i);
          _objData[i]._isHighlight = false;
        }
      }

      if (type === 'highlight') _objData[_index]._isHighlight = true;
      var oldData = oldIndex < 0 ? null : JSON.parse(JSON.stringify(_cloneData[oldIndex]));
      var newData = type === 'highlight' ? JSON.parse(JSON.stringify(_cloneData[_index])) : null;
      emit('current-change', newData, oldData, _index);
    }

    function highlightCurrentRow(_index) {
      if (!props.highlightRow || objData.value[_index]._isHighlight) return;
      handleCurrentRow('highlight', _index);
    }

    function clearCurrentRow() {
      if (!props.highlightRow) return;
      handleCurrentRow('clear');
    }

    function clickCurrentRow(_index) {
      var _cloneData = cloneData.value;
      if (_index === _cloneData.length) return;
      highlightCurrentRow(_index);
      emit('row-click', JSON.parse(JSON.stringify(_cloneData[_index])), _index);
    }

    function dblclickCurrentRow(_index) {
      var _cloneData = cloneData.value;
      highlightCurrentRow(_index);
      emit('row-dblclick', JSON.parse(JSON.stringify(_cloneData[_index])), _index);
    }

    function getSelection() {
      var selectionIndexes = [];
      var _objData = objData.value;

      for (var i in _objData) {
        if (_objData[i]._isChecked) selectionIndexes.push(parseInt(i));
      }

      return JSON.parse(JSON.stringify(props.data.filter(function (data, index) {
        return selectionIndexes.indexOf(index) > -1;
      })));
    }

    function toggleSelect(_index) {
      var data = {};
      var _objData = objData.value;

      for (var i in _objData) {
        if (parseInt(i) === _index) {
          data = _objData[i];
          break;
        }
      }

      var status = !data._isChecked;
      _objData[_index]._isChecked = status;
      var selection = getSelection();
      emit(status ? 'select' : 'select-cancel', selection, JSON.parse(JSON.stringify(props.data[_index])));
      emit('selection-change', selection);
    }

    function toggleExpand(_index) {
      var data = {};
      var _objData = objData.value;

      for (var i in _objData) {
        if (parseInt(i) === _index) {
          data = _objData[i];
          break;
        }
      }

      var status = !data._isExpanded;
      data._isExpanded = status;
      emit('expand', JSON.parse(JSON.stringify(cloneData.value[_index])), status);

      if (props.height || props.maxHeight) {
        vue.nextTick(function () {
          return fixedBody();
        });
      }
    }

    function selectAll(status) {
      for (var _iterator = _createForOfIteratorHelperLoose(rebuildData.value), _step; !(_step = _iterator()).done;) {
        var data = _step.value;
        var _objData = objData.value;

        if (_objData[data._index]._isDisabled) {
          continue;
        }

        _objData[data._index]._isChecked = status;
      }

      var selection = getSelection();

      if (status) {
        emit('select-all', selection);
      } else {
        emit('select-all-cancel', selection);
      }

      emit('selection-change', selection);
    }

    function dragAndDrop(newIndex, oldIndex, newData) {
      emit('drag-drop', newIndex, oldIndex, newData);
    }

    vue.provide('BTable', {
      props: props,
      showVerticalScrollBar: showVerticalScrollBar,
      scrollBarWidth: scrollBarWidth,
      objData: objData,
      handleSort: handleSort,
      handleMouseIn: handleMouseIn,
      handleMouseOut: handleMouseOut,
      handleCurrentRow: handleCurrentRow,
      highlightCurrentRow: highlightCurrentRow,
      clickCurrentRow: clickCurrentRow,
      dblclickCurrentRow: dblclickCurrentRow,
      slots: slots,
      toggleSelect: toggleSelect,
      selectAll: selectAll,
      toggleExpand: toggleExpand
    }); // 钩子函数

    vue.onMounted(function () {
      handleResize();
      on$1(window, 'resize', handleResize);

      if (containerRef.value) {
        addResizeListener(containerRef.value.parentElement, handleResize);
      }

      vue.nextTick(function () {
        read.value = true;
      });

      if (props.draggable) {
        setSort();
      }
    }); // 初始化拖拽

    function setSort() {
      if (sortInstance) sortInstance.destroy();
      var table = tbodyRef.value.$el.querySelector('.bin-table-tbody');
      sortInstance = Sortable.create(table, {
        animation: 150,
        ghostClass: 'bin-table-ghost-class',
        handle: props.dragHandle,
        onEnd: function onEnd(evt) {
          var newIndex = evt.newIndex,
              oldIndex = evt.oldIndex;
          var newData = deepCopy(props.data);
          var targetRow = newData.splice(oldIndex, 1)[0];
          newData.splice(newIndex, 0, targetRow);
          dragAndDrop(newIndex, oldIndex, newData);
        }
      });
    }

    vue.onBeforeUnmount(function () {
      if (sortInstance) sortInstance.destroy();
      off$1(window, 'resize', handleResize);

      if (containerRef.value) {
        removeResizeListener(containerRef.value.parentElement, handleResize);
      }
    });
    vue.watch(function () {
      return props.data;
    }, function (newData) {
      var oldDataLen = rebuildData.value.length;
      objData.value = makeObjData();
      rebuildData.value = makeDataWithSort();
      if (!oldDataLen) fixedHeader();
      cloneData.value = deepCopy(newData);
      vue.nextTick(function () {
        handleResize();
      });
    }, {
      deep: true
    });
    vue.watch(function () {
      return props.columns;
    }, function (newColumns) {
      var colsWithId = makeColumnsId(newColumns);
      allColumns.value = getAllColumns(colsWithId);
      cloneColumns.value = makeColumns(colsWithId);
      columnRows.value = makeColumnRows(false, colsWithId);
      leftFixedColumnRows.value = makeColumnRows('left', colsWithId);
      rightFixedColumnRows.value = makeColumnRows('right', colsWithId);
      rebuildData.value = makeDataWithSort();
      vue.nextTick(function () {
        handleResize();
      });
    }, {
      deep: true
    });
    vue.watch(function () {
      return [props.height, props.maxHeight, showHorizontalScrollBar, showVerticalScrollBar];
    }, function () {
      handleResize();
    });
    return {
      containerRef: containerRef,
      titleRef: titleRef,
      headerRef: headerRef,
      bodyRef: bodyRef,
      tbodyRef: tbodyRef,
      footerRef: footerRef,
      fixedBodyRef: fixedBodyRef,
      fixedRightBodyRef: fixedRightBodyRef,
      // data
      read: read,
      cloneColumns: cloneColumns,
      columnRows: columnRows,
      headerWidth: headerWidth,
      headerHeight: headerHeight,
      objData: objData,
      bodyHeight: bodyHeight,
      columnsWidth: columnsWidth,
      tableWidth: tableWidth,
      rebuildData: rebuildData,
      cloneData: cloneData,
      showVerticalScrollBar: showVerticalScrollBar,
      scrollBarWidth: scrollBarWidth,
      // computed
      wrapClasses: wrapClasses,
      wrapStyles: wrapStyles,
      classes: classes,
      tableHeaderStyle: tableHeaderStyle,
      tableStyle: tableStyle,
      bodyStyle: bodyStyle,
      isLeftFixed: isLeftFixed,
      isRightFixed: isRightFixed,
      leftFixedColumns: leftFixedColumns,
      rightFixedColumns: rightFixedColumns,
      leftFixedColumnRows: leftFixedColumnRows,
      rightFixedColumnRows: rightFixedColumnRows,
      fixedTableStyle: fixedTableStyle,
      fixedRightTableStyle: fixedRightTableStyle,
      fixedHeaderClasses: fixedHeaderClasses,
      fixedBodyStyle: fixedBodyStyle,
      fixedRightHeaderStyle: fixedRightHeaderStyle,
      handleSort: handleSort,
      handleMouseIn: handleMouseIn,
      handleMouseOut: handleMouseOut,
      handleCurrentRow: handleCurrentRow,
      highlightCurrentRow: highlightCurrentRow,
      handleMouseWheel: handleMouseWheel,
      handleBodyScroll: handleBodyScroll,
      handleFixedMousewheel: handleFixedMousewheel,
      clickCurrentRow: clickCurrentRow,
      clearCurrentRow: clearCurrentRow,
      selectAll: selectAll,
      getSelection: getSelection,
      toggleSelect: toggleSelect,
      toggleExpand: toggleExpand
    };
  }
};

var _hoisted_1$3 = {
  cellspacing: "0",
  cellpadding: "0",
  border: "0"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_table_head = vue.resolveComponent("table-head");

  var _component_table_body = vue.resolveComponent("table-body");

  var _component_b_empty = vue.resolveComponent("b-empty");

  var _directive_loading = vue.resolveDirective("loading");

  return vue.openBlock(), vue.createBlock("div", {
    class: $setup.wrapClasses,
    style: $setup.wrapStyles,
    ref: "containerRef"
  }, [vue.withDirectives(vue.createVNode("div", {
    class: $setup.classes
  }, [$props.showHeader ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: ['bin-table-header'],
    ref: "headerRef",
    onMousewheel: _cache[1] || (_cache[1] = function () {
      return $setup.handleMouseWheel && $setup.handleMouseWheel.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_table_head, {
    "prefix-cls": "bin-table",
    styleObject: $setup.tableHeaderStyle,
    columns: $setup.cloneColumns,
    "column-rows": $setup.columnRows,
    "obj-data": $setup.objData,
    "columns-width": $setup.columnsWidth,
    data: $setup.rebuildData
  }, null, 8
  /* PROPS */
  , ["styleObject", "columns", "column-rows", "obj-data", "columns-width", "data"])], 544
  /* HYDRATE_EVENTS, NEED_PATCH */
  )) : vue.createCommentVNode("v-if", true), vue.withDirectives(vue.createVNode("div", {
    class: ['bin-table-body'],
    ref: "bodyRef",
    style: $setup.bodyStyle,
    onScroll: _cache[2] || (_cache[2] = function () {
      return $setup.handleBodyScroll && $setup.handleBodyScroll.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_table_body, {
    ref: "tbodyRef",
    "prefix-cls": "bin-table",
    draggable: $props.draggable,
    styleObject: $setup.tableStyle,
    columns: $setup.cloneColumns,
    data: $setup.rebuildData,
    "row-key": $props.rowKey,
    "columns-width": $setup.columnsWidth,
    "obj-data": $setup.objData
  }, null, 8
  /* PROPS */
  , ["draggable", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 36
  /* STYLE, HYDRATE_EVENTS */
  ), [[vue.vShow, !(!!$props.noDataText && (!$props.data || $props.data.length === 0))]]), vue.withDirectives(vue.createVNode("div", {
    class: ['bin-table-tip'],
    style: $setup.bodyStyle,
    onScroll: _cache[3] || (_cache[3] = function () {
      return $setup.handleBodyScroll && $setup.handleBodyScroll.apply($setup, arguments);
    })
  }, [vue.createVNode("table", _hoisted_1$3, [vue.createVNode("tbody", null, [vue.createVNode("tr", null, [vue.createVNode("td", {
    style: {
      'height': $setup.bodyStyle.height,
      'width': $setup.headerWidth + "px"
    }
  }, [!$props.data || $props.data.length === 0 ? (vue.openBlock(), vue.createBlock(_component_b_empty, {
    key: 0
  }, {
    default: vue.withCtx(function () {
      return [vue.createTextVNode(vue.toDisplayString($props.noDataText), 1
      /* TEXT */
      )];
    }),
    _: 1
    /* STABLE */

  })) : vue.createCommentVNode("v-if", true)], 4
  /* STYLE */
  )])])])], 36
  /* STYLE, HYDRATE_EVENTS */
  ), [[vue.vShow, !$props.data || $props.data.length === 0]]), $setup.isLeftFixed ? (vue.openBlock(), vue.createBlock("div", {
    key: 1,
    class: ['bin-table-fixed'],
    style: $setup.fixedTableStyle
  }, [$props.showHeader ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: $setup.fixedHeaderClasses
  }, [vue.createVNode(_component_table_head, {
    fixed: "left",
    "prefix-cls": "bin-table",
    styleObject: $setup.fixedTableStyle,
    columns: $setup.leftFixedColumns,
    "column-rows": $setup.columnRows,
    "fixed-column-rows": $setup.leftFixedColumnRows,
    "obj-data": $setup.objData,
    "columns-width": $setup.columnsWidth,
    data: $setup.rebuildData
  }, null, 8
  /* PROPS */
  , ["styleObject", "columns", "column-rows", "fixed-column-rows", "obj-data", "columns-width", "data"])], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    class: ['bin-table-fixed-body'],
    style: $setup.fixedBodyStyle,
    ref: "fixedBodyRef",
    onMousewheel: _cache[4] || (_cache[4] = function () {
      return $setup.handleFixedMousewheel && $setup.handleFixedMousewheel.apply($setup, arguments);
    }),
    onDOMMouseScroll: _cache[5] || (_cache[5] = function () {
      return $setup.handleFixedMousewheel && $setup.handleFixedMousewheel.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_table_body, {
    fixed: "left",
    draggable: $props.draggable,
    "prefix-cls": "bin-table",
    styleObject: $setup.fixedTableStyle,
    columns: $setup.leftFixedColumns,
    data: $setup.rebuildData,
    "row-key": $props.rowKey,
    "columns-width": $setup.columnsWidth,
    "obj-data": $setup.objData
  }, null, 8
  /* PROPS */
  , ["draggable", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 36
  /* STYLE, HYDRATE_EVENTS */
  )], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true), $setup.isRightFixed ? (vue.openBlock(), vue.createBlock("div", {
    key: 2,
    class: ['bin-table-fixed-right'],
    style: $setup.fixedRightTableStyle
  }, [$props.showHeader ? (vue.openBlock(), vue.createBlock("div", {
    key: 0,
    class: $setup.fixedHeaderClasses
  }, [vue.createVNode(_component_table_head, {
    fixed: "right",
    "prefix-cls": "bin-table",
    styleObject: $setup.fixedRightTableStyle,
    columns: $setup.rightFixedColumns,
    "column-rows": $setup.columnRows,
    "fixed-column-rows": $setup.rightFixedColumnRows,
    "obj-data": $setup.objData,
    "columns-width": $setup.columnsWidth,
    data: $setup.rebuildData
  }, null, 8
  /* PROPS */
  , ["styleObject", "columns", "column-rows", "fixed-column-rows", "obj-data", "columns-width", "data"])], 2
  /* CLASS */
  )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
    class: ['bin-table-fixed-body'],
    style: $setup.fixedBodyStyle,
    ref: "fixedRightBodyRef",
    onMousewheel: _cache[6] || (_cache[6] = function () {
      return $setup.handleFixedMousewheel && $setup.handleFixedMousewheel.apply($setup, arguments);
    }),
    onDOMMouseScroll: _cache[7] || (_cache[7] = function () {
      return $setup.handleFixedMousewheel && $setup.handleFixedMousewheel.apply($setup, arguments);
    })
  }, [vue.createVNode(_component_table_body, {
    fixed: "right",
    draggable: $props.draggable,
    "prefix-cls": "bin-table",
    styleObject: $setup.fixedRightTableStyle,
    columns: $setup.rightFixedColumns,
    data: $setup.rebuildData,
    "row-key": $props.rowKey,
    "columns-width": $setup.columnsWidth,
    "obj-data": $setup.objData
  }, null, 8
  /* PROPS */
  , ["draggable", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 36
  /* STYLE, HYDRATE_EVENTS */
  )], 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true), $setup.isRightFixed ? (vue.openBlock(), vue.createBlock("div", {
    key: 3,
    class: ['bin-table-fixed-right-header'],
    style: $setup.fixedRightHeaderStyle
  }, null, 4
  /* STYLE */
  )) : vue.createCommentVNode("v-if", true)], 2
  /* CLASS */
  ), [[_directive_loading, $props.loading, $props.loadingText]])], 6
  /* CLASS, STYLE */
  );
}

script$5.render = render$5;
script$5.__file = "src/components/table/table.vue";

script$5.install = function (app) {
  app.component(script$5.name, script$5);
};

// 此组件参考vue-count-to实现
var script$4 = {
  name: 'BCountTo',
  props: {
    startVal: {
      type: Number,
      default: 0
    },
    endVal: {
      type: Number,
      default: 2000
    },
    duration: {
      type: Number,
      default: 2000
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    decimals: {
      type: Number,
      required: false,
      default: 0,
      validator: function validator(value) {
        return value >= 0;
      }
    },
    decimal: {
      type: String,
      default: '.'
    },
    separator: {
      type: String,
      default: ','
    },
    prefix: {
      type: String,
      default: ''
    },
    suffix: {
      type: String,
      default: ''
    },
    useEasing: {
      type: Boolean,
      default: true
    },
    easingFn: {
      type: Function,
      default: function _default(t, b, c, d) {
        return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
      }
    }
  },
  emits: ['mounted', 'callback'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var state = vue.reactive({
      localStartVal: props.startVal,
      displayValue: formatNumber(props.startVal),
      printVal: null,
      paused: false,
      localDuration: props.duration,
      startTime: null,
      timestamp: null,
      remaining: null,
      rAF: null
    });
    vue.onMounted(function () {
      if (props.autoplay) {
        start();
      }

      emit('mounted');
    });
    var getCountDown = vue.computed(function () {
      return props.startVal > props.endVal;
    });
    vue.watch([function () {
      return props.startVal;
    }, function () {
      return props.endVal;
    }], function () {
      if (props.autoplay) {
        start();
      }
    });

    function start() {
      var startVal = props.startVal,
          duration = props.duration;
      state.localStartVal = startVal;
      state.startTime = null;
      state.localDuration = duration;
      state.paused = false;
      state.rAF = requestAnimationFrame(count);
    }

    function pauseResume() {
      if (state.paused) {
        resume();
        state.paused = false;
      } else {
        pause();
        state.paused = true;
      }
    }

    function pause() {
      cancelAnimationFrame(state.rAF);
    }

    function resume() {
      state.startTime = null;
      state.localDuration = +state.remaining;
      state.localStartVal = +state.printVal;
      requestAnimationFrame(count);
    }

    function reset() {
      state.startTime = null;
      cancelAnimationFrame(state.rAF);
      state.displayValue = formatNumber(props.startVal);
    }

    function count(timestamp) {
      var useEasing = props.useEasing,
          easingFn = props.easingFn,
          endVal = props.endVal;
      if (!state.startTime) state.startTime = timestamp;
      state.timestamp = timestamp;
      var progress = timestamp - state.startTime;
      state.remaining = state.localDuration - progress;

      if (useEasing) {
        if (vue.unref(getCountDown)) {
          state.printVal = state.localStartVal - easingFn(progress, 0, state.localStartVal - endVal, state.localDuration);
        } else {
          state.printVal = easingFn(progress, state.localStartVal, endVal - state.localStartVal, state.localDuration);
        }
      } else {
        if (vue.unref(getCountDown)) {
          state.printVal = state.localStartVal - (state.localStartVal - endVal) * (progress / state.localDuration);
        } else {
          state.printVal = state.localStartVal + (endVal - state.localStartVal) * (progress / state.localDuration);
        }
      }

      if (vue.unref(getCountDown)) {
        state.printVal = state.printVal < endVal ? endVal : state.printVal;
      } else {
        state.printVal = state.printVal > endVal ? endVal : state.printVal;
      }

      state.displayValue = formatNumber(state.printVal);

      if (progress < state.localDuration) {
        state.rAF = requestAnimationFrame(count);
      } else {
        emit('callback');
      }
    }

    function formatNumber(num) {
      var decimals = props.decimals,
          decimal = props.decimal,
          separator = props.separator,
          suffix = props.suffix,
          prefix = props.prefix;
      num = Number(num).toFixed(decimals);
      num += '';
      var x = num.split('.');
      var x1 = x[0];
      var x2 = x.length > 1 ? decimal + x[1] : '';
      var rgx = /(\d+)(\d{3})/;

      if (separator) {
        while (rgx.test(x1)) {
          x1 = x1.replace(rgx, '$1' + separator + '$2');
        }
      }

      return prefix + x1 + x2 + suffix;
    }

    function restart() {
      reset();
      start();
    }

    return {
      count: count,
      reset: reset,
      resume: resume,
      start: start,
      pauseResume: pauseResume,
      restart: restart,
      displayValue: vue.toRef(state, 'displayValue')
    };
  }
};

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("span", null, vue.toDisplayString($setup.displayValue), 1
  /* TEXT */
  );
}

script$4.render = render$4;
script$4.__file = "src/components/count-to/count-to.vue";

script$4.install = function (app) {
  app.component(script$4.name, script$4);
};

var prefixCls = 'bin-loading-bar';
var script$3 = {
  name: 'BLoadingBar',
  props: {
    color: {
      type: String,
      default: 'primary'
    },
    failedColor: {
      type: String,
      default: 'error'
    },
    height: {
      type: Number,
      default: 2
    },
    icon: String
  },
  data: function data() {
    return {
      percent: 0,
      status: 'success',
      show: false
    };
  },
  computed: {
    classes: function classes() {
      return "" + prefixCls;
    },
    innerClasses: function innerClasses() {
      var _ref;

      return [prefixCls + "-inner", (_ref = {}, _ref[prefixCls + "-inner-color-primary"] = this.color === 'primary' && this.status === 'success', _ref[prefixCls + "-inner-failed-color-error"] = this.failedColor === 'error' && this.status === 'error', _ref)];
    },
    outerStyles: function outerStyles() {
      return {
        height: this.height + "px"
      };
    },
    iconClasses: function iconClasses() {
      var _ref2;

      return [(_ref2 = {}, _ref2['icon-color-primary'] = this.color === 'primary' && this.status === 'success', _ref2['icon-failed-color-error'] = this.failedColor === 'error' && this.status === 'error', _ref2)];
    },
    styles: function styles() {
      var style = {
        width: this.percent + "%",
        height: this.height + "px"
      };

      if (this.color !== 'primary' && this.status === 'success') {
        style.backgroundColor = this.color;
      }

      if (this.failedColor !== 'error' && this.status === 'error') {
        style.backgroundColor = this.failedColor;
      }

      return style;
    },
    iconStyle: function iconStyle() {
      var style = {};

      if (this.color !== 'primary' && this.status === 'success') {
        style.color = this.color;
      }

      if (this.failedColor !== 'error' && this.status === 'error') {
        style.color = this.failedColor;
      }

      return style;
    }
  }
};

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade-in"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", {
        class: $options.classes,
        style: $options.outerStyles
      }, [vue.createVNode("div", {
        class: $options.innerClasses,
        style: $options.styles
      }, null, 6
      /* CLASS, STYLE */
      ), $props.icon ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: ["icon", $options.iconClasses]
      }, [vue.createVNode("i", {
        class: "b-iconfont b-icon-" + $props.icon + " icon-is-rotating",
        style: $options.iconStyle
      }, null, 6
      /* CLASS, STYLE */
      )], 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true)], 6
      /* CLASS, STYLE */
      ), [[vue.vShow, $data.show]])];
    }),
    _: 1
    /* STABLE */

  });
}

script$3.render = render$3;
script$3.__file = "src/components/loading-bar/loading-bar.vue";

function getInstance(properties) {
  var _props = properties || {};

  var app = vue.createApp(script$3, _props);
  var loadingBar = app.mount(document.createElement('div'));
  document.body.appendChild(loadingBar.$el);
  return {
    update: function update(options) {
      if ('percent' in options) {
        loadingBar.percent = options.percent;
      }

      if (options.status) {
        loadingBar.status = options.status;
      }

      if ('show' in options) {
        loadingBar.show = options.show;
      }

      if ('icon' in options) {
        loadingBar.icon = options.icon;
      }
    },
    component: loadingBar,
    destroy: function destroy() {
      document.body.removeChild(document.getElementsByClassName('bin-loading-bar')[0]);
    }
  };
}

var loadingBarInstance;
var color$2 = 'primary';
var duration = 800;
var failedColor = 'error';
var height = 2;
var timer;
var icon = undefined; // 获取loadingBar的实例

function getLoadingBarInstance() {
  // 初始化实例
  loadingBarInstance = loadingBarInstance || getInstance({
    color: color$2,
    failedColor: failedColor,
    height: height,
    icon: icon
  });
  return loadingBarInstance;
} // 更新进度并传入配置


function _update(options) {
  var instance = getLoadingBarInstance();
  instance.update(options);
} // 隐藏加载进度


function hide() {
  setTimeout(function () {
    _update({
      show: false
    });

    setTimeout(function () {
      _update({
        percent: 0
      });
    }, 200);
  }, duration);
} // 清除timer


function clearTimer() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
}

var LoadingBar = {
  start: function start() {
    if (timer) return;
    var percent = 0;

    _update({
      percent: percent,
      status: 'success',
      show: true
    }); //  开启模拟动画


    timer = setInterval(function () {
      percent += Math.floor(Math.random() * 3 + 1);

      if (percent > 95) {
        clearTimer();
      }

      _update({
        percent: percent,
        status: 'success',
        show: true
      });
    }, 200);
  },
  update: function update(percent) {
    clearTimer();

    _update({
      percent: percent,
      status: 'success',
      show: true
    });
  },
  done: function done() {
    clearTimer();

    _update({
      percent: 100,
      status: 'success',
      show: true
    });

    hide();
  },
  error: function error() {
    clearTimer();

    _update({
      percent: 100,
      status: 'error',
      show: true
    });

    hide();
  },
  config: function config(options) {
    this.destroy();

    if (options.color) {
      color$2 = options.color;
    }

    if (options.duration) {
      duration = options.duration;
    }

    if (options.failedColor) {
      failedColor = options.failedColor;
    }

    if (options.height) {
      height = options.height;
    }

    if (options.icon) {
      icon = options.icon;
    }
  },
  destroy: function destroy() {
    clearTimer();
    var instance = getLoadingBarInstance();
    loadingBarInstance = null;
    instance.destroy();
  }
};

LoadingBar.install = function (app) {
  app.config.globalProperties.$loadingBar = LoadingBar;
};

var TypeMap$2 = {
  'info': 'info-circle-fill',
  'success': 'check-circle-fill',
  'warning': 'warning-circle-fill',
  'error': 'close-circle-fill'
};
var script$2 = {
  name: 'BMessage',
  props: {
    customClass: {
      type: String,
      default: ''
    },
    useHTML: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 3
    },
    iconClass: {
      type: String,
      default: ''
    },
    id: {
      type: String,
      default: ''
    },
    message: {
      type: [String, Object],
      default: ''
    },
    onClose: {
      type: Function,
      required: true
    },
    showClose: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'info'
    },
    offset: {
      type: Number,
      default: 20
    },
    zIndex: {
      type: Number,
      default: 0
    }
  },
  data: function data() {
    return {
      visible: false,
      closed: false
    };
  },
  computed: {
    typeClass: function typeClass() {
      var type = this.type;
      return type && TypeMap$2[type] ? "bin-message__icon b-iconfont b-icon-" + TypeMap$2[type] + " is-" + type : '';
    },
    customStyle: function customStyle() {
      return {
        top: this.offset + "px",
        zIndex: this.zIndex
      };
    }
  },
  watch: {
    closed: function closed(newVal) {
      if (newVal) {
        this.visible = false;
        on$1(this.$el, 'transitionend', this.destroyElement);
      }
    }
  },
  mounted: function mounted() {
    this.startTimer();
    this.visible = true;
    on$1(document, 'keydown', this.keydown);
  },
  beforeUnmount: function beforeUnmount() {
    off$1(document, 'keydown', this.keydown);
  },
  methods: {
    destroyElement: function destroyElement() {
      this.visible = false;
      off$1(this.$el, 'transitionend', this.destroyElement);
      this.onClose();
    },
    // start counting down to destroy message instance
    startTimer: function startTimer() {
      var _this = this;

      if (this.duration > 0) {
        this.timer = setTimeout(function () {
          if (!_this.closed) {
            _this.close();
          }
        }, this.duration * 1000);
      }
    },
    // clear timer
    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
      this.timer = null;
    },
    // Event handlers
    close: function close() {
      this.closed = true;
      this.timer = null;
    },
    keydown: function keydown(_ref) {
      var code = _ref.code;

      if (code === EVENT_CODE.esc) {
        // press esc to close the message
        if (!this.closed) {
          this.close();
        }
      } else {
        this.startTimer(); // resume timer
      }
    }
  }
};

var _hoisted_1$2 = {
  key: 0,
  class: "bin-message__content"
};
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "bin-message-fade"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", {
        id: $props.id,
        class: ['bin-message', $props.type && !$props.iconClass ? "bin-message--" + $props.type : '', $props.showClose ? 'is-closable' : '', $props.customClass],
        style: $options.customStyle,
        role: "alert",
        onMouseenter: _cache[2] || (_cache[2] = function () {
          return $options.clearTimer && $options.clearTimer.apply($options, arguments);
        }),
        onMouseleave: _cache[3] || (_cache[3] = function () {
          return $options.startTimer && $options.startTimer.apply($options, arguments);
        })
      }, [$props.type || $props.iconClass ? (vue.openBlock(), vue.createBlock("i", {
        key: 0,
        class: [$options.typeClass, $props.iconClass]
      }, null, 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true), vue.renderSlot(_ctx.$slots, "default", {}, function () {
        return [!$props.useHTML ? (vue.openBlock(), vue.createBlock("p", _hoisted_1$2, vue.toDisplayString($props.message), 1
        /* TEXT */
        )) : (vue.openBlock(), vue.createBlock("p", {
          key: 1,
          class: "bin-message__content",
          innerHTML: $props.message
        }, null, 8
        /* PROPS */
        , ["innerHTML"]))];
      }), $props.showClose ? (vue.openBlock(), vue.createBlock("div", {
        key: 1,
        class: "b-iconfont b-icon-close",
        onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
          return $options.close && $options.close.apply($options, arguments);
        }, ["stop"]))
      })) : vue.createCommentVNode("v-if", true)], 46
      /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
      , ["id"]), [[vue.vShow, $data.visible]])];
    }),
    _: 3
    /* FORWARDED */

  });
}

script$2.render = render$2;
script$2.__file = "src/components/message/message.vue";

var vm$1;
var instances = [];
var seed$1 = 1;

var Message = function Message(opts) {
  if (isServer) return;

  if (typeof opts === 'string') {
    opts = {
      message: opts
    };
  }

  var options = opts;
  var verticalOffset = opts.offset || 20;
  instances.forEach(function (_ref) {
    var vm = _ref.vm;
    verticalOffset += (vm.el.offsetHeight || 0) + 16;
  });
  verticalOffset += 16;
  var id = 'message_' + seed$1++;
  var userOnClose = options.onClose;
  options = _extends$2({
    offset: verticalOffset,
    id: id,
    zIndex: transferIncrease()
  }, options, {
    onClose: function onClose() {
      close$1(id, userOnClose);
    }
  });
  var container = document.createElement('div');
  container.className = "container_" + id;
  var message = options.message;
  vm$1 = vue.createVNode(script$2, options, vue.isVNode(options.message) ? {
    default: function _default() {
      return message;
    }
  } : null);
  vue.render(vm$1, container);
  instances.push({
    vm: vm$1,
    $el: container
  });
  document.body.appendChild(container);
  return {
    close: options.onClose
  };
};

function close$1(id, userOnClose) {
  var idx = instances.findIndex(function (_ref2) {
    var vm = _ref2.vm;
    var _id = vm.component.props.id;
    return id === _id;
  });

  if (idx === -1) {
    return;
  }

  var _instances$idx = instances[idx],
      vm = _instances$idx.vm,
      $el = _instances$idx.$el;
  if (!vm) return;
  userOnClose == null ? void 0 : userOnClose(vm);
  var removedHeight = vm.el.offsetHeight;
  vue.render(null, $el);
  vue.nextTick(function () {
    document.body.removeChild($el);
  });
  instances.splice(idx, 1); // adjust other instances vertical offset

  var len = instances.length;
  if (len < 1) return;

  for (var i = idx; i < len; i++) {
    var pos = parseInt(instances[i].vm.el.style['top'], 10) - removedHeight - 16;
    instances[i].vm.component.props.offset = pos;
    instances[i].vm.component.props.vertOffset = pos;
  }
}
function closeAll() {
  for (var i = instances.length - 1; i >= 0; i--) {
    var instance = instances[i].vm.component;
    instance.ctx.close();
  }
}
['success', 'warning', 'info', 'error'].forEach(function (type) {
  Message[type] = function (options) {
    if (typeof options === 'string') {
      options = {
        message: options,
        type: type
      };
    } else {
      options.type = type;
    }

    return Message(options);
  };
});
Message.closeAll = closeAll;

Message.install = function (app) {
  app.config.globalProperties.$message = Message;
};

var TypeMap$1 = {
  'info': 'info-circle',
  'success': 'check-circle',
  'warning': 'warning-circle',
  'error': 'close-circle'
};
var script$1 = {
  name: 'BMessageBox',
  components: {
    BMask: script$15,
    BButton: script$1B
  },
  props: {
    beforeClose: {
      type: Function,
      default: undefined
    },
    callback: Function,
    cancelText: {
      type: String,
      default: '取消'
    },
    cancelButtonClass: String,
    maskClosable: {
      type: Boolean,
      default: true
    },
    escClosable: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    confirmText: {
      type: String,
      default: '确定'
    },
    confirmButtonClass: String,
    container: {
      type: String,
      // default append to body
      default: 'body'
    },
    customClass: String,
    useHTML: Boolean,
    iconClass: String,
    lockScroll: {
      type: Boolean,
      default: true
    },
    message: [String, Object],
    modalFade: {
      // implement this feature
      type: Boolean,
      default: true
    },
    modalClass: String,
    mask: {
      type: Boolean,
      default: true
    },
    showCancelButton: Boolean,
    showConfirmButton: {
      type: Boolean,
      default: true
    },
    type: String,
    title: String,
    zIndex: Number
  },
  emits: ['vanish', 'action'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    // const popup = usePopup(props, doClose)
    var visible = vue.ref(false); // s represents state

    var state = vue.reactive({
      action: '',
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      cancelText: props.cancelText,
      confirmButtonDisabled: false,
      confirmText: props.confirmText,
      zIndex: transferIncrease()
    });
    var icon = vue.computed(function () {
      return props.iconClass || (props.type && TypeMap$1[props.type] ? TypeMap$1[props.type] : '');
    });
    var hasMessage = vue.computed(function () {
      return !!props.message;
    });
    var confirmRef = vue.ref(null);
    var confirmButtonClasses = vue.computed(function () {
      return "b-button--primary " + props.confirmButtonClass;
    });
    vue.watch(function () {
      return visible.value;
    }, function (val) {
      if (val) {
        if (props.type === 'alert' || props.type === 'confirm') {
          vue.nextTick().then(function () {
            var _confirmRef$value, _confirmRef$value$$el;

            (_confirmRef$value = confirmRef.value) == null ? void 0 : (_confirmRef$value$$el = _confirmRef$value.$el) == null ? void 0 : _confirmRef$value$$el.focus == null ? void 0 : _confirmRef$value$$el.focus();
          });
        }

        state.zIndex = transferIncrease();
      }
    });
    vue.onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return vue.nextTick();

            case 2:
              if (props.closeOnHashChange) {
                on$1(window, 'hashchange', doClose);
              }

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    vue.onBeforeUnmount(function () {
      if (props.closeOnHashChange) {
        off$1(window, 'hashchange', doClose);
      }
    });

    function doClose() {
      if (!visible.value) return;
      visible.value = false;
      vue.nextTick(function () {
        if (state.action) emit('action', state.action);
      });
    }

    var handleWrapperClick = function handleWrapperClick() {
      if (props.maskClosable) {
        handleAction('cancel');
      }
    };

    var handleAction = function handleAction(action) {
      state.action = action;

      if (props.beforeClose) {
        props.beforeClose == null ? void 0 : props.beforeClose(action, state, doClose);
      } else {
        doClose();
      }
    };

    var handleClose = function handleClose() {
      handleAction('close');
    };

    if (props.escClosable) {
      useModal({
        handleClose: handleClose
      }, visible);
    } // locks the screen to prevent scroll


    if (props.lockScroll) {
      useLockScreen(visible);
    } // restore to prev active element.


    useRestoreActive(visible);
    return {
      state: state,
      visible: visible,
      hasMessage: hasMessage,
      icon: icon,
      confirmButtonClasses: confirmButtonClasses,
      confirmRef: confirmRef,
      doClose: doClose,
      // for outside usage
      handleClose: handleClose,
      // for out side usage
      handleWrapperClick: handleWrapperClick,
      handleAction: handleAction
    };
  }
};

var _hoisted_1$1 = {
  key: 0,
  class: "bin-message-box__header"
};
var _hoisted_2$1 = {
  class: "bin-message-box__title"
};
var _hoisted_3 = {
  key: 1,
  class: "bin-message-box__message"
};
var _hoisted_4 = {
  key: 0
};
var _hoisted_5 = {
  class: "bin-message-box__footer"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_b_button = vue.resolveComponent("b-button");

  var _component_b_mask = vue.resolveComponent("b-mask");

  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[3] || (_cache[3] = function ($event) {
      return _ctx.$emit('vanish');
    })
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode(_component_b_mask, {
        "z-index": $setup.state.zIndex,
        "mask-class": ['is-message-box', $props.modalClass],
        mask: $props.mask,
        onClick: vue.withModifiers($setup.handleWrapperClick, ["self"])
      }, {
        default: vue.withCtx(function () {
          return [vue.createVNode("div", {
            ref: "root",
            "aria-label": $props.title || 'dialog',
            "aria-modal": "true",
            class: ['bin-message-box', $props.customClass]
          }, [$props.title !== null && $props.title !== undefined ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$1, [$setup.icon ? (vue.openBlock(), vue.createBlock("i", {
            key: 0,
            class: ['bin-message-box__status', "b-iconfont b-icon-" + $setup.icon + " is-" + $props.type]
          }, null, 2
          /* CLASS */
          )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_2$1, [vue.createVNode("span", null, vue.toDisplayString($props.title), 1
          /* TEXT */
          )])])) : vue.createCommentVNode("v-if", true), $setup.hasMessage ? (vue.openBlock(), vue.createBlock("div", _hoisted_3, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
            return [!$props.useHTML ? (vue.openBlock(), vue.createBlock("p", _hoisted_4, vue.toDisplayString($props.message), 1
            /* TEXT */
            )) : (vue.openBlock(), vue.createBlock("p", {
              key: 1,
              innerHTML: $props.message
            }, null, 8
            /* PROPS */
            , ["innerHTML"]))];
          })])) : vue.createCommentVNode("v-if", true), vue.createVNode("div", _hoisted_5, [$props.showCancelButton ? (vue.openBlock(), vue.createBlock(_component_b_button, {
            key: 0,
            loading: $setup.state.cancelButtonLoading,
            class: [$props.cancelButtonClass],
            onClick: _cache[1] || (_cache[1] = function ($event) {
              return $setup.handleAction('cancel');
            })
          }, {
            default: vue.withCtx(function () {
              return [vue.createTextVNode(vue.toDisplayString($setup.state.cancelText), 1
              /* TEXT */
              )];
            }),
            _: 1
            /* STABLE */

          }, 8
          /* PROPS */
          , ["loading", "class"])) : vue.createCommentVNode("v-if", true), vue.withDirectives(vue.createVNode(_component_b_button, {
            ref: "confirmRef",
            loading: $setup.state.confirmButtonLoading,
            class: [$setup.confirmButtonClasses],
            type: "primary",
            disabled: $setup.state.confirmButtonDisabled,
            onClick: _cache[2] || (_cache[2] = function ($event) {
              return $setup.handleAction('confirm');
            })
          }, {
            default: vue.withCtx(function () {
              return [vue.createTextVNode(vue.toDisplayString($setup.state.confirmText), 1
              /* TEXT */
              )];
            }),
            _: 1
            /* STABLE */

          }, 8
          /* PROPS */
          , ["loading", "class", "disabled"]), [[vue.vShow, $props.showConfirmButton]])])], 10
          /* CLASS, PROPS */
          , ["aria-label"])];
        }),
        _: 3
        /* FORWARDED */

      }, 8
      /* PROPS */
      , ["z-index", "mask-class", "mask", "onClick"]), [[vue.vShow, $setup.visible]])];
    }),
    _: 1
    /* STABLE */

  });
}

script$1.render = render$1;
script$1.__file = "src/components/message-box/message-box.vue";

var messageInstance = new Map();

var initInstance = function initInstance(props, container) {
  var vnode = vue.h(script$1, props);
  vue.render(vnode, container);
  document.body.appendChild(container.firstElementChild);
  return vnode.component;
};

var genContainer = function genContainer() {
  return document.createElement('div');
};

var showMessage = function showMessage(options) {
  var container = genContainer(); // Adding destruct method.
  // when transition leaves emitting `vanish` evt. so that we can do the clean job.

  options.onVanish = function () {
    // not sure if this causes mem leak, need proof to verify that.
    // maybe calling out like 1000 msg-box then close them all.
    vue.render(null, container);
    messageInstance.delete(vm); // Remove vm to avoid mem leak.
    // here we were suppose to call document.body.removeChild(container.firstElementChild)
    // but render(null, container) did that job for us. so that we do not call that directly
  };

  options.onAction = function (action) {
    var currentMsg = messageInstance.get(vm);
    var resolve = action;

    if (options.callback) {
      options.callback(resolve, instance.proxy);
    } else {
      if (action === 'cancel') {
        currentMsg.reject('cancel');
      } else {
        currentMsg.resolve(resolve);
      }
    }
  };

  var instance = initInstance(options, container); // This is how we use message box programmably.
  // Maybe consider releasing a template version?
  // get component instance like v2.

  var vm = instance.proxy;

  if (vue.isVNode(options.message)) {
    // Override slots since message is vnode type.
    instance.slots.default = function () {
      return [options.message];
    };
  } // change visibility after everything is settled


  vm.visible = true;
  return vm;
};

function MessageBox(options) {
  if (isServer) return;
  var callback = options.callback;
  return new Promise(function (resolve, reject) {
    var vm = showMessage(options); // collect this vm in order to handle upcoming events.

    messageInstance.set(vm, {
      options: options,
      callback: callback,
      resolve: resolve,
      reject: reject
    });
  });
}

MessageBox.alert = function (options) {
  return MessageBox(Object.assign({
    type: 'alert',
    escClosable: false,
    maskClosable: false
  }, options));
};

MessageBox.confirm = function (options) {
  return MessageBox(Object.assign({
    type: 'confirm',
    showCancelButton: true
  }, options));
};

MessageBox.close = function () {
  // instance.setupInstall.doClose()
  // instance.setupInstall.state.visible = false
  messageInstance.forEach(function (_, vm) {
    vm.doClose();
  });
  messageInstance.clear();
};

MessageBox.install = function (app) {
  app.config.globalProperties.$messageBox = MessageBox;
  app.config.globalProperties.$alert = MessageBox.alert;
  app.config.globalProperties.$confirm = MessageBox.confirm;
};

var TypeMap = {
  'info': 'info-circle-fill',
  'success': 'check-circle-fill',
  'warning': 'warning-circle-fill',
  'error': 'close-circle-fill'
};
var script = {
  name: 'BNotice',
  props: {
    customClass: {
      type: String,
      default: ''
    },
    useHTML: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 4.5
    },
    iconClass: {
      type: String,
      default: ''
    },
    id: {
      type: String,
      default: ''
    },
    message: {
      type: [String, Object],
      default: ''
    },
    offset: {
      type: Number,
      default: 0
    },
    onClick: {
      type: Function
    },
    onClose: {
      type: Function,
      required: true
    },
    position: {
      type: String,
      default: 'top-right'
    },
    showClose: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: ''
    },
    zIndex: {
      type: Number,
      default: 0
    }
  },
  emits: ['close', 'click'],
  setup: function setup(props) {
    var typeClass = vue.computed(function () {
      var type = props.type;
      return type && TypeMap[type] ? "b-iconfont b-icon-" + TypeMap[type] + " is-" + type : '';
    });
    var horizontalClass = vue.computed(function () {
      return props.position.indexOf('right') > 1 ? 'right' : 'left';
    });
    var verticalProperty = vue.computed(function () {
      return props.position.startsWith('top') ? 'top' : 'bottom';
    });
    var noticeStyles = vue.computed(function () {
      var _ref;

      return _ref = {}, _ref[verticalProperty.value] = props.offset + "px", _ref.zIndex = props.zIndex, _ref;
    });
    var visible = vue.ref(false);
    var closed = vue.ref(false);
    var timer = vue.ref(null);
    return {
      horizontalClass: horizontalClass,
      typeClass: typeClass,
      noticeStyles: noticeStyles,
      verticalProperty: verticalProperty,
      visible: visible,
      closed: closed,
      timer: timer
    };
  },
  watch: {
    closed: function closed(newVal) {
      if (newVal) {
        this.visible = false;
        on$1(this.$el, 'transitionend', this.destroyElement);
      }
    }
  },
  mounted: function mounted() {
    this.startTimer();
    this.visible = true;
    on$1(document, 'keydown', this.keydown);
  },
  beforeUnmount: function beforeUnmount() {
    off$1(document, 'keydown', this.keydown);
  },
  methods: {
    destroyElement: function destroyElement() {
      this.visible = false;
      off$1(this.$el, 'transitionend', this.destroyElement);
      this.onClose();
    },
    // start counting down to destroy notification instance
    startTimer: function startTimer() {
      var _this = this;

      if (this.duration > 0) {
        this.timer = setTimeout(function () {
          if (!_this.closed) {
            _this.close();
          }
        }, this.duration * 1000);
      }
    },
    // clear timer
    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
      this.timer = null;
    },
    // Event handlers
    click: function click() {
      this == null ? void 0 : this.onClick();
    },
    close: function close() {
      this.closed = true;
      this.timer = null;
    },
    keydown: function keydown(_ref2) {
      var code = _ref2.code;

      if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
        this.clearTimer(); // press delete/backspace clear timer
      } else if (code === EVENT_CODE.esc) {
        // press esc to close the notification
        if (!this.closed) {
          this.close();
        }
      } else {
        this.startTimer(); // resume timer
      }
    }
  }
};

var _hoisted_1 = {
  class: "bin-notice__content"
};
var _hoisted_2 = {
  key: 0
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "bin-notice-fade"
  }, {
    default: vue.withCtx(function () {
      return [vue.withDirectives(vue.createVNode("div", {
        id: $props.id,
        class: ['bin-notice', $props.customClass, $setup.horizontalClass],
        style: $setup.noticeStyles,
        role: "alert",
        onMouseenter: _cache[2] || (_cache[2] = function ($event) {
          return $options.clearTimer();
        }),
        onMouseleave: _cache[3] || (_cache[3] = function ($event) {
          return $options.startTimer();
        }),
        onClick: _cache[4] || (_cache[4] = function () {
          return $options.click && $options.click.apply($options, arguments);
        })
      }, [$props.type || $props.iconClass ? (vue.openBlock(), vue.createBlock("i", {
        key: 0,
        class: ["bin-notice__icon", [$setup.typeClass, $props.iconClass]]
      }, null, 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true), vue.createVNode("div", {
        class: ["bin-notice__group", {
          'is-with-icon': $setup.typeClass || $props.iconClass
        }]
      }, [vue.createVNode("h2", {
        class: "bin-notice__title",
        textContent: vue.toDisplayString($props.title)
      }, null, 8
      /* PROPS */
      , ["textContent"]), vue.withDirectives(vue.createVNode("div", _hoisted_1, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
        return [!$props.useHTML ? (vue.openBlock(), vue.createBlock("p", _hoisted_2, vue.toDisplayString($props.message), 1
        /* TEXT */
        )) : (vue.openBlock(), vue.createBlock("p", {
          key: 1,
          innerHTML: $props.message
        }, null, 8
        /* PROPS */
        , ["innerHTML"]))];
      })], 512
      /* NEED_PATCH */
      ), [[vue.vShow, $props.message]]), $props.showClose ? (vue.openBlock(), vue.createBlock("div", {
        key: 0,
        class: "b-iconfont b-icon-close",
        onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
          return $options.close && $options.close.apply($options, arguments);
        }, ["stop"]))
      })) : vue.createCommentVNode("v-if", true)], 2
      /* CLASS */
      )], 46
      /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
      , ["id"]), [[vue.vShow, $setup.visible]])];
    }),
    _: 3
    /* FORWARDED */

  });
}

script.render = render;
script.__file = "src/components/notice/notice.vue";

var vm;
var notifications = [];
var seed = 1;

var Notice = function Notice(options) {
  if (isServer) return;
  var position = options.position || 'top-right';
  var verticalOffset = options.offset || 0;
  notifications.filter(function (_ref) {
    var vm = _ref.vm;
    return vm.component.props.position === position;
  }).forEach(function (_ref2) {
    var vm = _ref2.vm;
    verticalOffset += (vm.el.offsetHeight || 0) + 16;
  });
  verticalOffset += 16;
  var id = 'notification_' + seed++;
  var userOnClose = options.onClose;
  options = _extends$2({
    offset: verticalOffset,
    id: id,
    useHTML: false,
    duration: 4.5,
    position: 'top-right',
    showClose: true,
    zIndex: transferIncrease()
  }, options, {
    onClose: function onClose() {
      close(id, userOnClose);
    }
  });
  var container = document.createElement('div');
  container.className = "container_" + id;
  container.style.zIndex = String();
  var message = options.message;
  vm = vue.createVNode(script, options, vue.isVNode(options.message) ? {
    default: function _default() {
      return message;
    }
  } : null);
  vue.render(vm, container);
  notifications.push({
    vm: vm,
    $el: container
  });
  document.body.appendChild(container);
  return {
    close: options.onClose
  };
};

function close(id, userOnClose) {
  var idx = notifications.findIndex(function (_ref3) {
    var vm = _ref3.vm;
    var _id = vm.component.props.id;
    return id === _id;
  });

  if (idx === -1) {
    return;
  }

  var _notifications$idx = notifications[idx],
      vm = _notifications$idx.vm,
      $el = _notifications$idx.$el;
  if (!vm) return;
  userOnClose == null ? void 0 : userOnClose(vm);
  var removedHeight = vm.el.offsetHeight;
  vue.render(null, $el);
  vue.nextTick(function () {
    document.body.removeChild($el);
  });
  notifications.splice(idx, 1);
  var len = notifications.length;
  if (len < 1) return;
  var position = vm.props.position;

  for (var i = idx; i < len; i++) {
    if (notifications[i].vm.component.props.position === position) {
      var verticalPos = vm.props.position.split('-')[0];
      var pos = parseInt(notifications[i].vm.el.style[verticalPos], 10) - removedHeight - 16;
      notifications[i].vm.component.props.offset = pos;
      notifications[i].vm.el.style[verticalPos] = pos; // requestAnimationFrame(() => {
      //   render(notifications[i].vm, notifications[i].$el)
      // })
    }
  }
}
['success', 'warning', 'info', 'error'].forEach(function (type) {
  var _Object$assign;

  Object.assign(Notice, (_Object$assign = {}, _Object$assign[type] = function (options) {
    if (typeof options === 'string' || vue.isVNode(options)) {
      options = {
        message: options
      };
    }

    options.type = type;
    return Notice(options);
  }, _Object$assign));
});

Notice.install = function (app) {
  app.config.globalProperties.$notice = Notice;
};

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

var colorString = createCommonjsModule(function (module) {
/* MIT license */



var reverseNames = {};

// create a list of reverse color names
for (var name in colorName$1) {
	if (colorName$1.hasOwnProperty(name)) {
		reverseNames[colorName$1[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorName$1[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var conversions = createCommonjsModule(function (module) {
/* MIT license */


// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in colorName) {
	if (colorName.hasOwnProperty(key)) {
		reverseKeywords[colorName[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in colorName) {
		if (colorName.hasOwnProperty(keyword)) {
			var value = colorName[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return colorName[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};
});

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(colorConvert).forEach(function (model) {
	hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in colorConvert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = colorConvert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = colorConvert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = colorConvert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = colorConvert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = colorConvert[this.model].channels;
		var labels = colorConvert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorConvert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(colorConvert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = colorConvert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

var color$1 = Color;

/**
 * 依赖color插件，在此基础上封装部分转换函数
 * 参考文档说明：https://www.npmjs.com/package/color
 */

function getPalette(color) {
  var normalColor = color$1(color).hex().toString().toLowerCase(); // active

  var darkColor1 = mixBlack(normalColor, 0.1);
  var darkColor2 = mixBlack(normalColor, 0.2);
  var darkColor3 = mixBlack(normalColor, 0.3);
  var darkColor4 = mixBlack(normalColor, 0.4); // light

  var lightColor1 = mixWhite(normalColor, 0.2);
  var lightColor2 = mixWhite(normalColor, 0.4);
  var lightColor3 = mixWhite(normalColor, 0.6);
  var lightColor4 = mixWhite(normalColor, 0.8);
  var lightColor5 = mixWhite(normalColor, 0.9);
  var lightColor6 = mixWhite(normalColor, 0.95);
  return [darkColor4, darkColor3, darkColor2, darkColor1, normalColor, lightColor1, lightColor2, lightColor3, lightColor4, lightColor5, lightColor6];
} // getObject

function toObject(color) {
  return color$1(color).object();
} // getHex

function toHex(color, toLowerCase) {
  if (toLowerCase === void 0) {
    toLowerCase = true;
  }

  var hex = color$1(color).hex().toString();
  return toLowerCase ? hex.toLowerCase() : hex;
} // getRgbArr

function toRgbArr(color) {
  return color$1(color).rgb().array();
} // getHslArr

function toHslArr(color) {
  return color$1(color).hsl();
} // grayscale

function grayscale(color) {
  return color$1(color).grayscale().toString();
}
/**
 * 两个颜色值比较
 */

function isEqual(color1, color2) {
  return color$1(color1).toString() === color$1(color2).toString();
} // 是否是light

function isLight(color) {
  return color$1(color).isLight();
} // 是否是light

function isDark(color) {
  return color$1(color).isDark();
}
/**
 * 混合色，浓度
 */

function mix(mixColor, color, concentration) {
  return color$1(color).mix(color$1(mixColor), concentration).hex().toLowerCase();
}
function mixWhite(color, concentration) {
  return mix('#ffffff', color, concentration);
}
function mixBlack(color, concentration) {
  return mix('#000000', color, concentration);
}
function alpha(color, alpha) {
  return color$1(color).alpha(alpha).toString();
}
function fade(color, fade) {
  return color$1(color).fade(fade).toString();
}
function lighten(color, concentration) {
  return color$1(color).lighten(concentration).toString();
}
function darken(color, concentration) {
  return color$1(color).darken(concentration).toString();
}

var color = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getPalette: getPalette,
  toObject: toObject,
  toHex: toHex,
  toRgbArr: toRgbArr,
  toHslArr: toHslArr,
  grayscale: grayscale,
  isEqual: isEqual,
  isLight: isLight,
  isDark: isDark,
  mix: mix,
  mixWhite: mixWhite,
  mixBlack: mixBlack,
  alpha: alpha,
  fade: fade,
  lighten: lighten,
  darken: darken
});

var name = "bin-ui-next";
var version$1 = "0.5.0";
var keywords = [
	"bin-ui-next",
	"bin-ui",
	"bin",
	"ui",
	"vue",
	"vue3",
	"components"
];
var author = "wangbin";
var files = [
	"lib",
	"src"
];
var main = "lib/bin-ui.common.js";
var module$1 = "lib/bin-ui.esm.js";
var unpkg = "lib/bin-ui.global.js";
var style = "lib/styles/index.css";
var homepage = "https://wangbin3162.gitee.io/bin-ui-next/";
var license = "MIT";
var scripts = {
	dev: "webpack-dev-server --config build/webpack.dev.js",
	"build:demo": "rimraf docs && cross-env NODE_ENV=production webpack --config build/webpack.dev.js",
	build: "yarn clean-lib && yarn build:lib && yarn build:style",
	"clean-lib": "rimraf lib",
	"build:lib": "rollup --config ./build/rollup.config.js",
	"build:style": "gulp --gulpfile ./build/gulpfile.js",
	lint: "eslint ./src --ext .vue,.js,.ts",
	"lint-fix": "eslint --fix ./src --ext .vue,.js,.ts"
};
var dependencies = {
	"@popperjs/core": "^2.9.2",
	"async-validator": "^3.4.0",
	color: "^3.1.3",
	dayjs: "^1.10.4",
	lodash: "^4.17.21",
	mitt: "^2.1.0",
	"resize-observer-polyfill": "^1.5.1",
	sortablejs: "^1.10.2"
};
var peerDependencies = {
	vue: "3.0.11"
};
var devDependencies = {
	"@babel/core": "^7.11.4",
	"@babel/polyfill": "^7.12.1",
	"@babel/preset-env": "^7.11.5",
	"@rollup/plugin-babel": "^5.2.2",
	"@rollup/plugin-commonjs": "^15.1.0",
	"@rollup/plugin-json": "^4.1.0",
	"@rollup/plugin-node-resolve": "^9.0.0",
	"@rollup/plugin-replace": "^2.3.4",
	"@vue/babel-plugin-jsx": "^1.0.0",
	"@vue/compiler-sfc": "3.0.11",
	"babel-eslint": "^10.1.0",
	"babel-loader": "^8.2.2",
	"babel-plugin-transform-class-properties": "^6.24.1",
	"cross-env": "^7.0.2",
	"css-loader": "^4.2.2",
	"css-minimizer-webpack-plugin": "^1.1.5",
	eslint: "^7.7.0",
	"eslint-plugin-vue": "^7.5.0",
	"file-loader": "^6.0.0",
	"file-save": "^0.2.0",
	gulp: "^4.0.2",
	"gulp-autoprefixer": "^7.0.1",
	"gulp-cssmin": "^0.2.0",
	"gulp-stylus": "^2.7.0",
	"highlight.js": "^11.0.1",
	"html-webpack-plugin": "^4.3.0",
	"markdown-it": "^12.0.4",
	"markdown-it-anchor": "^7.0.0",
	"markdown-it-chain": "^1.3.0",
	"markdown-it-container": "^3.0.0",
	"mini-css-extract-plugin": "^0.11.2",
	prettier: "^1.19.1",
	rimraf: "^3.0.2",
	rollup: "^2.28.2",
	"rollup-plugin-css-only": "^2.1.0",
	"rollup-plugin-peer-deps-external": "^2.2.4",
	"rollup-plugin-stylus": "^1.0.4",
	"rollup-plugin-terser": "^7.0.2",
	"rollup-plugin-vue": "^6.0.0-beta.11",
	"style-loader": "^1.2.1",
	stylus: "^0.54.8",
	"stylus-loader": "3.0.2",
	transliteration: "^2.2.0",
	"url-loader": "^4.1.1",
	vue: "3.0.11",
	"vue-loader": "^16.1.2",
	"vue-router": "^4.0.2",
	webpack: "^4.44.1",
	"webpack-bundle-analyzer": "^3.9.0",
	"webpack-cli": "^3.3.12",
	"webpack-dev-server": "^3.11.0"
};
var config = {
	name: name,
	version: version$1,
	keywords: keywords,
	author: author,
	files: files,
	main: main,
	module: module$1,
	unpkg: unpkg,
	style: style,
	homepage: homepage,
	"private": false,
	license: license,
	scripts: scripts,
	dependencies: dependencies,
	peerDependencies: peerDependencies,
	devDependencies: devDependencies
};

var version = config.version; // version_ to fix tsc issue

var Utils = {
  util: util,
  color: color,
  log: log
};
var components = [script$1K, script$1J, script$1I, script$1A, script$1B, script$1z, script$1y, script$1C, script$1H, script$1x, script$1w, Space, script$1G, script$1u, script$1t, script$1F, script$1s, Tooltip, script$1q, script$1p, script$1o, script$1n, script$1m, script$1l, script$1k, script$1i, script$1h, script$1g, script$1f, script$1e, script$1d, script$1c, script$1b, script$b, script$c, script$1a, script$19, script$18, script$17, script$16, script$14, script$13, script$12, script$11, script$10, script$$, script$Y, script$X, script$W, script$V, script$1D, script$U, script$T, script$Q, script$P, script$S, script$R, script$N, script$M, script$J, script$K, script$I, script$F, script$H, script$E, script$C, script$y, script$z, script$h, script$e, script$1E, script$a, script$t, TimePicker, DatePicker, script$5, script$4];
var plugins = [LoadingBar, Message, MessageBox, Notice];
var defaultInstallOpt = {
  zIndex: 2000
};

var install = function install(app, options) {
  if (options === void 0) {
    options = {};
  }

  components.forEach(function (component) {
    app.use(component);
  });
  plugins.forEach(function (plugin) {
    app.use(plugin);
  }); // 注册全局指令

  app.directive('Waves', Waves);
  app.directive('ClickAnimation', ClickAnimation);
  app.directive('ClickOutside', ClickOutside);
  app.directive('NoData', EmptyDirective);
  app.directive('Loading', LoadingDirective); // 注册全局函数和属性

  app.config.globalProperties.$global = _extends$2({}, defaultInstallOpt, options);
  setConfig(_extends$2({}, defaultInstallOpt, options));
  app.config.globalProperties.$title = title;
  app.config.globalProperties.$open = open;
  app.config.globalProperties.$copy = copy;
  app.config.globalProperties.$parseTime = parseTime;
  app.config.globalProperties.$rangeTime = rangeTime;
  app.config.globalProperties.$typeOf = typeOf;
  app.config.globalProperties.$deepCopy = deepCopy;
  app.config.globalProperties.$getRandomInt = getRandomInt;
  app.config.globalProperties.$throttle = throttle$2;
  app.config.globalProperties.$debounce = debounce;
  app.config.globalProperties.$isEqual = isEqual$1;
  app.config.globalProperties.$scrollTop = scrollTop;
  app.config.globalProperties.$shuffle = shuffle;
  app.config.globalProperties.$log = log;
  app.config.globalProperties.$color = color;

  if (!options.disabledDoc) {
    log.pretty("[" + config.name + "] " + config.version, config.homepage);
  }

  return app;
};
var index = {
  version: version,
  install: install
};

exports.BAffix = script$1m;
exports.BAlert = script$17;
exports.BAnchor = script$1K;
exports.BAnchorLink = script$1J;
exports.BBackTop = script$1y;
exports.BBadge = script$12;
exports.BBigTree = script$M;
exports.BBreadcrumb = script$1l;
exports.BBreadcrumbItem = script$1k;
exports.BButton = script$1B;
exports.BButtonGroup = script$1z;
exports.BCalendar = script$18;
exports.BCard = script$13;
exports.BCarousel = script$1a;
exports.BCarouselItem = script$19;
exports.BCascader = script$y;
exports.BCascaderPanel = script$z;
exports.BCheckbox = script$S;
exports.BCheckboxGroup = script$R;
exports.BCircle = script$W;
exports.BCol = script$1w;
exports.BCollapse = script$11;
exports.BCollapsePanel = script$10;
exports.BCollapseTransition = script$1u;
exports.BCollapseWrap = script$$;
exports.BColorPicker = script$t;
exports.BCountTo = script$4;
exports.BDatePicker = DatePicker;
exports.BDesc = script$J;
exports.BDescItem = script$K;
exports.BDivider = script$1t;
exports.BDrawer = script$16;
exports.BDropdown = script$1f;
exports.BDropdownItem = script$1e;
exports.BDropdownMenu = script$1d;
exports.BEmpty = script$1H;
exports.BForm = script$1E;
exports.BFormItem = script$a;
exports.BIcon = script$1I;
exports.BIconSelect = script$1A;
exports.BInput = script$1D;
exports.BInputNumber = script$U;
exports.BLoading = script$1G;
exports.BMenu = script$1q;
exports.BMenuItem = script$1p;
exports.BMenuItemGroup = script$1n;
exports.BModal = script$14;
exports.BOption = script$H;
exports.BOptionGroup = script$E;
exports.BPage = script$C;
exports.BPopover = script$1s;
exports.BPopper = script$1F;
exports.BProgress = script$V;
exports.BRadio = script$Q;
exports.BRadioGroup = script$P;
exports.BRate = script$I;
exports.BRow = script$1x;
exports.BScrollbar = script$1C;
exports.BSelect = script$F;
exports.BSkeleton = script$b;
exports.BSkeletonItem = script$c;
exports.BSlider = script$e;
exports.BSpace = Space;
exports.BSplit = script$Y;
exports.BStep = script$1g;
exports.BSteps = script$1h;
exports.BSubmenu = script$1o;
exports.BSwitch = script$T;
exports.BTable = script$5;
exports.BTabs = script$1i;
exports.BTag = script$X;
exports.BTimePicker = TimePicker;
exports.BTimeline = script$1c;
exports.BTimelineItem = script$1b;
exports.BTooltip = Tooltip;
exports.BTree = script$N;
exports.BUpload = script$h;
exports.LoadingBar = LoadingBar;
exports.Message = Message;
exports.MessageBox = MessageBox;
exports.Notice = Notice;
exports.Utils = Utils;
exports.default = index;
